<!DOCTYPE html>
<html lang="ja">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="ja">

    <meta name="author" content="Tasuku NAKAGAWA">
    <meta name="description" content="4完．コード
A - Kth Term 実装するだけ． Javaの場合は問題文をコピペしてfinal int[] array = {1, 1, ...};と宣言すると早い．
B - Bishop ここに一番時間を吸われた．
問題例を見ると最終的に(h * w &#43; 1) / 2でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．
C - Sqrt Inequality ここにも時間を吸われた．
Math#sqrtを使うと解けそうな気がするが，精度の都合上間違いになることがある． 今回は式変換を行うと4ab &lt; a^2 &#43; b^2 &#43; c^2 &#43; 2ab - 2bc - 2caに持っていけるので，そこに代入するだけ． あるいはBigDecimalを使っても大丈夫らしい．
D - String Equivalence 偶然通った問題．
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 &#43; 1までしか使えないことに注意．
E - Three Substrings 全探索の問題．ここを参考にした．
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう． 以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる． コードだとこんな感じ．
private static boolean[] init(final int length, final String a, final String b) {// 配列の初期化 final boolean[] array = new boolean[length]; // lengthは十分大きい値 Arrays.">
    <meta name="keywords" content="">

    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="パナソニックプログラミングコンテスト2020の解説">
  <meta name="twitter:description" content="4完．コード
A - Kth Term 実装するだけ． Javaの場合は問題文をコピペしてfinal int[] array = {1, 1, ...};と宣言すると早い．
B - Bishop ここに一番時間を吸われた．
問題例を見ると最終的に(h * w &#43; 1) / 2でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．
C - Sqrt Inequality ここにも時間を吸われた．
Math#sqrtを使うと解けそうな気がするが，精度の都合上間違いになることがある． 今回は式変換を行うと4ab &lt; a^2 &#43; b^2 &#43; c^2 &#43; 2ab - 2bc - 2caに持っていけるので，そこに代入するだけ． あるいはBigDecimalを使っても大丈夫らしい．
D - String Equivalence 偶然通った問題．
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 &#43; 1までしか使えないことに注意．
E - Three Substrings 全探索の問題．ここを参考にした．
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう． 以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる． コードだとこんな感じ．
private static boolean[] init(final int length, final String a, final String b) {// 配列の初期化 final boolean[] array = new boolean[length]; // lengthは十分大きい値 Arrays.">

    <meta property="twitter:image" content="https://t45k.github.io/img/original.png">
    <meta property="twitter:image:url" content="https://t45k.github.io/img/original.png">

    <meta property="og:url" content="https://t45k.github.io/kyopuro/panasonic2020/">
  <meta property="og:site_name" content="T45K">
  <meta property="og:title" content="パナソニックプログラミングコンテスト2020の解説">
  <meta property="og:description" content="4完．コード
A - Kth Term 実装するだけ． Javaの場合は問題文をコピペしてfinal int[] array = {1, 1, ...};と宣言すると早い．
B - Bishop ここに一番時間を吸われた．
問題例を見ると最終的に(h * w &#43; 1) / 2でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．
C - Sqrt Inequality ここにも時間を吸われた．
Math#sqrtを使うと解けそうな気がするが，精度の都合上間違いになることがある． 今回は式変換を行うと4ab &lt; a^2 &#43; b^2 &#43; c^2 &#43; 2ab - 2bc - 2caに持っていけるので，そこに代入するだけ． あるいはBigDecimalを使っても大丈夫らしい．
D - String Equivalence 偶然通った問題．
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 &#43; 1までしか使えないことに注意．
E - Three Substrings 全探索の問題．ここを参考にした．
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう． 以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる． コードだとこんな感じ．
private static boolean[] init(final int length, final String a, final String b) {// 配列の初期化 final boolean[] array = new boolean[length]; // lengthは十分大きい値 Arrays.">
  <meta property="og:locale" content="ja">
  <meta property="og:type" content="article">
    <meta property="article:section" content="kyopuro">
    <meta property="article:published_time" content="2020-03-14T22:56:44+09:00">
    <meta property="article:modified_time" content="2020-03-14T22:56:44+09:00">


    
      <base href="https://t45k.github.io/kyopuro/panasonic2020/">
    
    <title>
  パナソニックプログラミングコンテスト2020の解説 · T45K
</title>

    
      <link rel="canonical" href="https://t45k.github.io/kyopuro/panasonic2020/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.13.0/css/all.css" integrity="sha384-Bfad6CLCknfcloXFOyFnlgtENryhrpZCe29RTifKEixXQZ38WheV+i/6YWSzkz3V" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://t45k.github.io/css/coder.min.a4f332213a21ce8eb521670c614470c58923aaaf385e2a73982c31dd7642decb.css" integrity="sha256-pPMyITohzo61IWcMYURwxYkjqq84XipzmCwx3XZC3ss=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="https://t45k.github.io/css/custom.css" />
    

    

    <link rel="icon" type="image/png" href="https://t45k.github.io/img/original.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://t45k.github.io/img/original.png" sizes="16x16">

    <meta name="generator" content="Hugo 0.127.0">
  </head>

  
  
  <body class="colorscheme-light">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://t45k.github.io/">
      T45K
    </a>
    
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://t45k.github.io/about">about</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://t45k.github.io/blog_index">blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://t45k.github.io/kyopuro_index">kyopuro</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://t45k.github.io/product">product</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://sdl.ist.osaka-u.ac.jp/~t-nakagw">lab</a>
          </li>
        
      
      
    </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>パナソニックプログラミングコンテスト2020の解説</h1>
      <br>
      
    </header>

    <p>4完．<a href="https://github.com/t45k/kyopuro/tree/master/AtCoder/others/pana20">コード</a></p>
<h2 id="a---kth-term">A - Kth Term</h2>
<p>実装するだけ．
Javaの場合は問題文をコピペして<code>final int[] array = {1, 1, ...};</code>と宣言すると早い．</p>
<h2 id="b---bishop">B - Bishop</h2>
<p>ここに一番時間を吸われた．<br>
問題例を見ると最終的に<code>(h * w + 1) / 2</code>でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．</p>
<h2 id="c---sqrt-inequality">C - Sqrt Inequality</h2>
<p>ここにも時間を吸われた．<br>
<code>Math#sqrt</code>を使うと解けそうな気がするが，精度の都合上間違いになることがある．
今回は式変換を行うと<code>4ab &lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2ca</code>に持っていけるので，そこに代入するだけ．
あるいは<code>BigDecimal</code>を使っても大丈夫らしい．</p>
<h2 id="d---string-equivalence">D - String Equivalence</h2>
<p>偶然通った問題．<br>
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．</p>
<h2 id="e---three-substrings">E - Three Substrings</h2>
<p>全探索の問題．<a href="https://www.hamayanhamayan.com/entry/2020/03/15/002311">ここ</a>を参考にした．<br>
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう．
以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．<br>
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる．
コードだとこんな感じ．</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="font-weight:bold">private</span> <span style="font-weight:bold">static</span> <span style="">boolean</span>[] init(<span style="font-weight:bold">final</span> <span style="">int</span> length, <span style="font-weight:bold">final</span> String a, <span style="font-weight:bold">final</span> String b) {<span style="font-style:italic">// 配列の初期化</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">final</span> <span style="">boolean</span>[] array = <span style="font-weight:bold">new</span> <span style="">boolean</span>[length]; <span style="font-style:italic">// lengthは十分大きい値</span>
</span></span><span style="display:flex;"><span>    Arrays.fill(array, <span style="font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; a.length(); i++) {
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> (<span style="">int</span> j = 0; j &lt; b.length() &amp;&amp; i + j &lt; a.length(); j++) {
</span></span><span style="display:flex;"><span>            <span style="font-style:italic">// 文字列aの位置i以降がbと被っているかの確認</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span> (!match(a.charAt(i + j), b.charAt(j))) { 
</span></span><span style="display:flex;"><span>                array[i] = <span style="font-weight:bold">false</span>;
</span></span><span style="display:flex;"><span>                <span style="font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> array;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="font-weight:bold">private</span> <span style="font-weight:bold">static</span> <span style="">boolean</span> match(<span style="font-weight:bold">final</span> <span style="">char</span> a, <span style="font-weight:bold">final</span> <span style="">char</span> b) {
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> a == <span style="font-style:italic">&#39;?&#39;</span> || b == <span style="font-style:italic">&#39;?&#39;</span> || a == b;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>それぞれの結果をab，ac，bcとする．<br>
これらの配列の</p>
<ul>
<li><code>ab[i] == true</code>となる<code>i</code></li>
<li><code>bc[j] == true</code>となる<code>j</code></li>
</ul>
<p>に対して<code>ac[i + j] == true</code>となれば，その配置は矛盾がないことになる．
図だとこんな感じ</p>
<figure><img src="https://t45k.github.io/img/kyopuro/pana2020_e.png" width="50%" height="50%">
</figure>

<p>iの探索範囲は0からaの長さ，jの探索範囲はbの長さかiからaの終端までの長さの長い方になる．<br>
あとは長さの最小値を出すだけ．</p>

  </article>

  <a href="https://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="basic-label-counter" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>

</section>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/startup.js" id="MathJax-script"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ['$', '$'], ['\\(', '\\)']
        ],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>

      </div>

      
  <footer class="footer">
    <section class="container">
      
        <p>圧倒的多幸感</p>
      
      
      
      
    </section>
  </footer>

    </main>

    

    
  



    

  </body>

</html>
