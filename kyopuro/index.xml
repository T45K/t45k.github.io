<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuroes on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuroes on T45K</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 20 Feb 2022 13:56:21 +0900</lastBuildDate>
    <atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ABC239の解説</title>
      <link>https://t45k.github.io/kyopuro/abc239/</link>
      <pubDate>Sun, 20 Feb 2022 13:56:21 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc239/</guid>
      <description>3 ヶ月ぶりのコンテスト参加。ただし Unrated。 6 完&#xA;A - Horizon やるだけ&#xA;B - Integer Division X が負かつ 10 で割り切れないときだけ、X/10 に-1 を加える。&#xA;C - Knight Fork 「二つの点から距離 √5 である格子点が存在する」ということは、 「それぞれの点から距離 √5 である格子点を列挙した時、重なる物が 1 つ以上ある」ということになる。&#xA;なので、それぞれの点の距離 √5 の格子点の集合に対して、共通集合が存在するかを確認すればよい。&#xA;D - Prime Sum Game 高橋君が選べる全ての数字に対して、足すことで素数になるような数字を青木君が選べればよい。&#xA;具体的には、以下のような処理を行う&#xA;A~B の数字を順番に選んでいく。この数字を i とする i に対して、C~D の数字を足していく。この和を j とする j が素数の場合は、1.で選んだ数字の次の数字で 2.以降を試す。逆に、素数となる j が存在しなければ、その時点で高橋君の勝ちが確定する 全ての i に対して j が素数となるような数字を青木君が選べた場合、青木君の勝利 E - Subtree K-th Max Ki は高々 20 なので、愚直に計算していけば良い。 具体的には、各頂点に対して部分木に書かれた値の降順リスト（長さ最大 20）を用意し、以下の手順をボトムアップに繰り返す。</description>
    </item>
    <item>
      <title>ABC223の解説</title>
      <link>https://t45k.github.io/kyopuro/abc223/</link>
      <pubDate>Sat, 23 Oct 2021 20:31:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc223/</guid>
      <description>ギリギリ 4 完． コード&#xA;A - Exact Price 100 で割った余りが 0 になればよい．&#xA;入力例にあるように X=0 である場合に注意．&#xA;B - String Shifting シフトした文字列を全通り用意しておき，ソートする．&#xA;C - Doukasen 両端からシミュレーションするのは難しそうなので他の方法を考える．&#xA;少し考えると，左端と右端両端から同時に火をつけたそれらがぶつかった時， どちらも同じ時間燃えていたことになる． つまり，ぶつかる場所は，左端から火をつけて燃え切るのに必要な時間の半分になる．&#xA;あとは，全て燃える時間を計算して，その半分でどこまで燃えるかを計算すればよい．&#xA;D - Restricted Permutation トポロジカルソートを，優先度付きキューを用いた幅優先探索でやるだけ．</description>
    </item>
    <item>
      <title>ABC222の解説</title>
      <link>https://t45k.github.io/kyopuro/abc222/</link>
      <pubDate>Sat, 23 Oct 2021 18:07:27 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc222/</guid>
      <description>四完． コード&#xA;A - Four Digits 10 未満には 3 個，100 未満には 2 個，1000 未満には 3 個 0 を付けた文字列を出力する．&#xA;B - Failing Grade やるだけ．&#xA;C - Swiss-System Tournament 問題文が長すぎて，飛ばして先に D から解いた問題． やることは&#xA;前から二人ペアでじゃんけんをする 勝ったらその人の勝ち数を増やす 勝ち数でソートする を繰り返すだけ．&#xA;D - Between Two Arrays DP．&#xA;dp[前から何番目を見てるか][c_iの値]=何通りかという DP を組むとdp[i][j]は&#xA;i=1の時，a_1 &amp;lt;= j &amp;lt;= b_1の範囲で 1，それ以外は 0 i&amp;gt;1の時，dp[i-1][a_i]~dp[i-1][j]までの総和 になる．&#xA;総和の計算には累積和を使う．&#xA;E - Red and Blue Tree 場合分けが漏れていて解き損ねた問題．&#xA;基本的なやり方としては，&#xA;全ての辺に対して，全ての移動を行った後に何回通ったかを記録しておく それぞれの辺を赤，青とした場合の R-B の値を DP を使って計算する． R-B=K となる組み合わせの数を求める． ここで注意しないといけないのは以下の 2 点．</description>
    </item>
    <item>
      <title>ABC220の解説</title>
      <link>https://t45k.github.io/kyopuro/abc220/</link>
      <pubDate>Wed, 06 Oct 2021 22:54:53 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc220/</guid>
      <description>5 完．コード&#xA;A - Find Multiple ゴリゴリに計算して答えを出しても良いが，この手の問題は全探索しても間に合う．&#xA;B - Base K 10 進法に直してから計算する&#xA;C - Long Sequence A1 ～ AN までの 1 ループでの和を事前に計算しておき，X とその和の商と余りから k を求める．&#xA;D - FG operation DP&#xA;E - Distance on Large Perfect Binary Tree ある頂点について，ペアの作るための頂点の選び方は以下の 3 通りになる&#xA;自分の子孫から対となる頂点を選ぶ 自分の先祖から対となる頂点を選ぶ 自分の先祖を経由して，その先祖の自分側以外の子孫から対となる頂点を選ぶ また，それぞれに関して，自分の深さを X とすると，以下の条件が設けられる&#xA;自分の深さから N までが D 以上，つまり N-X &amp;gt;= D 1 から自分の深さまでが D 以上，つまり X-1 &amp;gt;= D ある先祖の深さが Y の時，Y を経由しても D に収まる，つまり (X-Y)+(N-Y) &amp;gt;= D あとはそれぞれに関して計算すればよい．</description>
    </item>
    <item>
      <title>ABC219の解説</title>
      <link>https://t45k.github.io/kyopuro/abc219/</link>
      <pubDate>Wed, 06 Oct 2021 22:26:04 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc219/</guid>
      <description>5 完 600 位で青パフォ． コード&#xA;A - AtCoder Quiz 2 やるだけ．誤読して WA を出した&#xA;B - Maritozzo これもやるだけ． S1~S3 を配列に入れて，T の各数字を int 型に変換してからそれぞれの S に map して一つの文字列に結合すると気持ち良く書ける．&#xA;final String s1 = scanner.next(); final String s2 = scanner.next(); final String s3 = scanner.next(); final String[] s = {s1, s2, s3}; final String t = scanner.next(); final String answer = IntStream.range(0, t.length()) .map(i -&amp;gt; t.charAt(i) - &amp;#39;1&amp;#39;) .mapToObj(i -&amp;gt; s[i]) .collect(Collectors.joining()); System.out.println(answer); C - Neo-lexicographic Ordering 初めにバブルソートをやろうとして TLE を食らった問題</description>
    </item>
    <item>
      <title>ABC218の解説</title>
      <link>https://t45k.github.io/kyopuro/abc218/</link>
      <pubDate>Mon, 13 Sep 2021 16:37:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc218/</guid>
      <description>初の 6 完で久々に盛れた． コード&#xA;A - Weather Forecast String#charAt使う．&#xA;B - qwerty 問題文内では辞書順という言葉を使っているが，単純に(char)(&#39;a&#39; + P_i - 1)を出力するだけ．&#xA;c - Shapes アルゴリズムは簡単だが実装が割としんどい問題．&#xA;#が存在する座標のリストを取得し，それらを左上詰めしたうえで比較する． 例えば，入力例 1 の S&#xA;..... ..#.. .###. ..... ..... は 0-indexed で(1,2), (2,1), (2,2), (2,3)と表せられる． このとき，行の最小値は 1，列の最小値は 1 なので， 左上詰めするとそれぞれの座標の行，列から 1 ずつ引いて (0,1), (1,0), (1,1), (1,2)と表せられる．&#xA;これを S に対して 90° ずつ回転させたリストと T を比較する．&#xA;D - Rectangles 条件から，求めたいのは， あるx_iをx座標に持つ点の集合と，あるx_jをx座標に持つ点の集合の間で，y座標が一致する点の集合から2つ選ぶ時の組み合わせの数になる． これを実現するため，与えられた点を x 座標をキー，y 座標のリストを値に持つ Map に格納する． この時，リストは事前にソートしておく． あとは x 座標の各組合せに対して，一致する y 座標の数を数えておく． ソートしているので尺取法的に数え上げると，この操作はリストの長さに線形で可能なので十分に間に合う．</description>
    </item>
    <item>
      <title>ABC217の解説</title>
      <link>https://t45k.github.io/kyopuro/abc217/</link>
      <pubDate>Wed, 08 Sep 2021 18:47:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc217/</guid>
      <description>ぎりぎり5完． 難しく考えてセグ木で殴りにいくことが多かった． コード&#xA;A - Lexicographic Order JavaはS.compareTo(T)するだけ．&#xA;B - AtCoder Quiz 初めに4つのコンテストをSet等で持っておいて，出てきたものを消す．&#xA;Inverse of Permutation 問題文の解読にちょっと時間がかかった． 転置する．&#xA;D - Cutting Woods セグ木で殴った問題その1． JavaだとTreeSetでOK（lowerとceilingが使えることを知らなかった）． 別解を紹介する．&#xA;まずminを返すセグ木とmaxを返すセグ木を用意する． 木材を切る度に，2つのセグ木のxiの位置をxiで更新する． こうすると，線xiを含む木材の長さは，(出てきた数値のうち，xi以上の最小値)-(xi以下の最大値)と表すことができ， セグ木を使うことでO(log N)で処理できる． 木材の長さは10^9を取りうるので，木材を切る位置で座標圧縮する． つまり，ci=1のクエリを先に全て集めて起き，それらのxiの値でリストを作り， それをもとにセグ木を構築する．&#xA;E - Sorting Queries セグ木で殴った問題その2．&#xA;これも初めに出てくるxを全て集めておきリストに入れる． このリストをセグ木に入れる． 次にクエリを順番にみていき，以下の操作を行う．&#xA;操作1の時，Aの長さを表す変数lengthを更新する． 操作3の時，Aのどの部分までがソート済みかを表す変数sortedPointにlengthを代入する． 操作2の時，次に出力する数字が何個目か（count）によって，操作を変える sortedPoint以下なら，ソート済みの部分を出力するため，countからsortedPointの範囲で最小値を出力する （出力した数字は，次以降の操作で引っかからないように最大値で更新しておく） sortedPointを超過していれば，リストのcount番目の数字をそのまま出力する． </description>
    </item>
    <item>
      <title>ABC216の解説</title>
      <link>https://t45k.github.io/kyopuro/abc216/</link>
      <pubDate>Sat, 04 Sep 2021 20:29:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc216/</guid>
      <description>カス4完． コード&#xA;A - Signed Difficulty やるだけ．&#xA;doubleやfloatでなく文字列型で入力を受け取ってピリオドで分割したほうが良い．&#xA;B - Same Name 姓と名を結合した文字列（間に空白を挟む）をSet等で管理し，最終的にSetの要素数とNを比較すれば良い （要素数がNと同じなら同姓同名は存在しない）．&#xA;C - Many Balls 元のNに対して&#xA;Nが奇数なら1引いてから2で割る Nが偶数なら2で割る という操作を行っていき，最後に行った操作を逆順に出力する&#xA;D - Pair of Balls 考え方としては，筒の先頭を順番に見ていき，重複するボールがあればそれを取り除き，改めてその筒を見る，という操作の繰り返しである．&#xA;「操作を行う対象の筒リスト」を用意し，1~Nを初めに挿入する． 次に，リストの先頭から取り出した番号の筒に対して，以下の操作を行っていく&#xA;筒の先頭の数字が「すでに出現した数字」の集合に含まれている場合，筒の先頭と集合中のその数字を取り除き，「操作を行う対象の筒リスト」に今見ている筒の番号を入れる． 筒の先頭の数字が「すでに出現した数字」の集合に含まれていない場合，その数字を集合に入れる． E - Amusement Park ある楽しさXに対して，Σ(max(Ai-X,0)) = KとなるようなXが存在するときに，各アトラクションを楽しさがXになるまで乗るのが最適． なので，そのXを二分探索を用いて探す．&#xA;F- Max Sum Counting Aを昇順に並べたとき，Aiを含む(1,&amp;hellip;,i)の空でない部分集合は必ず最大値がAiになる． このことから，ソートした後の各iに対して，(1,&amp;hellip;,i)の空でない部分集合に対してBiの和を求めて，Ai以下のものの個数を足し合わせていけば良い． 部分集合の和はナップザック問題に帰着し，Aiの最大値は5,000なので，それ以下の範囲で計算すれば良い．</description>
    </item>
    <item>
      <title>ABC215の解説</title>
      <link>https://t45k.github.io/kyopuro/abc215/</link>
      <pubDate>Mon, 23 Aug 2021 20:59:23 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc215/</guid>
      <description>Dで沼って緑パフォ4完． コード&#xA;A - Your First Judge 文字列判定&#xA;B - log2(N) logを使うと誤差で通らなかったりする． N&amp;lt;=10^18からkは高々60程度なので愚直に計算してよい&#xA;C - One More aab aba baa |S|&amp;lt;=8から全てのパターンを列挙しても4*19^5程度なので，全て列挙してからソートすればよい． C++だとpermutationを使えば良いが，Javaだと自分で実装する必要がある． 再帰を使うと楽．&#xA;D - Coprime 2 全然解法が思いつかなかった． 想定解とは別解を紹介する．&#xA;問題の条件から，求めたい数は，各Aiが約数として持たない素数と，それらの合成数であることが分かる． そこであらかじめ2以上M以下の約数を全て列挙した上で，それらの倍数とAiが一致しないかを確認していく． 素数の倍数を列挙するのはエラトステネスの篩と同じ計算量で行え，それらがAiと一致するかはAをSetで持つことでO(1)でできる．&#xA;また，合成数を作る処理だが，合成数の数は高々M個なので計算量はO(M)以下となる．&#xA;E - Chain Contestant 解法は思いついたが時間内に実装できなかった問題．&#xA;SがAからJまでの10種類しかないことに着目すると，2^10をやっても何となくいけそうな気になってくる． 以下のようなdpを組む．&#xA;dp[文字列のどこを見ているか][今までどの文字を通ってきたか][今どこの文字にいるか] ここで，今までどの文字を通ってきたかはbitで表現できる． このようなdp[i][j][k]を組むと，更新式は以下の和となる．&#xA;dp[i-1][j][k]&#xA;jがi番目の文字を含んでおり，かつk==i． これは，i-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに最後に参加したことを表している． このとき，そのままi番目の文字のコンテストを受けることができる．&#xA;jがi番目の文字を含んでおらず，かつk!=i． これはi-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに参加したことがなく， 初めてi番目の文字のコンテストに参加することを表している．&#xA;+1．これは，i-1番目までのコンテストのいずれにも参加しておらず，i番目のコンテストに初めて参加することを表す．</description>
    </item>
    <item>
      <title>ABC214の解説</title>
      <link>https://t45k.github.io/kyopuro/abc214/</link>
      <pubDate>Sun, 15 Aug 2021 13:45:18 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc214/</guid>
      <description>ABCDの四完．久々にD問題解けた．&#xA;コード&#xA;A - New Generation ABC if文で分岐する&#xA;B - How many? for文で全探索&#xA;C - Distribution 意外と難しかったと感じた割には灰diffらしい．&#xA;まずは簡単のために，時計回りに並んでいない場合を考える． i番目のすぬけ君が初めて宝石をもらう時間をtime[i]とすると， i(&amp;gt;=2)番目のすぬけ君が初めて宝石をもらうのは min(T_i, time[i-1]+S[i-1])となるので， 前から順番に計算していけば良い．&#xA;実際には時計回りに並んでいるため， 1番目のすぬけ君がN番目のすぬけ君から宝石をもらうのが最速である場合がある． これはmin(T_0, time[N]+S[N])となるので，先ほどの式と併せて min(T_i%N, time[(i-1)%N + S[(i-1)%N]])と一般化できる． あとはこの式を2周ループすれば良い．&#xA;D - Sum of Maximum Weights D問題にしては難しかった問題．&#xA;まず，以下のことが言える．&#xA;連結でない頂点u,vに対して辺(u,v)を考える時， その辺を最短パスに含む頂点の組の個数は (uの連結成分の個数)*(vの連結成分の個数) 以上から，u，v連結でなく，辺(u,v)が「uの連結成分中の辺」「vの連結成分中の辺」の重みよりも大きい（つまり，辺(u,v)が重みの最大値）場合， 辺(u,v)を繋ぐことで重みの最大値の合計値は (辺(u,v)の重み)*(uの連結成分の個数)*(vの連結成分の個数)だけ増える．&#xA;よって，重みの小さい辺から順番に連結していくことで，答えを求めることができる． 連結成分の個数はUnion Findなどで管理できる．&#xA;E - Packing Under Range Regulations 解説AC．&#xA;F - Substrings 解説AC．解説が分かりやすい．</description>
    </item>
    <item>
      <title>ABC211の解説</title>
      <link>https://t45k.github.io/kyopuro/abc211/</link>
      <pubDate>Mon, 26 Jul 2021 22:41:46 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc211/</guid>
      <description>4完速解き失敗でレートが微減．コード&#xA;A - Blood Pressure けつあつそくてい．doubleで計算する．&#xA;B - Cycle Hit セットを使うなり事前にソートするなりする．&#xA;C - chokudai 一部で炎上していた問題．簡単なDP&#xA;D - Number of Shortest paths 基本的にはダイクストラ．&#xA;距離とは別に経路数の情報を持っておき，ある節点に到達したとき，&#xA;その節点での距離の最小値を更新した場合，経路数をその経路の値に置き換える その節点での距離の最小値と同じ距離だった場合，経路数を足し合わせる という操作を行う&#xA;E - Red Polyomino 解説AC．解きたかった． 赤に塗った盤面を全て記録しておいても十分メモリに余裕がある．</description>
    </item>
    <item>
      <title>ABC210の解説</title>
      <link>https://t45k.github.io/kyopuro/abc210/</link>
      <pubDate>Sun, 18 Jul 2021 14:18:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc210/</guid>
      <description>四完青パフォ。 今回は D 速解きがそこそこ上手くいった一方で、E に歯が立たなかったので精進したい。 コード&#xA;A - Cabbages A &amp;gt; Nになりうるのがポイント&#xA;A が N よりも小さい場合、A 個を X 円で買って、(N-A)個を Y 円で買う A が N 以上の場合、N 個を X 円で買う と場合分けする。&#xA;B - Bouzu Mekuri 愚直にシミュレーションする。 文字列を先頭から見ていき、初めに坊主を引いた方が負け。&#xA;Stream#findFirstを使うとすっきり書ける。&#xA;C - Colorful Candies 範囲内の飴ちゃんの種類を最大にする問題&#xA;範囲をスライドさせていく。 具体的には、&#xA;まずは先頭 K 個の飴の色と出現回数を辞書等を使って数えておく。この時の種類数をXとする。 K+1 個目の飴の出現回数を 1 増やし、1 個目の飴を出現回数を 1 減らす。 この時、K+1 個目の飴が初登場ならXを 1 増やし、1 個目の飴の出現回数が 0 になったらXを 1 減らす。 上の操作を、範囲をずらしながら繰り返す Xの最大値が答え D - National Railway 意外と難しかったらしい。&#xA;まずは簡単のために 1 行しかない場合を考える。</description>
    </item>
    <item>
      <title>ABC209の解説</title>
      <link>https://t45k.github.io/kyopuro/abc209/</link>
      <pubDate>Sat, 10 Jul 2021 23:14:52 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc209/</guid>
      <description>四完速解きで青パフォ． コード&#xA;A - Counting 基本的にはB-A-1だが，A&amp;gt;Bの時に限り0となる. max(B-A-1, 0)とすれば多少は楽．&#xA;B - Can you buy them all? 偶数番目の商品だけ-1して総和を計算するだけ．&#xA;C - Not Equal まず，整数列を昇順にソートしても求めたい値は変わらない．&#xA;1番目の値は全ての値から選ぶことができる． 2番目の値は1番目に選んだ値以外の値を選ぶので，C2 - 1通りから選べる． このとき，昇順にソートしているので選ぶ値の上限を考える必要がない． このように考えると，i番目の値はCi - (i-1)から選ぶことができる． このとき，(i-1) &amp;gt;= Ciとなると値を選べなくなるので答えは0になる．&#xA;そうでない場合，答えは全ての選べる値を掛け合わせた値になる．&#xA;D - Collision 問題文から，与えられたグラフが木構造であることが分かる．&#xA;木構造の場合，ある節点(a,b)の距離の偶奇は，頂点を一つ定めたときの(頂点からaまでの距離)-(頂点からbまでの距離)となる．&#xA;これは，例えば(a,b)の最小共通祖先をc，頂点（適当な節点）をd，二つの節点の距離をdis(x,y)と表す時，(頂点からaまでの距離)-(頂点からbまでの距離)の偶奇は&#xA;(dis(d,a) - dis(d,b)) % 2 = (dis(d,c) + dis(c,a) + dis(d,c) + dis(c,b)) % 2 = (dis(d,c) * 2 + dis(c,a) + dis(c,b)) % 2 = (dis(c,a) + dis(c,b)) % 2 でa，b間の距離の偶奇と一致するからである．</description>
    </item>
    <item>
      <title>ABC208の解説</title>
      <link>https://t45k.github.io/kyopuro/abc208/</link>
      <pubDate>Sun, 04 Jul 2021 23:45:41 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc208/</guid>
      <description>5完．初の黄パフォ．コード&#xA;A - Rolling Dice Bの平均値について考えればよい． 平均が1以上6以下なら達成可能．&#xA;B - Factorial Yen Coin 大きい硬貨から貪欲に計算していく&#xA;C - Fair Candy Distribution 初めに国民番号で国民をソートしておく． 国民番号の上位K%N人は余計に1個多くもらえる．&#xA;D - Shortest Path Queries 2 ワーシャルフロイドを応用する．ワーシャルフロイドについてはこちらを参照． ワーシャルフロイドの中継点をkとすると，Math.min(graph[i][j], graph[i][k] + graph[k][j])はiスタートjゴールでk以下の箇所を経由した際の最短距離となるので，問題に適当．&#xA;E - Digit Products たまたま解けた問題．桁DP．&#xA;桁DPとは，ある値Nが与えられたときに各桁に対する遷移を以下のように行うDPを指す．&#xA;一つ前で見ている桁の時点で，数字がN以下であることが確定している場合，0~9に遷移する 数字がN以下であることが確定していない場合，0~(今見ている桁の数-1)への遷移（つまり，状態1に遷移する）と今見てる桁への遷移（状態2）への遷移を行う 今回は，各桁の積がK以下になれば良いのだが，このとき積は十分に疎になるので連想配列などで持てば良い．</description>
    </item>
    <item>
      <title>ABC200の解説</title>
      <link>https://t45k.github.io/kyopuro/abc200/</link>
      <pubDate>Sun, 16 May 2021 11:57:55 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc200/</guid>
      <description>祝200回． 4完．&#xA;A - Century やるだけ． X00年はX世紀であることに注意．&#xA;B - 200th ABC-200 やるだけ．十分間に合う．&#xA;C - Ringo&amp;rsquo;s Favorite Numbers 2 Ai-Aj=200ということはAi≡Aj(mod 200)であることなので， 各Aを，200で割ったあまりでグルーピングして組み合わせを計算すればよい．&#xA;D - Happy Birthday! 2 解説が賢い．&#xA;先頭8個のAを見ると，2^8-1&amp;gt;200から鳩の巣原理から必ずmod200が被る和の組み合わせが存在する． bit全探索するだけ．&#xA;E - Patisserie ABC 2 きれいさ，おいしさ，人気度をそれぞれa,b,cとする．&#xA;a+b+cの小さい順に何通りあるかを確認していく(3 &amp;lt;= sum &amp;lt;= 3*N)． b,cが1以上N以下でないといけないことから，aの範囲は max(1,sum-2n) &amp;lt;= a &amp;lt;= min(n,sum-2)． このとき，bの範囲は max(1,sum-a-n) &amp;lt;= b &amp;lt;= min(n,sum-a-1)． a,bが決まればcは一意に定まる． このことから，a+b+cの和がsumの時， Σ(a=max(1,sum-2n)~min(n,sum-2))(min(n,sum-a-1)-max(1,sum-a-n)+1) 通りの選び方がある． これをO(1)で求める．&#xA;まず，bの値をaで場合分けする（min，maxを固定する）と&#xA;a &amp;gt;= sum-n-1 の時，b = sum-a-1 a &amp;lt;= sum-n-1 の時，b = 2n+a-s+1 となる そこで，aの最小値と最大値から累積和の公式を用いてsumの時の選び方を求められる </description>
    </item>
    <item>
      <title>ZONeエナジー プログラミングコンテスト “HELLO SPACE” の解説</title>
      <link>https://t45k.github.io/kyopuro/zone2021/</link>
      <pubDate>Sat, 15 May 2021 20:51:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/zone2021/</guid>
      <description>奇跡的に5完． コード&#xA;A - UFO襲来 やるだけ&#xA;B - 友好の印 UFOとタワーの頂上を通る直線のy切片を求める．&#xA;C - MAD TEAM 通したけど嘘解法っぽい． 想定解法は二分探索．&#xA;3人選ばないといけないのに対してN=3,000から二重ループまでしか回せない． 各要素が大きい人を選ぶほど良い結果を期待できる． つまり，各要素でソートして，上三つだけ残しておく． そして，ある二人を選んだ後に各要素のトップを加えてみて総合力を計算すれば良い．&#xA;D - 宇宙人からのメッセージ 両端キューなどに対して文字を突っ込んでいく． このときに重複を排除する．&#xA;E - 潜入 ダイクストラをする．</description>
    </item>
    <item>
      <title>第二回日本最強プログラマー学生選手権の解説</title>
      <link>https://t45k.github.io/kyopuro/jsc2021/</link>
      <pubDate>Sun, 02 May 2021 17:02:14 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/jsc2021/</guid>
      <description>5完393位でパフォーマンス爆盛りした回。 コード&#xA;A - Competition X,Y,Z&amp;lt;=10^3から、整数iに対してY/X &amp;gt; i/Zを満たす最大の値を探す。 X=1,Y=1000,Z=1000の時i=999999で最大になるので、そこから降順に探す。&#xA;B - Xor of Sequences やるだけ。 Set等で管理する。&#xA;C - Max GCD 2 2からBの間で、AからBの間に2つの倍数を持つ最大の整数を求めれば良い。 ある整数をiとすると、A以上の最小のiの倍数は(A + i - 1) / i * i、 B以下の最大のiの倍数はB/i*iで求まるので、この二つの値が異なる最大のiを求める。&#xA;D - Nowhere P まずA_1は1からP-1のP-1通り選べる。 次にA_2については1からP-1で、P-A_1でないP-2通りが選べる。 A_3以降についても、P-sum%P以外のP-2通りが選べるので、答えは(P-1)*(P-2)^(N-1)&#xA;E - Level K Palindrome 基本的には、回文で対応する文字に対して、一番出現する文字に書き換えていく。&#xA;まずはレベルを満たす最小の文字列に分解していく。 基本的には文字列を半分にするのを繰り返していく。 この時、各折り返し点が異なっている場合は書き換える。&#xA;次に、それぞれの文字列を同一にしていく。 これは、各文字列の同じ位置に存在する文字のうち、マジョリティに書き換える。&#xA;最後に各文字列が回文だった場合、そうならない様に書き換える。 これは、一つ前のマジョリティに書き換える処理を行う際に2番目に多い文字を記録しておき、 （中間点以外の）どこか一箇所をそれに書き換えれば良い。&#xA;F - Max Matrix 解説AC&#xA;出現した値をインデックス、出現回数をバリューとしたセグ木を構築するとうまくいく。</description>
    </item>
    <item>
      <title>JavaでN個の入力を良い感じにリストにする方法</title>
      <link>https://t45k.github.io/kyopuro/stream/</link>
      <pubDate>Sun, 18 Apr 2021 18:05:46 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/stream/</guid>
      <description>これが多分ベスト&#xA;Stream.generate(scanner::nextInt) .limit(N) .collect(Collectors.toList()); 配列にしたいときは&#xA;Stream.generate(scanner::nextInt) .limit(N) .mapToInt(Integer::intValue) .toArray(); </description>
    </item>
    <item>
      <title>ABC198の解説</title>
      <link>https://t45k.github.io/kyopuro/abc198/</link>
      <pubDate>Sun, 18 Apr 2021 17:47:27 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc198/</guid>
      <description>ABCEの4完。 その後Dを通した。 惜しかった。 コード&#xA;A - Div A君1個B君N-1個~A君N-1個B君1個までのN-1通り&#xA;B - Palindrome with leading zeros 意外と面倒臭い&#xA;後ろの0を全て削ってから回文確認をする&#xA;C - Compass Walking 点(X,Y)までの距離がRの倍数だったらそのまま割る。 そうでなければ、直前まで直線に向かい、そこから2歩使って到着するのが最善。&#xA;点(X,Y)がR未満の時答えが2になることに注意。&#xA;D - Send More Money 覆面算の条件から、使えるアルファベットは10種類以内になる（逆に、アルファベットが11種類以上の時、鳩の巣原理から数字が被ってしまう）。 あとは0~9までの順列をアルファベットに対応させて検証すれば良い。&#xA;E - Unique Color 木を深さ優先探索する。 今までに出現した色を記録する配列をboolean[10^5+1]とすると、以下のようなdfsで答えが求まる。&#xA;頂点xに到達した時、xの色に対応する配列の値がfalseだった場合、 xと頂点1からのパスにxの色が存在しないので、xはよい頂点になる。 逆に配列がtrueだった場合、よい頂点ではない。 xの色に対応する配列の値をtrueにする。 xの子に対して再帰的に上の手順を当てる。 xから登っていく（再帰関数を抜ける）時、xがよい頂点だったら、配列の値をfalseにしておく。 </description>
    </item>
    <item>
      <title>ABC196の解説</title>
      <link>https://t45k.github.io/kyopuro/abc196/</link>
      <pubDate>Sat, 20 Mar 2021 23:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc196/</guid>
      <description>惜しくも4完． E問題で一ヵ所凡ミスがあって1WAだった． コード&#xA;A - Difference Max x-yが最大になるのはxが最大かつyが最小の時． xの最大値はbであり，yの最小値はcなので，答えはb-c．&#xA;B - Round Down 100桁の小数が与えられるので，Xを数値として読み込むのは厳しい． 一旦文字列として読み込み，それの整数部を計算する． 文字列中に.が存在しないならその文字列をそのまま， 存在するなら.で分割し，前半の文字列を出力すれ良い．&#xA;C - Doubled 一見難しそうに見えるが，全探索すれば良い． 12桁の整数全ては調べられないが，条件は前半と後半が等しいなので， 下6桁まで(1~999,999)だけを確認すれば良い． 1~999,999までの数値を2回繰り返した整数がNよりも小さいかを判定する．&#xA;D - Hanjo HW &amp;lt;= 16という条件から，全探索をしてみる． 1畳の畳の置き方の問題なので，半畳の方は考えなくて良い（余った箇所に詰めれる）． 部屋を1メートル毎に分割し(i,j)と表現するとすると， 各(i,j)に対して，&#xA;（置けるけど）畳を置かない 畳を縦に置く 畳を横に置く の3通りの選び方があるので，再帰関数等を使って， 深さ優先探索で全てを試せば良い．&#xA;E - Filters N&amp;lt;=2*10^5，Q&amp;lt;=2*10^5から全てのxiに対して各関数を当てると間に合わないので， 1つの関数を全Xにlog(Q)に当てることを考える． そうすると，先にXをソートしておいて， 関数を当てる箇所を二分探索で探せば良いことが何となく分かる．&#xA;ti=1のとき，aiの値は最後に加算しても問題ない． sumなどの変数に加算しておき，最後に計算する． ti=2(max)のとき，&amp;ldquo;ソート済みXのai以下の値が全てaiになる&amp;quot;と考える． 二分探索でai以下の値の場所を求めて，その場所から左側の値は全てaiになることを記録しておく． ti=3(min)のときも同様． </description>
    </item>
    <item>
      <title>ARC113の解説</title>
      <link>https://t45k.github.io/kyopuro/arc113/</link>
      <pubDate>Mon, 22 Feb 2021 15:03:58 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/arc113/</guid>
      <description>ABCの3完で緑パフォ．コード&#xA;A - ABC 実は一番時間がかかった問題． Aを固定した時に，BとCの組み合わせはO(K)で求まる （BがNの時，Cは1~K/Nの値を取りうるので，組み合わせの個数はK/Nになる）． よって，Aを1からKまで動かしつつ，B*C&amp;lt;=K/Aを満たすB*Cの組み合わせを求めることになる． Aを動かしてもK/Aが変わらないときは，B，Cの組み合わせの個数も変わらない． なので，B，Cの組み合わせの個数をメモしておく．&#xA;個人的には計算量の見積もりが厳しい． 入力を考えるのは簡単なので，とりあえず実装してみて一番時間がかかりそうな入力（2*10^5）を突っ込んで時間計ってみるのが良さそう．&#xA;B - A^B^C A^B^Cの1の位は10で割った余りなので，(A%10)^B^Cと答えは同じ． 次にA%10の累乗の1の位がループする回数を求める． 例えば，2の場合，2の累乗の1の位は2 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt; 2と4回毎にループすることが分かる． これから，ループする回数をNとすると，B^CをNで割った余りを求めれば良い． 繰り返し二乗法を使えばO(log(C))でB^C % Nを求められるので十分間に合う．&#xA;C - String Invasion あるアルファベットαが二回連続で並んでいるときに，その後ろにあるアルファベットを全てαに置換できると考えると楽． このとき，αの後ろにある全てのアルファベットの内，αではないアルファベットの個数回操作を行える． この操作はなるべく後ろからしていくのが最適なので，以下の手順で解けばよい．&#xA;後ろからアルファベットを見ていく．この時，アルファベットの種類毎の個数を記録する． 二回連続しているアルファベットαがあれば，これまで記録してきたαではないアルファベットの個数回操作を行える． 操作を行うと，今見ている以降の全てのアルファベットがαになるので，そのように個数を記録し直す． </description>
    </item>
    <item>
      <title>ABC192の解説</title>
      <link>https://t45k.github.io/kyopuro/abc192/</link>
      <pubDate>Sun, 21 Feb 2021 17:56:33 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc192/</guid>
      <description>研究も一段落付いたので競プロに復帰します．&#xA;今回はABCDの4完． コード&#xA;A - Star Xは高々10^5なのでごり押しでもできますが， 100からXを100で割った余りを引くとO(1)で求まります．&#xA;B - uNrEaDaBlE sTrInG for文で回すだけ． 大文字，小文字判定はJavaだとCharacter#isUpper(Lower)Caseを使うと一発．&#xA;C - Kaprekar Number 一見難しそうに見えますが，N&amp;lt;=10^9からNをソート対象の要素は高々9個なので， K=10^5から毎回f(x)を計算しても十分間に合います． ということで&#xA;xをchar型配列に変換する g1がxを降順にソートして得られる値，g2が昇順ソートで得られる値になる x = f(x) をK回繰り返せばOK D - Base n E問題より解いた人が少なかったD問題．&#xA;まずXが一文字の時，何進数であってもXのn進数表記の値は変わらないため， X &amp;lt;= Mなら1，そうでなければ0を出力する．&#xA;次にXが二文字以上の時は，伝家の宝刀二分探索をする． dから10^18+1の範囲から初め， XをN進数表記にしたときにMを超過しない最大のNを求める． ちなみにXのN進数表記を計算するときはBigIntegerを使うことをオススメします （オーバーフローを考慮したうえでlongを使うと1WAになった）．&#xA;E - Train 出発できる時刻を考慮したうえでDijkstraをするだけ．</description>
    </item>
    <item>
      <title>ABC177の解説</title>
      <link>https://t45k.github.io/kyopuro/abc177/</link>
      <pubDate>Sun, 30 Aug 2020 16:35:35 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc177/</guid>
      <description>5完． コード&#xA;A - Don&amp;rsquo;t be late 規定の時間歩き切った際の距離が待ち合わせ場所までの距離以上であれば良い．&#xA;B - Substring 制約が緩いのでSの0以上|S|-|T|以下文字を先頭とした部分文字列とTを比較すれば良い．&#xA;C - Sum of product of pairs 愚直にやると時間に間に合わない．&#xA;答えはA1 * (A2 + A3 + ... An) + A2 * (A3 + ... + An) + ... + Ai * (Ai+1 + ... + An) + ...なので， A2からAnまでの累積和を取ってから掛け算を行えば良い．&#xA;D - Friends Union-Findで殴る．&#xA;問題文から，Union-Findを使うと友達グループは簡単に求まる． 全ての人について「同じグループの中に友達がいない」という状況を達成するためには， 一番大きい友達グループと同じサイズのグループに分割すれば良い．&#xA;E - Coprime まず全てのAiに対してGCDをとって，与えられた数字列がnot coprimeか否かを判定する． not coprime出ない場合，次にpairwise coprimeかどうかを判定する． ここで，「全ての組が互いに素である」とは，与えられた数字列の数字を素因数分解した際に，素数が約数となるのは高々1回までと同意である． Ai&amp;lt;=10^6から，素数の最大値は1000以下，あるいは1000以下の素数で割り切った後に残る数字（1以外）となる． なので，先に1000以下の素数をエラトステネスの篩などで用意しておき， 各Aiに対して各素数で割れるかどうかを判定する． 割れる場合，その素数を記録する． すでに記録した素数で割り切れた場合，互いに素でない数字の組が存在することになる．</description>
    </item>
    <item>
      <title>ABC176の解説</title>
      <link>https://t45k.github.io/kyopuro/abc176/</link>
      <pubDate>Mon, 24 Aug 2020 17:05:57 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc176/</guid>
      <description>気持ち良く5完． コード&#xA;A - Takoyaki 日本語をきちんと噛み砕かないと解けない問題． 答え自体は(X + N - 1) / N * Tするだけ．&#xA;B - Multiple of 9 各桁の合計を9で割るだけ&#xA;C - Step 前から順番に見ていき，今見ている人の身長が前の人以上になるように踏み台を使うのが最適．&#xA;なので，人iが見てきた中で最大の身長より小さければ，その差を足し合わせ， それより大きければ身長の最大値を更新すれば良い．&#xA;D - Wizard in Maze 意外と解ける人が少なかった問題&#xA;． 移動をコスト0，ワープをコスト1としてダイクストラすれば良い．&#xA;E - Bomber これが緑diffなの意外．&#xA;最初に各列，行ごとの爆破対象の個数を数えていく． 次に，列，行ごとで爆破対象が最大のもののみをフィルターする． 最後に残った列，行を組み合わせた際に爆破対象が最大となるものを選ぶ． この時，選んだ列，行の交差点に爆破対象がない場合合計個数は列の値 + 行の値， そうでない場合は列の値 + 行の値 - 1になる． なので，交差点に爆破対象がないように選びたい． 爆破対象の数は高々M個なので，交差点がMを超過するとき，必ず爆破対象が存在しない交差点がする． 逆にM以下の場合は，全ての交差点を確認しても制限時間に間に合う．</description>
    </item>
    <item>
      <title>ABC175の解説</title>
      <link>https://t45k.github.io/kyopuro/abc175/</link>
      <pubDate>Sun, 16 Aug 2020 19:58:10 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc175/</guid>
      <description>オンタイム参加せず． バチャやると3完だったので参加しなくてよかった&amp;hellip;&#xA;コード&#xA;A - Rainy Season 高々3文字なので全ての場合を列挙した方が良さそう．&#xA;B - Making Triangle 高々N &amp;lt;= 100なので3重ループでOK．&#xA;C - Walking Takahashi 個人的に結構難しかった問題．&#xA;Xは最初から絶対値として扱って良い． X &amp;gt;= K * Dの場合はX - K * Dが最適となる．&#xA;そうでない場合．まず　K2 = X / Dとすると0 &amp;lt; X - K2 * D &amp;lt; Dを満たすK2が得られる． ここからK2の偶奇がKと一致する場合そのKを，一致しない場合はK2+1が答えとなる．&#xA;K * Dが64bitに収まらないに注意．&#xA;D - Moving Piece 場合分けが面倒くさくて実装量が多くなる問題&#xA;． まず初めにマスのグループ分けを行う． というのも始める場所によっては行けないマスが存在することもあるからである（例えば2 1 4 3だと1からスタートすると1 -&amp;gt; 2 -&amp;gt; 1を繰り返す）． グループ分けは愚直にシミュレーションしても良いし，UnionFindTreeを用いてもできる．&#xA;分けたグループそれぞれに対して，スコアを計算する．&#xA;Kがグループのサイズ以下の場合&#xA;グループに含まれる各値をスタート地点にして，シミュレーションする． シミュレーションの途中のスコアも全て記録しておき，最大値を取得する Kがグループのサイズを超過する場合 グループの各数値iに対するCiの総和が 0より大きい場合</description>
    </item>
    <item>
      <title>ABC174の解説</title>
      <link>https://t45k.github.io/kyopuro/abc174/</link>
      <pubDate>Tue, 04 Aug 2020 13:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc174/</guid>
      <description>5完． Fが水diffだったのに解けなくて厳しい． コード&#xA;A - Air Conditioner 条件分岐するだけ&#xA;B - Distance 与えられたN個の座標の原点からの距離を計算していくだけ．&#xA;また，こういう時，小数点の計算などは誤差が発生しやすいので，平方根をとる計算はせず， 全て二乗で計算した方が良い． int型だとオーバーフローするので注意．&#xA;C - Repsept 証明が難しい問題．&#xA;C問題なので，時間いっぱい（10^7くらい）計算して答えが見つかれば答えを，見つかれなければ-1を出力する方針で解いた． 計算じたいは，最初にX = 7, i = 1として，XがKで割れればiを出力し， 割れなければX &amp;lt;- (X * 10 + 7) % K, i &amp;lt;- i + 1と更新すれば良い．&#xA;D - Alter Altar なんとなく解けた問題．&#xA;答えは次のいずれかの小さい方&#xA;玉を赤か白に統一する swapして左側に赤，右側に白を揃える 下の方法だと，最左の白玉と最右の赤玉の間にある玉の赤と白の少ない方の個数が答えになる．&#xA;E - Logs なんとなく解けた問題．想定解はにぶたん．&#xA;まずK &amp;lt;= 10^9という条件を無視すると，丸太iとその切断回数jに対して， i/jの天井関数の降順に並べるようにした 優先度付きキューに丸太を入れて，K回先頭の割る回数を増やすという操作で解ける(以降，操作O)． なので，Kを10^5くらいにできれば，この操作で大丈夫である． Kを減らす方法として，はじめに丸太iの長さに応じて適切な切断回数を決めておき， その切断回数の総和をKから引いた上で，操作Oに入ればよい． 初期切断回数として，丸太の長さの総和に対する割合を利用できる． つまり，丸太の長さの総和Sに対して，丸太iの長さがLiの時， K * (Li / S)を初期切断回数とすれば良い．&#xA;F - Range Set Query 解説AC．クエリをソートするという発想．</description>
    </item>
    <item>
      <title>エイシングプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/aising2020/</link>
      <pubDate>Mon, 13 Jul 2020 18:19:23 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/aising2020/</guid>
      <description>4完． コード 実装が重かった印象．&#xA;A - Number of Multiples for文で回すだけ&#xA;B - An Odd Problem for文で回すだけ&#xA;C - XYZ Triplets ゴリ押し全探索&#xA;N&amp;lt;=10^4から，x,y,zそれぞれの最大値は10^2になることが分かる． なので，x，yを1から10^2まで全探索しても計算量は全体で10^8に抑えられる．&#xA;計算方法だが，xとyが決まればあとはzの二次方程式となるため，解の公式を使えば条件を満たすzが存在するかがO(1)で分かる．&#xA;D - Anything Goes to Zero 意外と難しかったらしい問題&#xA;条件から，各Xiを最初に割るのは，popcount(X)±1となる． また桁iが0の時，Xi = X + 2^i，1の時，Xi = X - 2^1となることから， Xの値と各2^iの値を最初に求めておけば，最初の余を求めるところ以降は愚直にやっても間に合う． Xの値と各2^iの値は非常に大きくなる可能性があるので，何らかの値で割った余りを利用したい． ここで，条件から，各Xiを最初に割るのは，popcount(X)±1となるので，popcount(X)±1で割った余りを記録して， 桁iの値で使い分ければ良い.</description>
    </item>
    <item>
      <title>ABC173の解説</title>
      <link>https://t45k.github.io/kyopuro/abc173/</link>
      <pubDate>Mon, 13 Jul 2020 17:52:00 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc173/</guid>
      <description>4完． コード&#xA;A - Payment 愚直にforループを回しても良いが，Nが最大10,000なのを踏まえて， 10,000 - Nをしてお釣りを1000で割った余りを求めると早い．&#xA;B - Judge Status Summary switch文で数え上げるだけ．&#xA;C - H and V 典型的なbit全探索の問題． 縦，横でbit全探索して，該当行を赤く塗った後に盤上の黒いマスの個数を数える．&#xA;D - Chat in a Circle なぜ解けたかよくわからなかった． 直感的には，Aiをソートした後に&#xA;A1 A2を列に加える A3，A4を交互に列に加える．A1 A3 A2 A4となる A5，A6，A7，A8を交互に列に加える．A1 A5 A3 A6 A2 A7 A4 A8となる これを繰り返す． みたいな．</description>
    </item>
    <item>
      <title>ABC172の解説</title>
      <link>https://t45k.github.io/kyopuro/abc172/</link>
      <pubDate>Wed, 01 Jul 2020 10:38:47 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc172/</guid>
      <description>C，D問題に緑diffが出て結構阿鼻叫喚な人が多かった回． 4完．&#xA;コード&#xA;A - Calc 計算するだけ&#xA;B - Minor Change 問題文から，SとTの同じ位置で文字が異なる回数を数え上げれば良いことが分かる．&#xA;C - Tsundoku 貪欲だと解けない問題．&#xA;A，Bどちらの本も上限が10^5なので，全ての組み合わせを見ると時間が足りなくなる． ここで，本は上から見ていくというルールから，累積和をとっても問題ないことに気付ける． 累積和が取れるので，Aは前から見ていき，Bは二分探索できることに気付けるので，あとは実装するだけ．&#xA;D - Sum of Divisors 最近流行のエラトステネス的問題．&#xA;全ての数字の約数の個数をそれぞれ求めていたら遅いので，前から素数を見て，その素数を約数として持つ値に約数として加えていく方針でやる．&#xA;実装としては，以下のようにする．&#xA;長さNの配列を2つ用意する． 配列Aは1で，配列Bはその添字で初期化する． 配列Aは約数の個数を，配列Bは素数かどうかを判定するのに使う． 2 &amp;lt;= i &amp;lt;= √Nとして，配列を順番に見ていく． Biが2以上の時，iは素数となる．なので，iの倍数jに対して，jがiでk回割れる(= log(i,j))とすると Ak *= k + 1 Bk /= i ^ k と更新する Biが1の時，iは素数なので何もしない 配列Aに約数の個数が記録できたので，√N以上の素数に注意しながら欲しい値を計算する． </description>
    </item>
    <item>
      <title>ABC171の解説</title>
      <link>https://t45k.github.io/kyopuro/abc171/</link>
      <pubDate>Tue, 30 Jun 2020 22:33:15 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc171/</guid>
      <description>難易度が暴落した回．&#xA;5完．&#xA;コード&#xA;A - αlphabet やるだけ． JavaならCharacter#isUpperCaseとかが使える．&#xA;B - Mix Juice ソートして前からK個選ぶ．&#xA;C - One Quadrillion and One Dalmatians 与えられた数字を26進数に変換する問題．&#xA;Nをデクリメントし Nを26で割ったあまりを求め(これを使う) N /= 26 をする を繰り返す．&#xA;D - Replacing C問題よりわかりやすい．&#xA;最初に全ての和Sと，それぞれの数字が何回出てくるかを記録しておく． 各クエリ毎に以下の操作をすれば良い．&#xA;与えられたCに対して，SからC*(Cの出現回数)を引く 与えられたDに対して，SにD*(Cの出現回数)を加える Dの出現回数にCの出現回数を加える Cの出現回数を0にする E - Red Scarf まさかの茶diff．Nが偶数という制約があるのを知らんかった&amp;hellip;&#xA;すぬけ君iのスカーフに書かれた整数をbiとすると&#xA;a1 = b2 ^ b3 ^ ... ^ bn a2 = b1 ^ b3 ^ ... ^ bn a3 = b1 ^ b2 ^ ... ^ bn .</description>
    </item>
    <item>
      <title>ABC170の解説</title>
      <link>https://t45k.github.io/kyopuro/abc170/</link>
      <pubDate>Sat, 20 Jun 2020 11:52:18 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc170/</guid>
      <description>無念の3完． コード&#xA;A - Five Variables やるだけ． Listを作ってList#indexOfで探すと楽．&#xA;B - Crane and Turtle ツルカメ算． ループを回す．&#xA;C - Forbidden List 解答が燃えた問題．&#xA;Xが100以下なので，答えは101以下になる． したがって，0から101までの，数列に含まれていない数字に対してXとの差を計算するだけ．&#xA;D - Not Divisible 解けなかった．&#xA;エラトステネスの篩のイメージ． 数列A中の最大値をAmaxとすると，数列Aを昇順に見てsqrt(Amax)までの数字の倍数を全て消す作業をする． 最後に残った数字の中でダブりがないものが答え．&#xA;E - Smart Infants データ構造で殴る問題． Javaの標準ライブラリにMultiSetはないので少し考える必要がある． 今回は各幼稚園の園児のレートをTreeSetで，全ての幼稚園の最小値をセグ木で持つと，転園は以下の操作で行われる． また，各園児が現在所属している幼稚園の情報を持つとする．&#xA;Cjの園児が所属している幼稚園(TreeSet)からCjを消す． その幼稚園に関してセグ木の値を更新する．もし幼稚園に園児がいないならInteger.MAX_VALUEとする． 幼稚園DjにCjを加える． 幼稚園Djに関してセグ木の値を更新する． セグ木の全ての範囲に対してクエリを投げる．これが平等さになる． </description>
    </item>
    <item>
      <title>東京海上日動プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/tokiomarine2020/</link>
      <pubDate>Sun, 14 Jun 2020 18:55:26 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/tokiomarine2020/</guid>
      <description>3完． コード&#xA;A - Nickname 与えられた文字列の先頭3文字を抜き出すだけ．&#xA;B - Tag 非鬼が鬼より右側にいる場合，BはAに捕まらいためには右側に逃げるのが最適となる． 鬼と非鬼がT秒移動した時にいる箇所は，&#xA;鬼: A + V*T 非鬼: B + W*T となる． 鬼の座標が非鬼の座標以上に右側にいる(=より座標が大きい)と捕まるので，それを判定するだけ&#xA;C - Lamps いもす法をすると1回の操作はO(N)で達成できるので，K回やるとO(NK)となる(いもす法のやり方: Aiの値がdの時，座標i-dに+1，座標i+d+1に-1を加え，最後に累積和する)． O(NK)なので，最大で4*10^10程度の計算量となってしまいそうだが，ここで問題文から以下のことが言える．&#xA;全ての電球の明るさがNとなった場合，それ以降の操作で明るさは増えないため，そこで操作を打ち切って良い&#xA;操作回数が最大になるのはN=10^5，K=10^5，全ての電球の明るさの初期値が0の時なので，これを試してみると時間に十分間に合う．&#xA;あとはやるだけ．&#xA;解答を見ると，操作回数はO(log N)で抑えられるらしい．</description>
    </item>
    <item>
      <title>ABC169の解説</title>
      <link>https://t45k.github.io/kyopuro/abc169/</link>
      <pubDate>Mon, 01 Jun 2020 13:25:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc169/</guid>
      <description>久々のABC水パフォ． コード&#xA;A - Multiplication 1 読み込んで掛け算して出力するだけ．&#xA;B - Multiplication 2 与えられた数字の中に0があれば確定で0． それ以外の場合，それぞれ掛けて10^18を越えるかを確認すれば良い． JavaだとBigIntegerが使える． 比較はBigInteger#compareToで，0より大きければ1が返るっぽい．&#xA;C - Multiplication 3 罠．&#xA;JavaだとBigDecimalが使える． 解説通りにやるとするなら，一旦文字列で読み込んで，小数点を消した上で整数に変換すると良さそう．&#xA;D - Div Game まずは素因数分解する． 問題の条件から素数pに対して，p^1，p^2，p^3，&amp;hellip;，p^kと割っていくのが最適となる． したがって，各素数の出現回数からkを求めれば良い． p^kまで作るには，出現回数は1+2+3+...k=k(k+1)/2個必要となる． これは，kを1から全部列挙して探せば良い． 出現回数の最大値は，N&amp;lt;=10^12≒2^40から高々40回程度なので，全列挙しても十分間に合う．&#xA;E - Count Median たまたま解けた．&#xA;とても単純化してみる．&#xA;Nが奇数の時 N=3で，以下のような時を考える．&#xA;|---| |---| |---| a b c d e f この時，明らかに中央値はc~dの整数値になる．&#xA;このことから，何となく中央値は(0-indexedで)前からN/2番目の開始位置と後ろからN/2番目の終了位置の間の整数値であると考えられる．&#xA;Nが偶数の時 N=4で，以下のような時を考える．&#xA;|---| |---| |---| |---| a b c d e f g h この時，中央値は((c~dの値)+(e~fの値))/2となる． また，片方を1動かせば，中央値は1/2変化するので，中央値は1/2刻みとなる． 中央値候補の最小値は(c+e)/2，最大値は(d+f)/2となるので，その間の1/2刻みの値が中央値になると考えられる．&#xA;一般性は，あります！&#xA;F - Knapsack for All Subsets 解説AC．</description>
    </item>
    <item>
      <title>NOMURA プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/nomura2020/</link>
      <pubDate>Sun, 31 May 2020 15:57:56 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/nomura2020/</guid>
      <description>何とか3完． コード&#xA;A - Study Scheduling 時間を分に直して引き算するだけ．&#xA;B - Postdocs 例えば，?をPにした場合，その右側にDがある時だけ指数が1増えるのに対して，Dにすると確実に指数が1増えることから，全ての?をDに変換するのが最適になる．&#xA;C - Folia 解けてる人多くてびっくりした． 厳密な証明はeditorial参照．&#xA;初めに木を上から下の方へ見ていって，それぞれの深さでの葉でない頂点(以降，節)の最大値数を求めていく． 深さiの葉の数がAiの時，深さi-1での節の数がAi/2未満の時，Ai個の葉を生成できないので条件を満たす木は存在しない．&#xA;次に，木を下から上へ見ていき，各深さでの節の数を最適化していく． 木の頂点数を最大にするためには，各深さiに対して節の数を最大化したい． 節の数は，深さi+1の頂点数より大きくできない（全ての節は1つ以上の子を持つ），また，初めの操作により，深さiの節の個数から(深さi+1の頂点)個の子を産めることが分かっている． したがって，深さiでの節の数の最大値はmin(深さiでの節の数，深さi+1での頂点の数)となる． あとはこれを再帰的に計算して足し合わせるだけ．&#xA;この解き方だと，n=0がコーナーケースになることに注意(n=0, A0=1の時のみ答えが1で，それ以外は-1)</description>
    </item>
    <item>
      <title>AGC044の解説</title>
      <link>https://t45k.github.io/kyopuro/agc044/</link>
      <pubDate>Wed, 27 May 2020 23:41:26 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/agc044/</guid>
      <description>太陽でしたがNoSubなのでレートは変わらなかったです(NoSubというシステムをよく理解していなかったので，入力するのではないかとドキドキしてました)． A，Bの解説． コード&#xA;A - Pay to Win 400点問題だと高を括って望んだら痛い目にあった．&#xA;簡単に説明するとNから2，3，5で割っていくだけ． メモ化(b|d)fs． メモは値をキー，コストをバリューとしたMapで持つ． bfsで解く場合は，キューから取り出した値Kに対して&#xA;2で割れるか試す 割れる場合: 現在のコスト+min(a,d*K/2)（2で割るか，同じ値だけ1を引くかのコストが小さい方）がメモ[K/2]を更新できなければ何もしない．更新できれば，K/2をキューに追加する． 破れない場合: K+1とK-1は2で割れるので，割れる場合と同じ処理をする． 3で割れるか試す 割れる場合: 現在のコスト+min(b,d*2*K/3)がメモ[K/3]を更新できなければ何もしない．更新できれば，K/3をキューに追加する． 破れない場合: K-K%3とK+3-K%3はKで割り切れるので，割れる場合と同じ処理をする 5で割れるか試す．略 をやるだけ．&#xA;B - Joker 計算量の見積もりが難しい問題．&#xA;N&amp;lt;=500に対して，与えられる座標の数はN^2なので，座標が与えられる度に(d|b)fsすると間に合わないように見える． しかし，実は間に合う． 1回の(b|d)fsでいくつかの座標の端からの距離が減る では全ての走査で行われる操作は合計でO(n^3)で収まる 例えばN=6の時，最初の各座標の端からの距離は以下のようになる&#xA;0 0 0 0 0 0&#xA;0 1 1 1 1 0&#xA;0 1 2 2 1 0&#xA;0 1 2 2 1 0&#xA;0 1 1 1 1 0&#xA;0 0 0 0 0 0</description>
    </item>
    <item>
      <title>ABC168の解説</title>
      <link>https://t45k.github.io/kyopuro/abc168/</link>
      <pubDate>Tue, 19 May 2020 19:54:50 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc168/</guid>
      <description>速解き回だったけど速解き失敗． 4完． コード&#xA;A - ∴ (Therefore) switch文を使う問題． コードが長くなりがち． Kotlinだと気持ちよく書ける．&#xA;fun main() { Scanner(System.`in`) .run { when (this.nextInt() % 10) { 3 -&amp;gt; &amp;#34;bon&amp;#34; 0, 1, 6, 8 -&amp;gt; &amp;#34;pon&amp;#34; else -&amp;gt; &amp;#34;hon&amp;#34; }.apply(::println) } } B - &amp;hellip; (Triple Dots) やるだけ． Sの長さがKを上回っているとき，S.substring(0, K.length)．&#xA;C - : (Colon) 数学．&#xA;極座標か余弦定理を使うと簡単に解ける． 意外と二つの針の間の角度を求めるのが曲者．&#xA;D - .. (Double Dots) 嫌な気持ちになります．&#xA;問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．&#xA;E - ∙ (Bullet) 解説AC&#xA;解く手順としては&#xA;仲の悪いイワシを組み合わせないようにする方法 最終的な組み合わせを数え上げる方法 の2つを考える． 1. 仲の悪いイワシを組み合わせないようにする方法 Ai * Aj + Bi * Bj = 0という条件から，美味しさと香り高さがどちらも0のイワシは全てのイワシと仲が悪い． それ以外のイワシについて考えると，仲が悪くなるにはAi = a, Bi =bの時，Aj = kb, Bj = -kaとなる必要がある(kは0以外の整数)． なのでイワシを2種類のグループに分ける．</description>
    </item>
    <item>
      <title>ABC167の解説</title>
      <link>https://t45k.github.io/kyopuro/abc167/</link>
      <pubDate>Mon, 11 May 2020 11:43:31 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc167/</guid>
      <description>4完． コード&#xA;A - Registration 文字列Sと文字列Tの最後の文字を消した文字列が同等か確認する． javaだと S.equals(T.substring(0, S.length))&#xA;B - Easy Linear Programming A,B,Cの順番になるべく多くカードを取ると最大値になるので&#xA;KがA以下なら1のカードをK枚取って和はK Kが(A+B)以下なら，1のカードをA枚，0のカードを取れるだけ取って和はA それ以外なら1をA枚，0をB枚，-1を(K-(A+B))枚取って和は2A+B+K C - Skill Up bit全探索するだけ問題．&#xA;N&amp;lt;=12なので，全て試しても2^12≒4000通りなので十分間に合う．&#xA;D - Teleporter ABC030_Dとほぼ同じ問題．&#xA;K&amp;lt;=Nのとき K回のテレポートを愚直に計算しても間に合う．&#xA;K&amp;gt;Nの時 鳩の巣原理的に考えると，必ずどこかでループが発生することになる． なので，1ループで訪れる町の数でmodを取る．&#xA;E - Colorful Blocks 時間内に解けなかった．&#xA;全て隣り合わない組み合わせは m*(m-1)^(n-1)になる． 1組隣り合う場合，その隣り同士は同じ色なので ↑/(m-1) ↑に組み合わせをかける．一つ右とペアになると考えれば n-1C1 通り 2組以降も同じように考える．</description>
    </item>
    <item>
      <title>ABC166の解説</title>
      <link>https://t45k.github.io/kyopuro/abc166/</link>
      <pubDate>Mon, 04 May 2020 22:58:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc166/</guid>
      <description>二日連続ABCの二日目． ABCEの4完． コード&#xA;A - A?C 分岐するだけ．&#xA;B - Trick or Treat 数え上げるだけ&#xA;C - Peaks 結構誤読してた人が多かった問題&#xA;． 問題文から，i番目の展望台が地震を含めて繋がっている展望台の中で一番高ければ良いことが分かる． つまり，繋がっている展望台のどれか一つでも自身より高いものが良い展望台となる． なので，各A,Bに対して大きい方だけ残していくという戦略を取れば，残ったものが良い展望台である．&#xA;D - I hate Factorization 解けませんでした&#xA;問題文を誤読しないように． 任意のXについて成り立っているのではなく，テストケースとして与えられるXについて成り立つ． およそ200くらいが上限となるらしいので，それについて全探索するだけ．&#xA;E - This Message Will Self-Destruct in 5s 条件は添字i,jに対してi - j = Ai + Ajであり，これを式変形するとi - Ai = j + Ajとなる． つまり，(添字と身長の差)と(添字と身長の和)が同じ値になるペアが条件を満たす． なので各Aに対して添字との差と和をあらかじめ計算しておけば解ける</description>
    </item>
    <item>
      <title>ABC165の解説</title>
      <link>https://t45k.github.io/kyopuro/abc165/</link>
      <pubDate>Mon, 04 May 2020 22:58:03 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc165/</guid>
      <description>二日連続ABCの一日目． 3完． コード&#xA;A - We Love Golf きちんと数学して解くこともできるが，制約が小さいので全探索しても間に合う． AからBまでの閉区間内にKの倍数があるか確認する．&#xA;B - 1% これもきちんと数学して解けるけど全探索で解ける系． 入力例から分かるように，10^18が与えられても出力は3760になるので，1~3760までの区間を探索するだけで良い．&#xA;C - Many Requirements 解けませんでした&#xA;これも全探索するだけ問題． 考えられる数列を全列挙して特典の最大値を探す．&#xA;全列挙に必要な計算量が10^10だと思っていたので試さなかったが，実際にはボールとしきりの要領で組み合わせを考えると計算量は*O(N * C(N+M-1,N))*なので，全列挙しても十分間に合う．&#xA;D - Floor Function 数学．editorialが分かりやすいです．&#xA;E - Rotation Matching 同じ組み合わせを避けていく問題．&#xA;例えば，組み合わせ(1,N)は(1,2)と同じ組み合わせになる． したがって，(組み合わせの方の大きい方)-(小さい方)を組み合わせの距離と定義すると，距離N-iと距離iは同じ組み合わせである． これを念頭に入れてN-1からN-mまでの組み合わせを考えていく． (1,N)(2,N-1)&amp;hellip;と作っていくと距離N-1,N-3&amp;hellip;と1飛ばしに組み合わせを作れる． 途中で折り返しをうまく調整して距離N-2,N-4&amp;hellip;の組み合わせを作る．</description>
    </item>
    <item>
      <title>ABC164の解説</title>
      <link>https://t45k.github.io/kyopuro/abc164/</link>
      <pubDate>Mon, 27 Apr 2020 23:38:04 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc164/</guid>
      <description>4完．コード&#xA;A - Sheep and Wolves if文で分岐するだけ&#xA;B - Battle 割った余りを求めるのがスマートだけで，先攻後攻の概念があるので愚直に互いに引いていった方が安全．&#xA;C - gacha JavaだとSetに打ち込めば良い． Stream#distinctからのStream#countで多少スマートに書ける．&#xA;D - Multiple of 2019 各桁に対して，i桁目の数字がDiとしてSi = (10 ^ i * Di + Si-1) % 2019を計算すると，Siが同じ値の桁間の数字は2019の倍数になる．&#xA;E - Two Currencies むずかしかった．&#xA;(頂点番号, 所持金)を一つの頂点としてダイクストラする．</description>
    </item>
    <item>
      <title>ABC163の解説</title>
      <link>https://t45k.github.io/kyopuro/abc163/</link>
      <pubDate>Tue, 21 Apr 2020 16:22:58 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc163/</guid>
      <description>3完． unratedで良かった&amp;hellip; コード&#xA;A - Circle Pond やるだけ．&#xA;円周は2 * r * 円周率． Javaだと円周率はjava.lang.Math.PIが使える．&#xA;B - Homework 全ての宿題をやるにはΣ Ai日かかるので，それをMと比較する．&#xA;C - management 問題文が若干ややこしい． やることは特定の数字が何回出てくるかを数えるだけ． はじめに配列array[N + 1]を用意して，各Aiに対してarray[Ai]++する．&#xA;D - Sum of Large Numbers 時間内に解けなかった． 組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった&amp;hellip;&#xA;各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない． あるiに対してfront_sumを0からi-1までの和，back_sumをn-i+1からnまでの和とすると， i個選択する時の組み合わせによって得られる和はi * 10^100 + front_sumからi * 10^100 + back_sumまでの間に収まる． つまり，back_sum - front_sum + 1通りになる． front_sumとback_sumは累積和で取れるので，iをKからNまで動かして足し合わせれば良い．&#xA;E - Active Infants 原始的なDP（ほんまか？）．&#xA;活発度が高い順に左か右に移動させる． 活発度を降順にソートした時，dp[i][j]を，(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさという風に考える． そうすると，dp[i][j]は左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させるか左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させるの嬉しさが大きい方になる．</description>
    </item>
    <item>
      <title>ABC162の解説</title>
      <link>https://t45k.github.io/kyopuro/abc162/</link>
      <pubDate>Mon, 13 Apr 2020 16:57:30 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc162/</guid>
      <description>祝参加者1万人越え．無念の4完．コード&#xA;A - Lucky 7 やるだけ．文字列で読み込んでString#containsを使うと早い．&#xA;B - FizzBuzz Sum これもやるだけ．LongStreamできれいに書ける．&#xA;LongStream.rangeClosed(1, scanner.nextInt()) .filter(i -&amp;gt; i % 3 != 0 &amp;amp;&amp;amp; i % 5 != 0) .sum(); C - Sum of gcd of Tuples (Easy) 三重ループを回すだけ．&#xA;D - RGB Triplets N &amp;lt;= 4,000なので二重ループで回すことを考える． ある座標以降のそれぞれの色が何個あるかを記録する． これは後ろから累積和をとることで可能． こうすることで，例えばiが赤色，jが緑色のとき，j+1以降の青色の個数をO(1)で得られる． また，k-j ≠ j-iの条件を満たすために，k-j = j-iとなるkに対して(j+1以降の数) - (k以降の数) + (k+1以降の数)と計算すれば良い(累積和の性質から)．&#xA;E - Sum of gcd of Tuples (Hard) 解法は思いついていたが計算量的にダメだと思っていて放置していたやつ&#xA;． 解答が詳しいのでそちらを参照． 繰り返し二乗法などを使うと速くなる．</description>
    </item>
    <item>
      <title>ABC161の解説</title>
      <link>https://t45k.github.io/kyopuro/abc161/</link>
      <pubDate>Sat, 04 Apr 2020 22:53:03 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc161/</guid>
      <description>100-200-300-400-600の5完． 人生初のオンサイト600点問題AC． コード&#xA;A - ABC Swap Z，X，Yを順に出力するだけ&#xA;B - Popular Vote やるだけ．&#xA;割り算の結果を比較するときは，a &amp;gt; b / cではなくa * c &amp;gt; bのように書いたほうが正確．&#xA;C - Replacing Integer 方針立てるのに時間かかった問題．&#xA;直感的には分かりづらいけど以下のように言い換えられる(chokudaiさんのツイート)．&#xA;C問題、数学の問題といえばそうなんだけど、「無限に長いすごろくがあります。ゴールまでの距離がxです。Kマスずつ進めますが、ゴールを通り過ぎてしまう場合は折り返します。最もゴールに近づく時の残りマス数を答えなさい」みたいにすると、まぁ一応ちゃんとしたストーリーはつくよね。&#xA;&amp;mdash; chokudai(高橋 直大)🌸🍆🍡 (@chokudai) April 4, 2020 というわけで，N % Kと(N - (N % K)) % Kの小さい方を求める．&#xA;D - Lunlun Number 想定解が天才すぎる．愚直に解いた．&#xA;i番目の数字に対して，i + 1番目の数字を次のように決める．各桁を下から順番に見ていく．もし見ている桁が9でなく，かつ次の桁の数字より1小さいか同じなら，その桁をインクリメントし，それ以降の桁をルンルン数かつ最小となるように調整(つまり，&amp;lsquo;上の桁 - 1&amp;rsquo;か&#39;0&amp;rsquo;)した値がi + 1番目の数になる．どの桁も条件に当てはまらなければ，一番大きい桁をインクリメントする．&#xA;各桁を確認，操作する場合は，数字をいったんchar型配列にするとやりやすいかも．&#xA;E - Yutori 解説AC．&#xA;前から貪欲と後ろから貪欲の結果を比較するだけ．解説に登場する配列L，Rを求めなくても，二分探索しても十分間に合う．&#xA;F - Division or Substraction E問題よりACが多いF問題．&#xA;まずNに対して以下の数字は必ず条件を満たす</description>
    </item>
    <item>
      <title>ABC160の解説</title>
      <link>https://t45k.github.io/kyopuro/abc160/</link>
      <pubDate>Sat, 28 Mar 2020 23:27:57 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc160/</guid>
      <description>5完．コード&#xA;A - Coffee 書かれてることをするだけ．String#charAtを使う&#xA;B - Golden Coins なるべく多くの500円に換金した方が良いので，まずはXを500で割る． 余りを50で割って，それぞれの商に1000と5を掛けて出力．&#xA;C - Traveling Salesman around Lake ある家からその一つ手前の家までをぐるっと一周回ってくるのが最適となる． 1番目の家からN番目の家までに移動距離はAi - AN，それ以外の家iから家i - 1まではK - Ai + Ai-1になるので，その中の最小値が答え．&#xA;D - Line++ ワーシャルフロイドっぽい問題．&#xA;まず初めにX，Yを経由しない場合の全ての頂点間の距離を求める． これはグラフを隣接行列で表すとgraph[i][j] = |i - j|となる．&#xA;次に，XまたはYを経由した場合を考えた上で，全ての頂点間の最短距離を求める． これはgraph[i][j] = min(graph[i][j], graph[i][X] + graph[X][j])となる．&#xA;最後に，隣接行列の中で各距離の出現回数を記録し，それを出力する．&#xA;E - Red and Green Apples 貪欲にやるだけ．&#xA;美味しさを最大化したいとき，赤リンゴを降順に並べたときのX+1つ目以降と緑リンゴを降順に並べたときののY+1つ目以降は捨ててもよい． 後はそれぞれのリンゴの小さいものを順番に無色のものと入れ替えるだけ．</description>
    </item>
    <item>
      <title>ABC159の解説</title>
      <link>https://t45k.github.io/kyopuro/abc159/</link>
      <pubDate>Sun, 22 Mar 2020 22:48:22 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc159/</guid>
      <description>奇跡的に5完．コード&#xA;A - The Number of Even Pairs 和が正になるのはeven + evenかodd + oddの時なので，偶奇それぞれに対して組み合わせ(n * (n - 1) / 2)を計算して足し合わせる．&#xA;B - String Palindrome 書かれてることをするだけ． 回文系の問題は以下のようなメソッドを作っとくと便利かも．&#xA;private static boolean isPalindrome(final int start, final int end, final String s) { for (int i = 0; ; i++) { if (start + i &amp;gt;= end - i) { return true; } if (s.charAt(start + i) != s.charAt(end - i)) { return false; } } } C - Maximum Volume Lの1/3の3乗</description>
    </item>
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>1完．コード&#xA;A - Range Flip Find Route 全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;&#xA;右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）． なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる． ダイクストラ法を使うと計算量は頂点数Vと辺数Eに対してO(V * log(E))となる． 今回の頂点数VはV &amp;lt;= H * W = 10 ^ 4となる． また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．&#xA;B - 123 Triangle 誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)&#xA;答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する． 各aは先に1引いといても問題ない． 偶奇判定なので，abs(a - b)ではなくa xor bで良い． そうすると， x n,1 = ( C 0 n-1 ⁢ x 1,1 ^ C 1 n-1 ⁢ x 1,2 ^ &amp;hellip; ^ C n-1 n-1 ⁢ x 1,n ) % 2 となる． そのため，各組み合わせを計算すれば良い．&#xA;今回は偶奇が欲しいので，各組み合わせの2で割った余りだけで十分である． そこでLucasの定理を用いる(リンク参照)． 定理に従うと手順はこう．</description>
    </item>
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>4完．コード&#xA;A - Kth Term 実装するだけ． Javaの場合は問題文をコピペしてfinal int[] array = {1, 1, ...};と宣言すると早い．&#xA;B - Bishop ここに一番時間を吸われた．&#xA;問題例を見ると最終的に(h * w + 1) / 2でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．&#xA;C - Sqrt Inequality ここにも時間を吸われた．&#xA;Math#sqrtを使うと解けそうな気がするが，精度の都合上間違いになることがある． 今回は式変換を行うと4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2caに持っていけるので，そこに代入するだけ． あるいはBigDecimalを使っても大丈夫らしい．&#xA;D - String Equivalence 偶然通った問題．&#xA;左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．&#xA;E - Three Substrings 全探索の問題．ここを参考にした．&#xA;Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう． 以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．&#xA;まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる． コードだとこんな感じ．&#xA;private static boolean[] init(final int length, final String a, final String b) {// 配列の初期化 final boolean[] array = new boolean[length]; // lengthは十分大きい値 Arrays.</description>
    </item>
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>ABC061 D - Score Attackの別解．コード&#xA;問題内容 正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題． 解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている． また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．&#xA;別解 最長路検出と閉路検出について異なる方法を紹介する．&#xA;最長路検出 今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である． BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる． BFSであることから，n ^ 2 回繰り返せば十分である．&#xA;閉路検出 解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない． 各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていればinfを出力すれば良い．</description>
    </item>
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>四完．コード&#xA;A - Station and Bus 連想配列にぶちこむ．&#xA;B - Count Balls n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．&#xA;C - Tax Increase 1から20,000くらいまでの整数が条件を満たすか全探索．&#xA;D - String Formation 現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する． クエリが1ならフラグ反転，クエリが2の場合は，&#xA;正順ならクエリ通りに文字追加 逆順ならクエリとは逆に文字追加 をやる． 最終的にフラグを参照してから正しい方向で出力．&#xA;StringBuilder#insertを使うとTLEになりました．</description>
    </item>
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>なんとか四完．コード&#xA;A - Duplex Printing nに1足して2で割るだけ&#xA;B - Bingo 実装するだけだが実装量が多くなりがちな問題&#xA;C - Guess The Number 条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更． 桁数を満たす整数を昇順に条件を満たすか確認する． 余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．&#xA;D - Friend Suggestions Union-Find Treeで殴る問題． 友達関係を取得する時にUnion-Find Treeを構築します． 同時に，それぞれの人が何人友達がいるかを記録します．&#xA;ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します． この時，友達候補でない人を記録する必要はありません．&#xA;最終的に，Union-Find Treeから自分，友達，ブロック関係を含めた自分と繋がっている人を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．&#xA;余談ですが，Setをfor文で回すと異様に遅いので，for文を使う場合はListを使った方が良いです．</description>
    </item>
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>最小全域木という概念を知ったのでメモ．&#xA;最小全域木とは 無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanning Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．（蟻本より）&#xA;つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．&#xA;ABC065-Dがこの問題に該当します．&#xA;解き方 有名なアルゴリズムとして，クラスカル法とプリム法があります． 今回はクラスカル法を紹介します．&#xA;クラスカル法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります． ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．&#xA;// edges は Edge(int label1, int label2, long cost) のリスト edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost)); final UnionFindTree unionFindTree = new UnionFindTree(n); // 要素数nのUnion-Find Treeを構築 long sum = 0; for (final Edge edge : edges) { if (!unionFindTree.isSame(edge.label1, edge.label2)) { unionFindTree.unit(edge.label1, edge.label2); sum += edge.cost; } } 辺のソートに一番計算量を食われます．</description>
    </item>
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>ワーシャルフロイド法というアルゴリズムを知ったのでメモ．&#xA;ワーシャルフロイド法とは グラフのある一点から任意の点への最短距離を求めるアルゴリズム． 計算量は点の個数nに対してO(n^3)． 似たようなアルゴリズムにダイクストラ法があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである． 計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．&#xA;実装 このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単． 二次元配列を用いた例がこちら．&#xA;public static void main(final String[] args) { final int[][] graph = new int[n][n]; // 初めに無限大の値で各要素を初期化 for (int i = 0; i &amp;lt; graph.length; i++) { Arrays.fill(graph[i], Integer.MAX_VALUE / 2); // Integer.MAX_VALUEでないことに注意 graph[i][i] = 0; } // グラフの各辺を与えられた値に変更 // ここからワーシャルフロイド for (int k = 0; k &amp;lt; graph.length; k++) { // 中継する点 for (int i = 0; i &amp;lt; graph.length; i++) { // 出発する点 for (int j = 0; j &amp;lt; graph.</description>
    </item>
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>4完．解答&#xA;A - Beginner 算数&#xA;B - Digits nが0になるまでkで割り続ける&#xA;C - Rally 座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．&#xA;D - Bouquet 組み合わせの問題．&#xA;組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く． 組み合わせの総和は2^n - 1になる． a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．&#xA;modInvのJava実装の例</description>
    </item>
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>無念の三冠．&#xA;A - Poor 重複を調べる問題．&#xA;愚直に比較しても良いけど，Setを使うのが早そう．&#xA;JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．&#xA;B - Papers, Please fizzbuzzみたいな問題．&#xA;これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．&#xA;C - Poll 連想配列を使って数え上げる典型的な問題．&#xA;StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくはCollections#sort)． C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．&#xA;D - Pairs E問題より難しいD問題． 以下の要素が重なりあってきつい．&#xA;決め打ち二分探索 決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す． 単調性とは，ある数 x に対してその問題が成り立つならば，x 以降の数字に対しても成り立つような性質を指す．&#xA;実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 isOk(...) を用意する． D問題だとある値 x と K が与えられた時に，積が x 以下となるペアの個数が K 以上の場合は真のようになる．&#xA;次に，二分探索の対象を用意する．このとき，始点は isOk が偽となり，かつ終点は真となるような範囲を用意する． 今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので 0 ~ 10^18 のようになる．&#xA;そして二分探索する． 二分探索では通常範囲を指定するが，この時始点は isOk が偽，終点は真となることを意識する． 通常の二分探索と同じく対象範囲の真ん中の値((始点 + 終点) / 2)をとり，それの真偽を判定する． 真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する． この操作で，常に始点は偽，終点は真となる． 最終的に始点と終点が連続した値になるため，その終点を解として出力する．&#xA;要約すると，isOk() を満たす範囲の下界を求める操作だと言える．&#xA;Lower Bound / Upper Bound Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた． 計算量もそこまで気にする必要はない． 今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある． そのため，Lower BoundやUpper Boundを用いる必要がある．</description>
    </item>
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>A~Dまで．コード&#xA;A - Remaining Balls Uで分岐&#xA;B - I miss you&amp;hellip; 入力の文字列の長さの回数&amp;rsquo;x&amp;rsquo;を出力&#xA;C - Distinct or Not 連想配列を使って数字が出現したかを確認&#xA;D - Dice in Line 毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく． あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．&#xA;E - Almost Everywhere Zero 桁DP&#xA;0でない(= 1 ~ 9)の数字がK回出る回数を数える． 桁を上から決定していき数え上げる． 桁の決定の仕方は，その桁を決める前の時点でNより小さいことが確定しているかどうかで変わる．&#xA;確定している場合をdp[|N|][K + 1]と表現した時に，桁iでの状態遷移は以下のようになる&#xA;桁i-1での状態 桁iでの状態 確定している 0を選択する: dp[i][k] += dp[i - 1][k]&#xA;0以外を選択する: dp[i][k] += dp[i - 1][k - 1] * 9 確定していない 桁iが0の時: Nより小さくすることはできないので何もしない&#xA;桁iが0でない時: 1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができるので，桁i-1までに0以外の数字が出現した回数をjとするとdp[i][j + 1] += (桁iの数字 - 1) 桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．</description>
    </item>
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>けもフレチックでした．&#xA;A~Eまで&#xA;A - Serval vs Monster (H + A - 1) / A するだけ&#xA;B - Common Raccoon vs Monster 必殺技の総和をとって大小比較&#xA;C - Fennec vs Monster 体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃&#xA;D - Caracal vs Monster 等比数列の和&#xA;E - Crested Ibis vs Monster DP&#xA;ソースコード&#xA;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153</description>
    </item>
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>A~E問題まで．&#xA;A - AC or WA if文で分岐するだけ&#xA;B - Comparing Strings 辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される． 2数の大きい方の値の回数だけ，小さい方の値を出力する．&#xA;C - Low Elements 数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．&#xA;D - Handstand 2 与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく． 例えば334は34，398は38という感じ． あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．&#xA;E - Flatten modの逆元を知らないと厳しい問題．参考&#xA;この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める． LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．&#xA;ソースコード&#xA;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152</description>
    </item>
    <item>
      <title></title>
      <link>https://t45k.github.io/kyopuro/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://t45k.github.io/kyopuro/doc/</guid>
      <description>&lt;!DOCTYPE HTML&gt; 生成されたドキュメント(タイトルなし) ブラウザのJavaScriptが無効になっています。&#xA;library/package-summary.html</description>
    </item>
  </channel>
</rss>
