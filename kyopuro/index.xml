<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuros on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuros on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 23 Feb 2020 01:54:16 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>ワーシャルフロイド法というアルゴリズムを知ったのでメモ．
ワーシャルフロイド法とは グラフのある一点から任意の点への最短距離を求めるアルゴリズム． 計算量は点の個数nに対してO(n^3)． 似たようなアルゴリズムにダイクストラ法があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである． 計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．
実装 このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単． 二次元配列を用いた例がこちら．
public static void main(final String[] args) { final int[][] graph = new int[n][n]; // 初めに無限大の値で各要素を初期化  for (int i = 0; i &amp;lt; graph.length; i++) { Arrays.fill(graph[i], Integer.MAX_VALUE / 2); // Integer.MAX_VALUEでないことに注意  graph[i][i] = 0; } // グラフの各辺を与えられた値に変更  // ここからワーシャルフロイド  for (int k = 0; k &amp;lt; graph.length; k++) { // 中継する点  for (int i = 0; i &amp;lt; graph.</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>4完．解答
A問題 算数
B問題 nが0になるまでkで割り続ける
C問題 座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．
D問題 組み合わせの問題．
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く． 組み合わせの総和は2^n - 1になる． a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．
modInvのJava実装の例</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>無念の三冠． D以降は後日追加するかも．
A問題 重複を調べる問題．
愚直に比較しても良いけど，Setを使うのが早そう．
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．
B問題 fizzbuzzみたいな問題．
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．
C問題 連想配列を使って数え上げる典型的な問題．
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくはCollections.sort())． C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．
E問題 貪欲にやってもできそうな気がするけど，editorial見て正攻法で解答．
いわゆる桁dpの問題(多分)． 今回は，その桁をちょうど払う状態(以降，just)と1多く払う状態(以降，extra)に分けて考える． 言い換えると，extraは繰り下がりを考慮した状態といえる．
上の桁から考えていくと，状態遷移は以下のようになる．
 その桁のjust = (前の桁のjust + その桁の数字) か (前の桁のextra + (10 - その桁の数字)) の小さい方 その桁のextra = (前の桁のjust + その桁の数字 + 1) か (前の桁のextra + (9 - その桁の数字)) の小さい方  これを解いていくと答えになる．
ちなみに，最後の桁は必ずjustとなること，また，最初の桁の前についてもjustとextraを考慮する(99を100で払ったり)ことに注意．
コード</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>A~Dまで．コード
A問題 Uで分岐
B問題 入力の文字列の長さの回数&amp;rsquo;x&#39;を出力
C問題 連想配列を使って数字が出現したかを確認
D問題 毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく． あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．
E問題 桁DP
0でない(= 1 ~ 9)の数字がK回出る回数を数える． 桁を上から決定していき数え上げる． 桁の決定の仕方は，その桁を決める前の時点でNより小さいことが確定しているかどうかで変わる．
確定している場合をdp[|N|][K + 1]と表現した時に，桁iでの状態遷移は以下のようになる
   桁i-1での状態 桁iでの状態     確定している 0を選択する: dp[i][k] += dp[i - 1][k]
0以外を選択する: dp[i][k] += dp[i - 1][k - 1] * 9   確定していない 桁iが0の時: Nより小さくすることはできないので何もしない
桁iが0でない時: 1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができるので，桁i-1までに0以外の数字が出現した回数をjとするとdp[i][j + 1] += (桁iの数字 - 1)    桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．
最終的な出力はdp[|N| - 1][K] + ((N自身が条件を満たす)?</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>けもフレチックでした．
A~Eまで
A問題 (H + A - 1) / A するだけ
B問題 必殺技の総和をとって大小比較
C問題 体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃
D問題 等比数列の和
E問題 DP
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC153</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>A~E問題まで．
A問題 if文で分岐するだけ
B問題 辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される． 2数の大きい方の値の回数だけ，小さい方の値を出力する．
C問題 数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．
D問題 与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく． 例えば334は34，398は38という感じ． あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．
E問題 modの逆元を知らないと厳しい問題．参考
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める． LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC152</description>
    </item>
    
  </channel>
</rss>