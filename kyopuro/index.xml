<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuros on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuros on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 22 Feb 2020 22:17:59 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>4完．解答
A問題 算数
B問題 nが0になるまでkで割り続ける
C問題 座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．
D問題 組み合わせの問題．
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く． 組み合わせの総和は2^n - 1になる． a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．
modInvのJava実装の例</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>無念の三冠． D以降は後日追加するかも．
A問題 重複を調べる問題．
愚直に比較しても良いけど，Setを使うのが早そう．
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．
B問題 fizzbuzzみたいな問題．
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．
C問題 連想配列を使って数え上げる典型的な問題．
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(Collections.sor())．</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>A~Dまで
A問題 Uで分岐
B問題 入力の文字列の長さの回数&amp;rsquo;x&#39;を出力
C問題 連想配列を使って数字が出現したかを確認
D問題 毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく． あとは連続したkの要素の期待値の合計をそれぞれ求めるだけ．</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>けもフレチックでした．
A~Eまで
A問題 (H + A - 1) / A するだけ
B問題 必殺技の総和をとって大小比較
C問題 体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃
D問題 等比数列の和
E問題 DP
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC153</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>A~E問題まで．
A問題 if文で分岐するだけ
B問題 辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される． 2数の大きい方の値の回数だけ，小さい方の値を出力する．
C問題 数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．
D問題 与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく． 例えば334は34，398は38という感じ． あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．
E問題 modの逆元を知らないと厳しい問題．参考
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める． LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC152</description>
    </item>
    
  </channel>
</rss>