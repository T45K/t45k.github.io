<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuros on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuros on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 27 May 2020 23:41:26 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AGC044の解説</title>
      <link>https://t45k.github.io/kyopuro/agc044/</link>
      <pubDate>Wed, 27 May 2020 23:41:26 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc044/</guid>
      <description>&lt;p&gt;太陽でしたがNoSubなのでレートは変わらなかったです(NoSubというシステムをよく理解していなかったので，入力するのではないかとドキドキしてました)．
A，Bの解説．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/AGC/AGC044&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---pay-to-win&#34;&gt;A - Pay to Win&lt;/h2&gt;
&lt;p&gt;400点問題だと高を括って望んだら痛い目にあった．&lt;br&gt;
簡単に説明するとNから2，3，5で割っていくだけ．
メモ化(b|d)fs．
メモは値をキー，コストをバリューとしたMapで持つ．
bfsで解く場合は，キューから取り出した値Kに対して&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(a,d*K/2)&lt;/code&gt;（2で割るか，同じ値だけ1を引くかのコストが小さい方）がメモ[K/2]を更新できなければ何もしない．更新できれば，K/2をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K+1とK-1は2で割れるので，割れる場合と同じ処理をする．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(b,d*2*K/3)&lt;/code&gt;がメモ[K/3]を更新できなければ何もしない．更新できれば，K/3をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K-K%3とK+3-K%3はKで割り切れるので，割れる場合と同じ処理をする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5で割れるか試す．略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;をやるだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---joker&#34;&gt;B - Joker&lt;/h2&gt;
&lt;p&gt;計算量の見積もりが難しい問題．&lt;br&gt;
N&amp;lt;=500に対して，与えられる座標の数はN^2なので，座標が与えられる度に(d|b)fsすると間に合わないように見える．
しかし，実は間に合う．
1回の(b|d)fsでいくつかの座標の端からの距離が減る
では全ての走査で行われる操作は合計でO(n^3)で収まる
例えばN=6の時，最初の各座標の端からの距離は以下のようになる&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
全てを走査しきる（= 各座標の端からの距離が0になる）のは 4*4 + 2*2(四角形を狭めていくイメージ)回の操作が必要となる．
合計するとだいたい (N^3)/6 らしいので条件下で間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC168の解説</title>
      <link>https://t45k.github.io/kyopuro/abc168/</link>
      <pubDate>Tue, 19 May 2020 19:54:50 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc168/</guid>
      <description>&lt;p&gt;速解き回だったけど速解き失敗．
4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC168&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a----therefore&#34;&gt;A - ∴ (Therefore)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;文を使う問題．
コードが長くなりがち．
Kotlinだと気持ちよく書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;fun main() {
    Scanner(System.`in`)
        .run {
            when (this.nextInt() % 10) {
                3 -&amp;gt; &amp;#34;bon&amp;#34;
                0, 1, 6, 8 -&amp;gt; &amp;#34;pon&amp;#34;
                else -&amp;gt; &amp;#34;hon&amp;#34;
            }.apply(::println)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;b----triple-dots&#34;&gt;B - &amp;hellip; (Triple Dots)&lt;/h2&gt;
&lt;p&gt;やるだけ．
Sの長さがKを上回っているとき，&lt;code&gt;S.substring(0, K.length)&lt;/code&gt;．&lt;/p&gt;
&lt;h2 id=&#34;c----colon&#34;&gt;C - : (Colon)&lt;/h2&gt;
&lt;p&gt;数学．&lt;br&gt;
極座標か余弦定理を使うと簡単に解ける．
意外と二つの針の間の角度を求めるのが曲者．&lt;/p&gt;
&lt;h2 id=&#34;d----double-dots&#34;&gt;D - .. (Double Dots)&lt;/h2&gt;
&lt;p&gt;嫌な気持ちになります．&lt;br&gt;
問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e----bullet&#34;&gt;E - ∙ (Bullet)&lt;/h2&gt;
&lt;p&gt;解説AC&lt;br&gt;
解く手順としては&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪いイワシを組み合わせないようにする方法&lt;/li&gt;
&lt;li&gt;最終的な組み合わせを数え上げる方法
の2つを考える．&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-仲の悪いイワシを組み合わせないようにする方法&#34;&gt;1. 仲の悪いイワシを組み合わせないようにする方法&lt;/h3&gt;
&lt;p&gt;Ai * Aj + Bi * Bj = 0という条件から，美味しさと香り高さがどちらも0のイワシは全てのイワシと仲が悪い．
それ以外のイワシについて考えると，仲が悪くなるにはAi = a, Bi =bの時，Aj = k&lt;em&gt;b, Bj = -k&lt;/em&gt;aとなる必要がある(kは0以外の整数)．
なのでイワシを2種類のグループに分ける．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致する&lt;/li&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致しない&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;そうすると，それぞれのグループを美味しさと香り高さを互いに素にした値のペアをキー，出現回数をバリューとしたマップにすると，それぞれのキーに対して仲の悪いイワシの数が分かる．
例えば，グループ1のキーを(美味しさの絶対値をGCDで割った値，香り高さの絶対値をGCDで割った値)，グループ2のキーを(香り高さの絶対値をGCDで割った値，美味しさの絶対値をGCDで割った値)にしておくと，グループ1とグループ2の共通するキーが仲の悪い組み合わせになる．&lt;/p&gt;
&lt;h3 id=&#34;2-最終的な組み合わせを数え上げる方法&#34;&gt;2. 最終的な組み合わせを数え上げる方法&lt;/h3&gt;
&lt;p&gt;まず，全てのイワシが仲が悪くないとき，組み合わせの総数は，どのイワシも選ばない組み合わせを除いて2^N-1になる．
これを踏まえると，先ほどのグループ1，2の各キーに対して，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪い組み合わがある場合，それぞれのバリューp,qに対して 2^p + 2^q - 1&lt;br&gt;
これはグループ1，2両方のイワシを同時に加えることはできないので別々に計算する．グループ1だけから選ぶ場合は2^p通り，グループ2からだけ選ぶ場合は2^q通りになる．最後に，グループ1，2両方とも選ばない場合が重複しているので1引く．&lt;/li&gt;
&lt;li&gt;仲の悪い組み合わせがない場合，そのバリューpに対して 2^p&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を掛けていき，最終的に1引いた値（どのイワシも選ばない組み合わせ）が答えになる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC167の解説</title>
      <link>https://t45k.github.io/kyopuro/abc167/</link>
      <pubDate>Mon, 11 May 2020 11:43:31 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc167/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/t45k/tree/master/AtCoder/ABC/ABC167&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---registration&#34;&gt;A - Registration&lt;/h2&gt;
&lt;p&gt;文字列Sと文字列Tの最後の文字を消した文字列が同等か確認する．
javaだと &lt;code&gt;S.equals(T.substring(0, S.length))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;b---easy-linear-programming&#34;&gt;B - Easy Linear Programming&lt;/h2&gt;
&lt;p&gt;A,B,Cの順番になるべく多くカードを取ると最大値になるので&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KがA以下なら1のカードをK枚取って和はK&lt;/li&gt;
&lt;li&gt;Kが(A+B)以下なら，1のカードをA枚，0のカードを取れるだけ取って和はA&lt;/li&gt;
&lt;li&gt;それ以外なら1をA枚，0をB枚，-1を(K-(A+B))枚取って和は2A+B+K&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c---skill-up&#34;&gt;C - Skill Up&lt;/h2&gt;
&lt;p&gt;bit全探索するだけ問題．&lt;br&gt;
N&amp;lt;=12なので，全て試しても2^12≒4000通りなので十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---teleporter&#34;&gt;D - Teleporter&lt;/h2&gt;
&lt;p&gt;ABC030_Dとほぼ同じ問題．&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;knのとき&#34;&gt;K&amp;lt;=Nのとき&lt;/h3&gt;
&lt;p&gt;K回のテレポートを愚直に計算しても間に合う．&lt;/p&gt;
&lt;h3 id=&#34;knの時&#34;&gt;K&amp;gt;Nの時&lt;/h3&gt;
&lt;p&gt;鳩の巣原理的に考えると，必ずどこかでループが発生することになる．
なので，1ループで訪れる町の数でmodを取る．&lt;/p&gt;
&lt;h2 id=&#34;e---colorful-blocks&#34;&gt;E - Colorful Blocks&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．&lt;br&gt;
全て隣り合わない組み合わせは m*(m-1)^(n-1)になる．
1組隣り合う場合，その隣り同士は同じ色なので ↑/(m-1)
↑に組み合わせをかける．一つ右とペアになると考えれば n-1C1 通り
2組以降も同じように考える．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC166の解説</title>
      <link>https://t45k.github.io/kyopuro/abc166/</link>
      <pubDate>Mon, 04 May 2020 22:58:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc166/</guid>
      <description>&lt;p&gt;二日連続ABCの二日目．
ABCEの4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC166&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---ac&#34;&gt;A - A?C&lt;/h2&gt;
&lt;p&gt;分岐するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---trick-or-treat&#34;&gt;B - Trick or Treat&lt;/h2&gt;
&lt;p&gt;数え上げるだけ&lt;/p&gt;
&lt;h2 id=&#34;c---peaks&#34;&gt;C - Peaks&lt;/h2&gt;
&lt;p&gt;結構誤読してた人が多かった問題&lt;br&gt;．
問題文から，i番目の展望台が地震を含めて繋がっている展望台の中で一番高ければ良いことが分かる．
つまり，繋がっている展望台のどれか一つでも自身より高いものが良い展望台となる．
なので，各A,Bに対して大きい方だけ残していくという戦略を取れば，残ったものが良い展望台である．&lt;/p&gt;
&lt;h2 id=&#34;d---i-hate-factorization&#34;&gt;D - I hate Factorization&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
問題文を誤読しないように．
&lt;strong&gt;任意の&lt;/strong&gt;Xについて成り立っているのではなく，&lt;strong&gt;テストケースとして与えられる&lt;/strong&gt;Xについて成り立つ．
およそ200くらいが上限となるらしいので，それについて全探索するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---this-message-will-self-destruct-in-5s&#34;&gt;E - This Message Will Self-Destruct in 5s&lt;/h2&gt;
&lt;p&gt;条件は添字i,jに対して&lt;code&gt;i - j = Ai + Aj&lt;/code&gt;であり，これを式変形すると&lt;code&gt;i - Ai = j + Aj&lt;/code&gt;となる．
つまり，(添字と身長の差)と(添字と身長の和)が同じ値になるペアが条件を満たす．
なので各Aに対して添字との差と和をあらかじめ計算しておけば解ける&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC165の解説</title>
      <link>https://t45k.github.io/kyopuro/abc165/</link>
      <pubDate>Mon, 04 May 2020 22:58:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc165/</guid>
      <description>&lt;p&gt;二日連続ABCの一日目．
3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC165&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---we-love-golf&#34;&gt;A - We Love Golf&lt;/h2&gt;
&lt;p&gt;きちんと数学して解くこともできるが，制約が小さいので全探索しても間に合う．
AからBまでの閉区間内にKの倍数があるか確認する．&lt;/p&gt;
&lt;h2 id=&#34;b---1&#34;&gt;B - 1%&lt;/h2&gt;
&lt;p&gt;これもきちんと数学して解けるけど全探索で解ける系．
入力例から分かるように，10^18が与えられても出力は3760になるので，1~3760までの区間を探索するだけで良い．&lt;/p&gt;
&lt;h2 id=&#34;c---many-requirements&#34;&gt;C - Many Requirements&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
これも全探索するだけ問題．
考えられる数列を全列挙して特典の最大値を探す．&lt;br&gt;
全列挙に必要な計算量が10^10だと思っていたので試さなかったが，実際にはボールとしきりの要領で組み合わせを考えると計算量は*O(N * C(N+M-1,N))*なので，全列挙しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---floor-function&#34;&gt;D - Floor Function&lt;/h2&gt;
&lt;p&gt;数学．editorialが分かりやすいです．&lt;/p&gt;
&lt;h2 id=&#34;e---rotation-matching&#34;&gt;E - Rotation Matching&lt;/h2&gt;
&lt;p&gt;同じ組み合わせを避けていく問題．&lt;br&gt;
例えば，組み合わせ(1,N)は(1,2)と同じ組み合わせになる．
したがって，(組み合わせの方の大きい方)-(小さい方)を&lt;strong&gt;組み合わせの距離&lt;/strong&gt;と定義すると，距離N-iと距離iは同じ組み合わせである．
これを念頭に入れてN-1からN-mまでの組み合わせを考えていく．
(1,N)(2,N-1)&amp;hellip;と作っていくと距離N-1,N-3&amp;hellip;と1飛ばしに組み合わせを作れる．
途中で折り返しをうまく調整して距離N-2,N-4&amp;hellip;の組み合わせを作る．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC164の解説</title>
      <link>https://t45k.github.io/kyopuro/abc164/</link>
      <pubDate>Mon, 27 Apr 2020 23:38:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc164/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/atcoder/abc/abc164&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---sheep-and-wolves&#34;&gt;A - Sheep and Wolves&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---battle&#34;&gt;B - Battle&lt;/h2&gt;
&lt;p&gt;割った余りを求めるのがスマートだけで，先攻後攻の概念があるので愚直に互いに引いていった方が安全．&lt;/p&gt;
&lt;h2 id=&#34;c---gacha&#34;&gt;C - gacha&lt;/h2&gt;
&lt;p&gt;JavaだとSetに打ち込めば良い．
&lt;code&gt;Stream#distinct&lt;/code&gt;からの&lt;code&gt;Stream#count&lt;/code&gt;で多少スマートに書ける．&lt;/p&gt;
&lt;h2 id=&#34;d---multiple-of-2019&#34;&gt;D - Multiple of 2019&lt;/h2&gt;
&lt;p&gt;各桁に対して，i桁目の数字がDiとして&lt;code&gt;Si = (10 ^ i * Di + Si-1) % 2019&lt;/code&gt;を計算すると，Siが同じ値の桁間の数字は2019の倍数になる．&lt;/p&gt;
&lt;h2 id=&#34;e---two-currencies&#34;&gt;E - Two Currencies&lt;/h2&gt;
&lt;p&gt;むずかしかった．&lt;br&gt;
(頂点番号, 所持金)を一つの頂点としてダイクストラする．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC163の解説</title>
      <link>https://t45k.github.io/kyopuro/abc163/</link>
      <pubDate>Tue, 21 Apr 2020 16:22:58 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc163/</guid>
      <description>&lt;p&gt;3完．
unratedで良かった&amp;hellip;
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/ABC/ABC163&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---circle-pond&#34;&gt;A - Circle Pond&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
円周は&lt;code&gt;2 * r * 円周率&lt;/code&gt;．
Javaだと円周率は&lt;code&gt;java.lang.Math.PI&lt;/code&gt;が使える．&lt;/p&gt;
&lt;h2 id=&#34;b---homework&#34;&gt;B - Homework&lt;/h2&gt;
&lt;p&gt;全ての宿題をやるには&lt;code&gt;Σ Ai&lt;/code&gt;日かかるので，それを&lt;code&gt;M&lt;/code&gt;と比較する．&lt;/p&gt;
&lt;h2 id=&#34;c---management&#34;&gt;C - management&lt;/h2&gt;
&lt;p&gt;問題文が若干ややこしい．
やることは特定の数字が何回出てくるかを数えるだけ．
はじめに配列&lt;code&gt;array[N + 1]&lt;/code&gt;を用意して，各&lt;code&gt;Ai&lt;/code&gt;に対して&lt;code&gt;array[Ai]++&lt;/code&gt;する．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-large-numbers&#34;&gt;D - Sum of Large Numbers&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．
組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった&amp;hellip;&lt;br&gt;
各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない．
あるiに対して&lt;code&gt;front_sum&lt;/code&gt;を0からi-1までの和，&lt;code&gt;back_sum&lt;/code&gt;をn-i+1からnまでの和とすると，
i個選択する時の組み合わせによって得られる和は&lt;code&gt;i * 10^100 + front_sum&lt;/code&gt;から&lt;code&gt;i * 10^100 + back_sum&lt;/code&gt;までの間に収まる．
つまり，&lt;code&gt;back_sum - front_sum + 1&lt;/code&gt;通りになる．
&lt;code&gt;front_sum&lt;/code&gt;と&lt;code&gt;back_sum&lt;/code&gt;は累積和で取れるので，iをKからNまで動かして足し合わせれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---active-infants&#34;&gt;E - Active Infants&lt;/h2&gt;
&lt;p&gt;原始的なDP（ほんまか？）．&lt;br&gt;
活発度が高い順に左か右に移動させる．
活発度を降順にソートした時，&lt;code&gt;dp[i][j]&lt;/code&gt;を，&lt;strong&gt;(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさ&lt;/strong&gt;という風に考える．
そうすると，&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;strong&gt;左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させる&lt;/strong&gt;か&lt;strong&gt;左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させる&lt;/strong&gt;の嬉しさが大きい方になる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC162の解説</title>
      <link>https://t45k.github.io/kyopuro/abc162/</link>
      <pubDate>Mon, 13 Apr 2020 16:57:30 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc162/</guid>
      <description>&lt;p&gt;祝参加者1万人越え．無念の4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC162&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---lucky-7&#34;&gt;A - Lucky 7&lt;/h2&gt;
&lt;p&gt;やるだけ．文字列で読み込んで&lt;code&gt;String#contains&lt;/code&gt;を使うと早い．&lt;/p&gt;
&lt;h2 id=&#34;b---fizzbuzz-sum&#34;&gt;B - FizzBuzz Sum&lt;/h2&gt;
&lt;p&gt;これもやるだけ．&lt;code&gt;LongStream&lt;/code&gt;できれいに書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;LongStream.rangeClosed(1, scanner.nextInt())
    .filter(i -&amp;gt; i % 3 != 0 &amp;amp;&amp;amp; i % 5 != 0)
    .sum();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---sum-of-gcd-of-tuples-easy&#34;&gt;C - Sum of gcd of Tuples (Easy)&lt;/h2&gt;
&lt;p&gt;三重ループを回すだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---rgb-triplets&#34;&gt;D - RGB Triplets&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;N &amp;lt;= 4,000&lt;/code&gt;なので二重ループで回すことを考える．
ある座標以降のそれぞれの色が何個あるかを記録する．
これは後ろから累積和をとることで可能．
こうすることで，例えば&lt;code&gt;i&lt;/code&gt;が赤色，&lt;code&gt;j&lt;/code&gt;が緑色のとき，&lt;code&gt;j+1&lt;/code&gt;以降の青色の個数を&lt;code&gt;O(1)&lt;/code&gt;で得られる．
また，&lt;code&gt;k-j ≠ j-i&lt;/code&gt;の条件を満たすために，k-j = j-iとなるkに対して&lt;code&gt;(j+1以降の数) - (k以降の数) + (k+1以降の数)&lt;/code&gt;と計算すれば良い(累積和の性質から)．&lt;/p&gt;
&lt;h2 id=&#34;e---sum-of-gcd-of-tuples-hard&#34;&gt;E - Sum of gcd of Tuples (Hard)&lt;/h2&gt;
&lt;p&gt;解法は思いついていたが計算量的にダメだと思っていて放置していたやつ&lt;br&gt;．
解答が詳しいのでそちらを参照．
繰り返し二乗法などを使うと速くなる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC161の解説</title>
      <link>https://t45k.github.io/kyopuro/abc161/</link>
      <pubDate>Sat, 04 Apr 2020 22:53:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc161/</guid>
      <description>&lt;p&gt;100-200-300-400-600の5完．
人生初のオンサイト600点問題AC．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC161&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---abc-swap&#34;&gt;A - ABC Swap&lt;/h2&gt;
&lt;p&gt;Z，X，Yを順に出力するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---popular-vote&#34;&gt;B - Popular Vote&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
割り算の結果を比較するときは，&lt;code&gt;a &amp;gt; b / c&lt;/code&gt;ではなく&lt;code&gt;a * c &amp;gt; b&lt;/code&gt;のように書いたほうが正確．&lt;/p&gt;
&lt;h2 id=&#34;c---replacing-integer&#34;&gt;C - Replacing Integer&lt;/h2&gt;
&lt;p&gt;方針立てるのに時間かかった問題．&lt;br&gt;
直感的には分かりづらいけど以下のように言い換えられる(chokudaiさんのツイート)．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C問題、数学の問題といえばそうなんだけど、「無限に長いすごろくがあります。ゴールまでの距離がxです。Kマスずつ進めますが、ゴールを通り過ぎてしまう場合は折り返します。最もゴールに近づく時の残りマス数を答えなさい」みたいにすると、まぁ一応ちゃんとしたストーリーはつくよね。&lt;/p&gt;&amp;mdash; chokudai(高橋 直大)🌸🍆🍡 (@chokudai) &lt;a href=&#34;https://twitter.com/chokudai/status/1246435428476973063?ref_src=twsrc%5Etfw&#34;&gt;April 4, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;というわけで，&lt;code&gt;N % K&lt;/code&gt;と&lt;code&gt;(N - (N % K)) % K&lt;/code&gt;の小さい方を求める．&lt;/p&gt;
&lt;h2 id=&#34;d---lunlun-number&#34;&gt;D - Lunlun Number&lt;/h2&gt;
&lt;p&gt;想定解が天才すぎる．愚直に解いた．&lt;br&gt;
i番目の数字に対して，i + 1番目の数字を次のように決める．各桁を下から順番に見ていく．もし見ている桁が9でなく，かつ次の桁の数字より1小さいか同じなら，その桁をインクリメントし，それ以降の桁をルンルン数かつ最小となるように調整(つまり，&amp;lsquo;上の桁 - 1&amp;rsquo;か&#39;0&amp;rsquo;)した値がi + 1番目の数になる．どの桁も条件に当てはまらなければ，一番大きい桁をインクリメントする．&lt;br&gt;
各桁を確認，操作する場合は，数字をいったんchar型配列にするとやりやすいかも．&lt;/p&gt;
&lt;h2 id=&#34;e---yutori&#34;&gt;E - Yutori&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;br&gt;
前から貪欲と後ろから貪欲の結果を比較するだけ．解説に登場する配列L，Rを求めなくても，二分探索しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;f---division-or-substraction&#34;&gt;F - Division or Substraction&lt;/h2&gt;
&lt;p&gt;E問題よりACが多いF問題．&lt;br&gt;
まずNに対して以下の数字は必ず条件を満たす&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2: 偶数は割っていくと，奇数は引いていくと最終的に1になるため&lt;/li&gt;
&lt;li&gt;N - 1: 引くと1になるため&lt;/li&gt;
&lt;li&gt;N: 割ると1になるため&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それ以外に関しては関しては次のようになる．
ちなみに&amp;quot;何回か引いた後にに，何回か割る&amp;quot;という操作は発生しない．&lt;/p&gt;
&lt;h3 id=&#34;引くことしか考えない&#34;&gt;引くことしか考えない&lt;/h3&gt;
&lt;p&gt;N % L == 1 となるLを考えればよい．
このLは，N - 1の約数列挙を行うことで求まる．&lt;/p&gt;
&lt;h3 id=&#34;何回か割って何回か引く&#34;&gt;何回か割って，何回か引く&lt;/h3&gt;
&lt;p&gt;これは 3 ~ sqrt(N) (sqrt(N)を超過すると，1回割っただけで割る数を下回ってしまうので考えなくて良い)の各値iに対して，余りが0である間可能な限りiで割った後に，&lt;code&gt;N % i == 1&lt;/code&gt;となるかを確認すれば良い．&lt;/p&gt;
&lt;p&gt;これらの結果を足し合わせるだけ．
この解法だと&lt;strong&gt;2&lt;/strong&gt;がコーナーケースになることに注意．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC160の解説</title>
      <link>https://t45k.github.io/kyopuro/abc160/</link>
      <pubDate>Sat, 28 Mar 2020 23:27:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc160/</guid>
      <description>&lt;p&gt;5完．&lt;a href=&#34;https://github.com/T45K/tree/master/AtCoder/ABC/ABC160&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---coffee&#34;&gt;A - Coffee&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．&lt;code&gt;String#charAt&lt;/code&gt;を使う&lt;/p&gt;
&lt;h2 id=&#34;b---golden-coins&#34;&gt;B - Golden Coins&lt;/h2&gt;
&lt;p&gt;なるべく多くの500円に換金した方が良いので，まずは&lt;code&gt;X&lt;/code&gt;を500で割る．
余りを50で割って，それぞれの商に1000と5を掛けて出力．&lt;/p&gt;
&lt;h2 id=&#34;c---traveling-salesman-around-lake&#34;&gt;C - Traveling Salesman around Lake&lt;/h2&gt;
&lt;p&gt;ある家からその一つ手前の家までをぐるっと一周回ってくるのが最適となる．
1番目の家からN番目の家までに移動距離は&lt;code&gt;Ai - AN&lt;/code&gt;，それ以外の家iから家i - 1までは&lt;code&gt;K - Ai + Ai-1&lt;/code&gt;になるので，その中の最小値が答え．&lt;/p&gt;
&lt;h2 id=&#34;d---line&#34;&gt;D - 	Line++&lt;/h2&gt;
&lt;p&gt;ワーシャルフロイドっぽい問題．&lt;br&gt;
まず初めにX，Yを経由しない場合の全ての頂点間の距離を求める．
これはグラフを隣接行列で表すと&lt;code&gt;graph[i][j] = |i - j|&lt;/code&gt;となる．&lt;br&gt;
次に，XまたはYを経由した場合を考えた上で，全ての頂点間の最短距離を求める．
これは&lt;code&gt;graph[i][j] = min(graph[i][j], graph[i][X] + graph[X][j])&lt;/code&gt;となる．&lt;br&gt;
最後に，隣接行列の中で各距離の出現回数を記録し，それを出力する．&lt;/p&gt;
&lt;h2 id=&#34;e---red-and-green-apples&#34;&gt;E - Red and Green Apples&lt;/h2&gt;
&lt;p&gt;貪欲にやるだけ．&lt;br&gt;
美味しさを最大化したいとき，赤リンゴを降順に並べたときのX+1つ目以降と緑リンゴを降順に並べたときののY+1つ目以降は捨ててもよい．
後はそれぞれのリンゴの小さいものを順番に無色のものと入れ替えるだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC159の解説</title>
      <link>https://t45k.github.io/kyopuro/abc159/</link>
      <pubDate>Sun, 22 Mar 2020 22:48:22 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc159/</guid>
      <description>&lt;p&gt;奇跡的に5完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC159&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---the-number-of-even-pairs&#34;&gt;A - The Number of Even Pairs&lt;/h2&gt;
&lt;p&gt;和が正になるのは&lt;code&gt;even + even&lt;/code&gt;か&lt;code&gt;odd + odd&lt;/code&gt;の時なので，偶奇それぞれに対して組み合わせ(&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;)を計算して足し合わせる．&lt;/p&gt;
&lt;h2 id=&#34;b---string-palindrome&#34;&gt;B - String Palindrome&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．
回文系の問題は以下のようなメソッドを作っとくと便利かも．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; isPalindrome(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; end, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; ; i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (start + i &amp;gt;= end - i) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.charAt(start + i) != s.charAt(end - i)) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---maximum-volume&#34;&gt;C - Maximum Volume&lt;/h2&gt;
&lt;p&gt;Lの1/3の3乗&lt;/p&gt;
&lt;h2 id=&#34;d---banned-k&#34;&gt;D - Banned K&lt;/h2&gt;
&lt;p&gt;考えた方としては，初めに何も取り除かないときの組み合わせの総数を求めておいて，それを使って取り除いた数字の組み合わせを計算し直すという感じ．&lt;br&gt;
初めに全ての組み合わせの和を計算する．
これは連想配列を用いてどの数字が何回出てくるかを数え上げて，各回数に対して&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を計算して足し合わせるだけ．
次に，各数字を取り除いた場合を考える．
取り除いた数字の組み合わせは&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;になってしまうので，総和から&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を引いて&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;を足した数が求めたい数字になる．&lt;/p&gt;
&lt;h2 id=&#34;e---dividing-chocolate&#34;&gt;E - Dividing Chocolate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;が大きなヒント．&lt;br&gt;
&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;から，横方向に切る組み合わせは全探索を使える(&lt;code&gt;2 ^ 10 ≒ 10 ^ 3&lt;/code&gt;)．
横方向に切った結果から，Kを超えないように縦方向に切らないといけない回数を貪欲に算出できる．&lt;/p&gt;
&lt;h2 id=&#34;f----knapsack-for-all-segments&#34;&gt;F -  Knapsack for All Segments&lt;/h2&gt;
&lt;p&gt;解説AC．なぜか解説通りに実装するとTLEになったため別の方針を採用(&lt;a href=&#34;https://atcoder.jp/contests/abc159/submissions/11164623&#34;&gt;https://atcoder.jp/contests/abc159/submissions/11164623&lt;/a&gt;)．&lt;br&gt;
&lt;code&gt;Ax1 + Ax2 + ... Axn = S&lt;/code&gt;を満たす時，&lt;code&gt;s = 1, 2, ..., x1&lt;/code&gt;，&lt;code&gt;e = xn, xn + 1, ..., N&lt;/code&gt;とすると，sからeまでの文字列は全て条件を満たす．
そこで，始点と終点を決めるためのDPを行う．&lt;br&gt;
答えを表す変数&lt;code&gt;ans&lt;/code&gt;，dp[N][S]を用意し，次の場合分けを考える．j = 0 .. S - 1 に対して，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;場合分け&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Ai を足さない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;dp[N][j] = dp[N - 1][j]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Ai を足す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Ai を始点にする場合 dp[N][j] += dp[N - 1][j] + i&lt;br&gt;Ai を始点にしない場合 dp[N][j + Ai] += dp[N - 1][j]&lt;br&gt;Ai を終点にする場合 answer += dp[N - 1][S - Ai] * (n - i)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>&lt;script async src=&#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;
&lt;p&gt;1完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/AGC/AGC043&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---range-flip-find-route&#34;&gt;A - Range Flip Find Route&lt;/h2&gt;
&lt;p&gt;全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;&lt;/p&gt;
&lt;p&gt;右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）．
なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる．
ダイクストラ法を使うと計算量は頂点数&lt;code&gt;V&lt;/code&gt;と辺数&lt;code&gt;E&lt;/code&gt;に対して&lt;code&gt;O(V * log(E))&lt;/code&gt;となる．
今回の頂点数Vは&lt;code&gt;V &amp;lt;= H * W = 10 ^ 4&lt;/code&gt;となる．
また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;b---123-triangle&#34;&gt;B - 123 Triangle&lt;/h2&gt;
&lt;p&gt;誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)&lt;/p&gt;
&lt;p&gt;答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する．
各aは先に1引いといても問題ない．
偶奇判定なので，&lt;code&gt;abs(a - b)&lt;/code&gt;ではなく&lt;code&gt;a xor b&lt;/code&gt;で良い．
そうすると，
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mo&gt;(&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,2&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mo&gt;&amp;hellip;&lt;/mo&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,n&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;)&lt;/mo&gt;
&lt;mo&gt;%&lt;/mo&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/math&gt;
となる．
そのため，各組み合わせを計算すれば良い．&lt;br&gt;
今回は偶奇が欲しいので，各組み合わせの2で割った余りだけで十分である．
そこで&lt;a href=&#34;https://mathtrain.jp/lucastheorem&#34;&gt;&lt;strong&gt;Lucasの定理&lt;/strong&gt;&lt;/a&gt;を用いる(リンク参照)．
定理に従うと手順はこう．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初めに&lt;code&gt;n - 1&lt;/code&gt;を二進数に変換する&lt;/li&gt;
&lt;li&gt;各aを二進数に変換する(&lt;code&gt;n - 1&lt;/code&gt;の二進数表現と桁を揃えることに注意)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n - 1&lt;/code&gt;と&lt;code&gt;a&lt;/code&gt;の二進数表現の各桁(それぞれm，nとする)に対して組み合わせ(つまり，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;m&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;
)を計算する(各桁は0か1なので，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;の時だけ0でそれ以外は1になる)&lt;/li&gt;
&lt;li&gt;組み合わせの計算結果をかけ合わせる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これで
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;/math&gt;
の偶奇が出るので，答えが1かどうかが分かる．&lt;br&gt;
答えが奇数の場合は，数字列中に1が含まれていれば答えは0となる&lt;br&gt;
それでも決まらなければ，各aを2で割った上でもう一度偶奇を計算すると0か2が確定する．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/pana20&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---kth-term&#34;&gt;A - Kth Term&lt;/h2&gt;
&lt;p&gt;実装するだけ．
Javaの場合は問題文をコピペして&lt;code&gt;final int[] array = {1, 1, ...};&lt;/code&gt;と宣言すると早い．&lt;/p&gt;
&lt;h2 id=&#34;b---bishop&#34;&gt;B - Bishop&lt;/h2&gt;
&lt;p&gt;ここに一番時間を吸われた．&lt;br&gt;
問題例を見ると最終的に&lt;code&gt;(h * w + 1) / 2&lt;/code&gt;でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．&lt;/p&gt;
&lt;h2 id=&#34;c---sqrt-inequality&#34;&gt;C - Sqrt Inequality&lt;/h2&gt;
&lt;p&gt;ここにも時間を吸われた．&lt;br&gt;
&lt;code&gt;Math#sqrt&lt;/code&gt;を使うと解けそうな気がするが，精度の都合上間違いになることがある．
今回は式変換を行うと&lt;code&gt;4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2ca&lt;/code&gt;に持っていけるので，そこに代入するだけ．
あるいは&lt;code&gt;BigDecimal&lt;/code&gt;を使っても大丈夫らしい．&lt;/p&gt;
&lt;h2 id=&#34;d---string-equivalence&#34;&gt;D - String Equivalence&lt;/h2&gt;
&lt;p&gt;偶然通った問題．&lt;br&gt;
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;e---three-substrings&#34;&gt;E - Three Substrings&lt;/h2&gt;
&lt;p&gt;全探索の問題．&lt;a href=&#34;https://www.hamayanhamayan.com/entry/2020/03/15/002311&#34;&gt;ここ&lt;/a&gt;を参考にした．&lt;br&gt;
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう．
以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．&lt;br&gt;
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる．
コードだとこんな感じ．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] init(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; length, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String b) {&lt;span style=&#34;font-style:italic&#34;&gt;// 配列の初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] array = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[length]; &lt;span style=&#34;font-style:italic&#34;&gt;// lengthは十分大きい値
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    Arrays.fill(array, &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;);
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; a.length(); i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; b.length() &amp;amp;&amp;amp; i + j &amp;lt; a.length(); j++) {
            &lt;span style=&#34;font-style:italic&#34;&gt;// 文字列aの位置i以降がbと被っているかの確認
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!match(a.charAt(i + j), b.charAt(j))) { 
                array[i] = &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
                &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            }
        }
    }
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; array;
}
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; match(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; b) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; a == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || b == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || a == b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;それぞれの結果をab，ac，bcとする．&lt;br&gt;
これらの配列の&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab[i] == true&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc[j] == true&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に対して&lt;code&gt;ac[i + j] == true&lt;/code&gt;となれば，その配置は矛盾がないことになる．
図だとこんな感じ&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://t45k.github.io/img/kyopuro/pana2020_e.png&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;iの探索範囲は0からaの長さ，jの探索範囲はbの長さかiからaの終端までの長さの長い方になる．&lt;br&gt;
あとは長さの最小値を出すだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc061/tasks/abc061_d&#34;&gt;ABC061 D - Score Attack&lt;/a&gt;の別解．&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/ABC061/D/MainAlt.java&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;問題内容&#34;&gt;問題内容&lt;/h2&gt;
&lt;p&gt;正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題．
解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている．
また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;別解&#34;&gt;別解&lt;/h2&gt;
&lt;p&gt;最長路検出と閉路検出について異なる方法を紹介する．&lt;/p&gt;
&lt;h3 id=&#34;最長路検出&#34;&gt;最長路検出&lt;/h3&gt;
&lt;p&gt;今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である．
BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる．
BFSであることから，n ^ 2 回繰り返せば十分である．&lt;/p&gt;
&lt;h3 id=&#34;閉路検出&#34;&gt;閉路検出&lt;/h3&gt;
&lt;p&gt;解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない．
各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていれば&lt;code&gt;inf&lt;/code&gt;を出力すれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>&lt;p&gt;四完．&lt;a href=&#34;https://github.com/t45k/kyopuro/master/tree/abc158&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---station-and-bus&#34;&gt;A - Station and Bus&lt;/h2&gt;
&lt;p&gt;連想配列にぶちこむ．&lt;/p&gt;
&lt;h2 id=&#34;b---count-balls&#34;&gt;B - Count Balls&lt;/h2&gt;
&lt;p&gt;n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．&lt;/p&gt;
&lt;h2 id=&#34;c---tax-increase&#34;&gt;C - Tax Increase&lt;/h2&gt;
&lt;p&gt;1から20,000くらいまでの整数が条件を満たすか全探索．&lt;/p&gt;
&lt;h2 id=&#34;d---string-formation&#34;&gt;D - String Formation&lt;/h2&gt;
&lt;p&gt;現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する．
クエリが&lt;code&gt;1&lt;/code&gt;ならフラグ反転，クエリが&lt;code&gt;2&lt;/code&gt;の場合は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正順ならクエリ通りに文字追加&lt;/li&gt;
&lt;li&gt;逆順ならクエリとは逆に文字追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をやる．
最終的にフラグを参照してから正しい方向で出力．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StringBuilder#insert&lt;/code&gt;を使うとTLEになりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>&lt;p&gt;なんとか四完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC157&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---duplex-printing&#34;&gt;A - Duplex Printing&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt;に1足して2で割るだけ&lt;/p&gt;
&lt;h2 id=&#34;b---bingo&#34;&gt;B - Bingo&lt;/h2&gt;
&lt;p&gt;実装するだけだが実装量が多くなりがちな問題&lt;/p&gt;
&lt;h2 id=&#34;c---guess-the-number&#34;&gt;C - Guess The Number&lt;/h2&gt;
&lt;p&gt;条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更．
桁数を満たす整数を昇順に条件を満たすか確認する．
余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．&lt;/p&gt;
&lt;h2 id=&#34;d---friend-suggestions&#34;&gt;D - Friend Suggestions&lt;/h2&gt;
&lt;p&gt;Union-Find Treeで殴る問題．
友達関係を取得する時にUnion-Find Treeを構築します．
同時に，それぞれの人が何人友達がいるかを記録します．&lt;br&gt;
ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します．
この時，友達候補でない人を記録する必要はありません．&lt;br&gt;
最終的に，Union-Find Treeから&lt;strong&gt;自分，友達，ブロック関係を含めた自分と繋がっている人&lt;/strong&gt;を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．&lt;br&gt;
余談ですが，&lt;code&gt;Set&lt;/code&gt;をfor文で回すと異様に遅いので，for文を使う場合は&lt;code&gt;List&lt;/code&gt;を使った方が良いです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>&lt;p&gt;最小全域木という概念を知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;最小全域木とは&#34;&gt;最小全域木とは&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanningu Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．&lt;/em&gt;（蟻本より）&lt;br&gt;
つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc065/tasks/arc076_b&#34;&gt;ABC065-D&lt;/a&gt;がこの問題に該当します．&lt;/p&gt;
&lt;h2 id=&#34;解き方&#34;&gt;解き方&lt;/h2&gt;
&lt;p&gt;有名なアルゴリズムとして，クラスカル法とプリム法があります．
今回はプリム法を紹介します．&lt;br&gt;
プリム法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります．
ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// edges は Edge(int label1, int label2, long cost) のリスト
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost));
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; UnionFindTree unionFindTree = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; UnionFindTree(n); &lt;span style=&#34;font-style:italic&#34;&gt;// 要素数nのUnion-Find Treeを構築
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;long&lt;/span&gt; sum = 0;
&lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Edge edge : edges) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!unionFindTree.isSame(edge.label1, edge.label2)) {
        unionFindTree.unit(edge.label1, edge.label2);
        sum += edge.cost;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;辺のソートに一番計算量を食われます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>&lt;p&gt;ワーシャルフロイド法というアルゴリズムを知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;ワーシャルフロイド法とは&#34;&gt;ワーシャルフロイド法とは&lt;/h2&gt;
&lt;p&gt;グラフのある一点から任意の点への最短距離を求めるアルゴリズム．
計算量は点の個数nに対してO(n^3)．
似たようなアルゴリズムに&lt;strong&gt;ダイクストラ法&lt;/strong&gt;があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである．
計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．&lt;/p&gt;
&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;
&lt;p&gt;このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単．
二次元配列を用いた例がこちら．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;void&lt;/span&gt; main(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] args) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[][] graph = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[n][n];
    &lt;span style=&#34;font-style:italic&#34;&gt;// 初めに無限大の値で各要素を初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) {
        Arrays.fill(graph[i], Integer.MAX_VALUE / 2); &lt;span style=&#34;font-style:italic&#34;&gt;// Integer.MAX_VALUEでないことに注意
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        graph[i][i] = 0;
    }

    &lt;span style=&#34;font-style:italic&#34;&gt;// グラフの各辺を与えられた値に変更
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;font-style:italic&#34;&gt;// ここからワーシャルフロイド
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; k = 0; k &amp;lt; graph.length; k++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 出発する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; graph.length; j++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 到着する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;                graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点をとった方が短となるか判定
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三重ループを回すだけである．
注意点は，グラフの初期化時に&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;を代入しないこと．
&lt;code&gt;Math.min&lt;/code&gt;のタイミングでオーバーフローするため&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC156&#34;&gt;解答&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---beginner&#34;&gt;A - Beginner&lt;/h2&gt;
&lt;p&gt;算数&lt;/p&gt;
&lt;h2 id=&#34;b---digits&#34;&gt;B - Digits&lt;/h2&gt;
&lt;p&gt;nが0になるまでkで割り続ける&lt;/p&gt;
&lt;h2 id=&#34;c---rally&#34;&gt;C - Rally&lt;/h2&gt;
&lt;p&gt;座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．&lt;/p&gt;
&lt;h2 id=&#34;d---bouquet&#34;&gt;D - Bouquet&lt;/h2&gt;
&lt;p&gt;組み合わせの問題．&lt;br&gt;
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く．
組み合わせの総和は2^n - 1になる．
a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/util/Utility.java#L360-L390&#34;&gt;modInvのJava実装の例&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>&lt;p&gt;無念の三冠．&lt;/p&gt;
&lt;h2 id=&#34;a---poor&#34;&gt;A - Poor&lt;/h2&gt;
&lt;p&gt;重複を調べる問題．&lt;br&gt;
愚直に比較しても良いけど，Setを使うのが早そう．&lt;br&gt;
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．&lt;/p&gt;
&lt;h2 id=&#34;b---papers-please&#34;&gt;B - Papers, Please&lt;/h2&gt;
&lt;p&gt;fizzbuzzみたいな問題．&lt;br&gt;
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．&lt;/p&gt;
&lt;h2 id=&#34;c---poll&#34;&gt;C - Poll&lt;/h2&gt;
&lt;p&gt;連想配列を使って数え上げる典型的な問題．&lt;br&gt;
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくは&lt;code&gt;Collections#sort&lt;/code&gt;)．
C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．&lt;/p&gt;
&lt;h2 id=&#34;d---pairs&#34;&gt;D - Pairs&lt;/h2&gt;
&lt;p&gt;E問題より難しいD問題．
以下の要素が重なりあってきつい．&lt;/p&gt;
&lt;h3 id=&#34;決め打ち二分探索&#34;&gt;決め打ち二分探索&lt;/h3&gt;
&lt;p&gt;決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す．
単調性とは，ある数 &lt;code&gt;x&lt;/code&gt; に対してその問題が成り立つならば，&lt;code&gt;x&lt;/code&gt; 以降の数字に対しても成り立つような性質を指す．&lt;br&gt;
　実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 &lt;code&gt;isOk(...)&lt;/code&gt; を用意する．
D問題だと&lt;strong&gt;ある値 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;K&lt;/code&gt; が与えられた時に，積が &lt;code&gt;x&lt;/code&gt; 以下となるペアの個数が &lt;code&gt;K&lt;/code&gt; 以上の場合は真&lt;/strong&gt;のようになる．&lt;br&gt;
　次に，二分探索の対象を用意する．このとき，始点は &lt;code&gt;isOk&lt;/code&gt; が偽となり，かつ終点は真となるような範囲を用意する．
今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので &lt;code&gt;0 ~ 10^18&lt;/code&gt; のようになる．&lt;br&gt;
　そして二分探索する．
二分探索では通常範囲を指定するが，この時始点は &lt;code&gt;isOk&lt;/code&gt; が偽，終点は真となることを意識する．
通常の二分探索と同じく対象範囲の真ん中の値(&lt;code&gt;(始点 + 終点) / 2&lt;/code&gt;)をとり，それの真偽を判定する．
真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する．
この操作で，常に始点は偽，終点は真となる．
最終的に始点と終点が連続した値になるため，その終点を解として出力する．&lt;br&gt;
　要約すると，&lt;code&gt;isOk()&lt;/code&gt; を満たす範囲の下界を求める操作だと言える．&lt;/p&gt;
&lt;h3 id=&#34;lower-bound--upper-bound&#34;&gt;Lower Bound / Upper Bound&lt;/h3&gt;
&lt;p&gt;Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた．
計算量もそこまで気にする必要はない．
今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある．
そのため，&lt;strong&gt;Lower Bound&lt;/strong&gt;や&lt;strong&gt;Upper Bound&lt;/strong&gt;を用いる必要がある．&lt;br&gt;
Lower Boundは指定した値&lt;strong&gt;以上&lt;/strong&gt;の要素が初めて出現する場所を取得する．&lt;br&gt;
一方，Upper Boundは指定した値&lt;strong&gt;より大きい要素&lt;/strong&gt;が初めて出現する場所を取得する．&lt;br&gt;
C++ではこれらが標準ライブラリとして提供されているが，Javaにはない．
Javaでは，&lt;code&gt;Collections#binarySearch&lt;/code&gt; の第三引数に以下の &lt;code&gt;Comparator&lt;/code&gt; オブジェクトを渡すことで実現できる．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// 例: List&amp;lt;Long&amp;gt; に対する Comparator
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; lowerBoundComparator = (x, y) -&amp;gt; x &amp;gt;= y ? 1 : -1;
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; upperBoundComparator = (x, y) -&amp;gt; x &amp;gt; y ? 1 : -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ちなみに，これに限らずJavaの標準ライブラリの &lt;code&gt;binarySearch&lt;/code&gt; の結果として負の数が帰ってきた場合，bit反転( &lt;code&gt;~&lt;/code&gt; 演算子)を使うと良い感じになる．&lt;/p&gt;
&lt;h3 id=&#34;負の数の大小比較&#34;&gt;負の数の大小比較&lt;/h3&gt;
&lt;p&gt;今回は負の数の大小を比較したり，負の数の席を求めたりする場面がある．
負の数の大小比較や掛け算は直感と反する場合が多く，考察段階では考えることが増えてしまうことが多い．
そのため，一度負の数を正の数に反転した上で大小比較し，最後に辻褄を合わすようにするのが良い．&lt;/p&gt;
&lt;h2 id=&#34;e---payment&#34;&gt;E - Payment&lt;/h2&gt;
&lt;p&gt;貪欲にやってもできそうな気がするけど，editorial見て正攻法で解答．&lt;br&gt;
いわゆる桁dpの問題(多分)．
今回は，その桁をちょうど払う状態(以降，&lt;strong&gt;just&lt;/strong&gt;)と1多く払う状態(以降，&lt;strong&gt;extra&lt;/strong&gt;)に分けて考える．
言い換えると，extraは繰り下がりを考慮した状態といえる．&lt;br&gt;
上の桁から考えていくと，状態遷移は以下のようになる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;その桁のjust = (前の桁のjust + その桁の数字) か (前の桁のextra + (10 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;li&gt;その桁のextra = (前の桁のjust + その桁の数字 + 1) か (前の桁のextra + (9 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを解いていくと答えになる．&lt;br&gt;
ちなみに，最後の桁は必ずjustとなること，また，最初の桁の前についてもjustとextraを考慮する(99を100で払ったり)ことに注意．&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/T45k/kyopuro/tree/master/AtCoder/ABC/ABC155&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>&lt;p&gt;A~Dまで．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/abc154&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---remaining-balls&#34;&gt;A - Remaining Balls&lt;/h2&gt;
&lt;p&gt;Uで分岐&lt;/p&gt;
&lt;h2 id=&#34;b---i-miss-you&#34;&gt;B - I miss you&amp;hellip;&lt;/h2&gt;
&lt;p&gt;入力の文字列の長さの回数&amp;rsquo;x&amp;rsquo;を出力&lt;/p&gt;
&lt;h2 id=&#34;c---distinct-or-not&#34;&gt;C - Distinct or Not&lt;/h2&gt;
&lt;p&gt;連想配列を使って数字が出現したかを確認&lt;/p&gt;
&lt;h2 id=&#34;d---dice-in-line&#34;&gt;D - Dice in Line&lt;/h2&gt;
&lt;p&gt;毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく．
あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---almost-everywhere-zero&#34;&gt;E - Almost Everywhere Zero&lt;/h2&gt;
&lt;p&gt;桁DP&lt;br&gt;
0でない(= 1 ~ 9)の数字がK回出る回数を数える．
桁を上から決定していき数え上げる．
桁の決定の仕方は，&lt;strong&gt;その桁を決める前の時点でNより小さいことが確定しているかどうか&lt;/strong&gt;で変わる．&lt;br&gt;
確定している場合を&lt;code&gt;dp[|N|][K + 1]&lt;/code&gt;と表現した時に，桁iでの状態遷移は以下のようになる&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;桁i-1での状態&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;桁iでの状態&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;確定している&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k]&lt;/code&gt;&lt;br&gt;0以外を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k - 1] * 9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;確定していない&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;桁iが0の時: Nより小さくすることはできないので何もしない&lt;br&gt;桁iが0でない時: &lt;strong&gt;1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができる&lt;/strong&gt;ので，桁i-1までに0以外の数字が出現した回数をjとすると&lt;code&gt;dp[i][j + 1] += (桁iの数字 - 1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．&lt;br&gt;
最終的な出力は&lt;code&gt;dp[|N| - 1][K] + ((N自身が条件を満たす)? 1 : 0)&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>&lt;p&gt;けもフレチックでした．&lt;/p&gt;
&lt;p&gt;A~Eまで&lt;/p&gt;
&lt;h2 id=&#34;a---serval-vs-monster&#34;&gt;A - Serval vs Monster&lt;/h2&gt;
&lt;p&gt;(H + A - 1) / A するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---common-raccoon-vs-monster&#34;&gt;B - Common Raccoon vs Monster&lt;/h2&gt;
&lt;p&gt;必殺技の総和をとって大小比較&lt;/p&gt;
&lt;h2 id=&#34;c---fennec-vs-monster&#34;&gt;C - Fennec vs Monster&lt;/h2&gt;
&lt;p&gt;体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃&lt;/p&gt;
&lt;h2 id=&#34;d---caracal-vs-monster&#34;&gt;D - Caracal vs Monster&lt;/h2&gt;
&lt;p&gt;等比数列の和&lt;/p&gt;
&lt;h2 id=&#34;e---crested-ibis-vs-monster&#34;&gt;E - Crested Ibis vs Monster&lt;/h2&gt;
&lt;p&gt;DP&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>&lt;p&gt;A~E問題まで．&lt;/p&gt;
&lt;h2 id=&#34;a---ac-or-wa&#34;&gt;A - AC or WA&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---comparing-strings&#34;&gt;B - Comparing Strings&lt;/h2&gt;
&lt;p&gt;辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される．
2数の大きい方の値の回数だけ，小さい方の値を出力する．&lt;/p&gt;
&lt;h2 id=&#34;c---low-elements&#34;&gt;C - Low Elements&lt;/h2&gt;
&lt;p&gt;数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．&lt;/p&gt;
&lt;h2 id=&#34;d---handstand-2&#34;&gt;D - Handstand 2&lt;/h2&gt;
&lt;p&gt;与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく．
例えば334は34，398は38という感じ．
あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---flatten&#34;&gt;E - Flatten&lt;/h2&gt;
&lt;p&gt;modの逆元を知らないと厳しい問題．&lt;a href=&#34;https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-1-mod-p-%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%89%B2%E3%82%8A%E7%AE%97%E3%81%A8%E3%81%AF&#34;&gt;参考&lt;/a&gt;&lt;br&gt;
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める．
LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
