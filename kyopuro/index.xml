<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuros on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuros on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 08 Mar 2020 20:39:29 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>ABC061 D - Score Attackの別解．コード
問題内容 正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題． 解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている． また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．
別解 最長路検出と閉路検出について異なる方法を紹介する．
最長路検出 今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である． BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる． BFSであることから，n ^ 2 回繰り返せば十分である．
閉路検出 解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない． 各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていればinfを出力すれば良い．</description>
    </item>
    
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>四完．コード
A問題 連想配列にぶちこむ．
B問題 n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．
C問題 1から20,000くらいまでの整数が条件を満たすか全探索．
D問題 現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する． クエリが1ならフラグ反転，クエリが2の場合は，
 正順ならクエリ通りに文字追加 逆順ならクエリとは逆に文字追加  をやる． 最終的にフラグを参照してから正しい方向で出力．
StringBuilder#insertを使うとTLEになりました．</description>
    </item>
    
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>なんとか四完．コード
A問題 nに1足して2で割るだけ
B問題 実装するだけだが実装量が多くなりがちな問題
C問題 条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更． 桁数を満たす整数を昇順に条件を満たすか確認する． 余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．
D問題 Union-Find Treeで殴る問題． 友達関係を取得する時にUnion-Find Treeを構築します． 同時に，それぞれの人が何人友達がいるかを記録します．
ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します． この時，友達候補でない人を記録する必要はありません．
最終的に，Union-Find Treeから自分，友達，ブロック関係を含めた自分と繋がっている人を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．
余談ですが，Setをfor文で回すと異様に遅いので，for文を使う場合はListを使った方が良いです．</description>
    </item>
    
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>最小全域木という概念を知ったのでメモ．
最小全域木とは 無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanningu Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．（蟻本より）
つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．
ABC065-Dがこの問題に該当します．
解き方 有名なアルゴリズムとして，クラスカル法とプリム法があります． 今回はプリム法を紹介します．
プリム法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります． ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．
// edges は Edge(int label1, int label2, long cost) のリスト edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost)); final UnionFindTree unionFindTree = new UnionFindTree(n); // 要素数nのUnion-Find Treeを構築 long sum = 0; for (final Edge edge : edges) { if (!unionFindTree.isSame(edge.label1, edge.label2)) { unionFindTree.unit(edge.label1, edge.label2); sum += edge.cost; } } 辺のソートに一番計算量を食われます．</description>
    </item>
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>ワーシャルフロイド法というアルゴリズムを知ったのでメモ．
ワーシャルフロイド法とは グラフのある一点から任意の点への最短距離を求めるアルゴリズム． 計算量は点の個数nに対してO(n^3)． 似たようなアルゴリズムにダイクストラ法があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである． 計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．
実装 このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単． 二次元配列を用いた例がこちら．
public static void main(final String[] args) { final int[][] graph = new int[n][n]; // 初めに無限大の値で各要素を初期化  for (int i = 0; i &amp;lt; graph.length; i++) { Arrays.fill(graph[i], Integer.MAX_VALUE / 2); // Integer.MAX_VALUEでないことに注意  graph[i][i] = 0; } // グラフの各辺を与えられた値に変更  // ここからワーシャルフロイド  for (int k = 0; k &amp;lt; graph.length; k++) { // 中継する点  for (int i = 0; i &amp;lt; graph.</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>4完．解答
A問題 算数
B問題 nが0になるまでkで割り続ける
C問題 座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．
D問題 組み合わせの問題．
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く． 組み合わせの総和は2^n - 1になる． a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．
modInvのJava実装の例</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>無念の三冠．
A問題 重複を調べる問題．
愚直に比較しても良いけど，Setを使うのが早そう．
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．
B問題 fizzbuzzみたいな問題．
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．
C問題 連想配列を使って数え上げる典型的な問題．
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくはCollections#sort)． C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．
D問題 E問題より難しいD問題． 以下の要素が重なりあってきつい．
決め打ち二分探索 決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す． 単調性とは，ある数 x に対してその問題が成り立つならば，x 以降の数字に対しても成り立つような性質を指す．
実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 isOk(...) を用意する． D問題だとある値 x と K が与えられた時に，積が x 以下となるペアの個数が K 以上の場合は真のようになる．
次に，二分探索の対象を用意する．このとき，始点は isOk が偽となり，かつ終点は真となるような範囲を用意する． 今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので 0 ~ 10^18 のようになる．
そして二分探索する． 二分探索では通常範囲を指定するが，この時始点は isOk が偽，終点は真となることを意識する． 通常の二分探索と同じく対象範囲の真ん中の値((始点 + 終点) / 2)をとり，それの真偽を判定する． 真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する． この操作で，常に始点は偽，終点は真となる． 最終的に始点と終点が連続した値になるため，その終点を解として出力する．
要約すると，isOk() を満たす範囲の下界を求める操作だと言える．
Lower Bound / Upper Bound Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた． 計算量もそこまで気にする必要はない． 今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある． そのため，Lower BoundやUpper Boundを用いる必要がある．
Lower Boundは指定した値以上の要素が初めて出現する場所を取得する．
一方，Upper Boundは指定した値より大きい要素が初めて出現する場所を取得する．</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>A~Dまで．コード
A問題 Uで分岐
B問題 入力の文字列の長さの回数&amp;rsquo;x&#39;を出力
C問題 連想配列を使って数字が出現したかを確認
D問題 毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく． あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．
E問題 桁DP
0でない(= 1 ~ 9)の数字がK回出る回数を数える． 桁を上から決定していき数え上げる． 桁の決定の仕方は，その桁を決める前の時点でNより小さいことが確定しているかどうかで変わる．
確定している場合をdp[|N|][K + 1]と表現した時に，桁iでの状態遷移は以下のようになる
   桁i-1での状態 桁iでの状態     確定している 0を選択する: dp[i][k] += dp[i - 1][k]
0以外を選択する: dp[i][k] += dp[i - 1][k - 1] * 9   確定していない 桁iが0の時: Nより小さくすることはできないので何もしない
桁iが0でない時: 1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができるので，桁i-1までに0以外の数字が出現した回数をjとするとdp[i][j + 1] += (桁iの数字 - 1)    桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．
最終的な出力はdp[|N| - 1][K] + ((N自身が条件を満たす)?</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>けもフレチックでした．
A~Eまで
A問題 (H + A - 1) / A するだけ
B問題 必殺技の総和をとって大小比較
C問題 体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃
D問題 等比数列の和
E問題 DP
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC153</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>A~E問題まで．
A問題 if文で分岐するだけ
B問題 辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される． 2数の大きい方の値の回数だけ，小さい方の値を出力する．
C問題 数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．
D問題 与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく． 例えば334は34，398は38という感じ． あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．
E問題 modの逆元を知らないと厳しい問題．参考
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める． LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC152</description>
    </item>
    
  </channel>
</rss>