<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuroes on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuroes on T45K</description>
    <generator>Hugo</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 20 Feb 2022 13:56:21 +0900</lastBuildDate>
    <atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ABC239の解説</title>
      <link>https://t45k.github.io/kyopuro/abc239/</link>
      <pubDate>Sun, 20 Feb 2022 13:56:21 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc239/</guid>
      <description>&lt;p&gt;3 ヶ月ぶりのコンテスト参加。ただし Unrated。&#xA;6 完&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---horizon&#34;&gt;&#xA;  A - Horizon&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---horizon&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---integer-division&#34;&gt;&#xA;  B - Integer Division&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---integer-division&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;X が負かつ 10 で割り切れないときだけ、X/10 に-1 を加える。&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---knight-fork&#34;&gt;&#xA;  C - Knight Fork&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---knight-fork&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;「二つの点から距離 √5 である格子点が存在する」ということは、&#xA;「それぞれの点から距離 √5 である格子点を列挙した時、重なる物が 1 つ以上ある」ということになる。&lt;/p&gt;&#xA;&lt;p&gt;なので、それぞれの点の距離 √5 の格子点の集合に対して、共通集合が存在するかを確認すればよい。&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---prime-sum-game&#34;&gt;&#xA;  D - Prime Sum Game&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---prime-sum-game&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;高橋君が選べる全ての数字に対して、足すことで素数になるような数字を青木君が選べればよい。&lt;/p&gt;&#xA;&lt;p&gt;具体的には、以下のような処理を行う&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A~B の数字を順番に選んでいく。この数字を i とする&lt;/li&gt;&#xA;&lt;li&gt;i に対して、C~D の数字を足していく。この和を j とする&lt;/li&gt;&#xA;&lt;li&gt;j が素数の場合は、1.で選んだ数字の次の数字で 2.以降を試す。逆に、素数となる j が存在しなければ、その時点で高橋君の勝ちが確定する&lt;/li&gt;&#xA;&lt;li&gt;全ての i に対して j が素数となるような数字を青木君が選べた場合、青木君の勝利&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;e---subtree-k-th-max&#34;&gt;&#xA;  E - Subtree K-th Max&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---subtree-k-th-max&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Ki は高々 20 なので、愚直に計算していけば良い。&#xA;具体的には、各頂点に対して部分木に書かれた値の降順リスト（長さ最大 20）を用意し、以下の手順をボトムアップに繰り返す。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC223の解説</title>
      <link>https://t45k.github.io/kyopuro/abc223/</link>
      <pubDate>Sat, 23 Oct 2021 20:31:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc223/</guid>
      <description>&lt;p&gt;ギリギリ 4 完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC223&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---exact-price&#34;&gt;&#xA;  A - Exact Price&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---exact-price&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;100 で割った余りが 0 になればよい．&lt;/p&gt;&#xA;&lt;p&gt;入力例にあるように X=0 である場合に注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---string-shifting&#34;&gt;&#xA;  B - String Shifting&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---string-shifting&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;シフトした文字列を全通り用意しておき，ソートする．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---doukasen&#34;&gt;&#xA;  C - Doukasen&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---doukasen&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;両端からシミュレーションするのは難しそうなので他の方法を考える．&lt;/p&gt;&#xA;&lt;p&gt;少し考えると，左端と右端両端から同時に火をつけたそれらがぶつかった時，&#xA;どちらも同じ時間燃えていたことになる．&#xA;つまり，ぶつかる場所は，左端から火をつけて燃え切るのに必要な時間の半分になる．&lt;/p&gt;&#xA;&lt;p&gt;あとは，全て燃える時間を計算して，その半分でどこまで燃えるかを計算すればよい．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---restricted-permutation&#34;&gt;&#xA;  D - Restricted Permutation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---restricted-permutation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;トポロジカルソートを，優先度付きキューを用いた幅優先探索でやるだけ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC222の解説</title>
      <link>https://t45k.github.io/kyopuro/abc222/</link>
      <pubDate>Sat, 23 Oct 2021 18:07:27 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc222/</guid>
      <description>&lt;p&gt;四完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC222&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---four-digits&#34;&gt;&#xA;  A - Four Digits&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---four-digits&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;10 未満には 3 個，100 未満には 2 個，1000 未満には 3 個 0 を付けた文字列を出力する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---failing-grade&#34;&gt;&#xA;  B - Failing Grade&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---failing-grade&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---swiss-system-tournament&#34;&gt;&#xA;  C - Swiss-System Tournament&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---swiss-system-tournament&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文が長すぎて，飛ばして先に D から解いた問題．&#xA;やることは&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;前から二人ペアでじゃんけんをする&lt;/li&gt;&#xA;&lt;li&gt;勝ったらその人の勝ち数を増やす&lt;/li&gt;&#xA;&lt;li&gt;勝ち数でソートする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;を繰り返すだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---between-two-arrays&#34;&gt;&#xA;  D - Between Two Arrays&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---between-two-arrays&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;DP．&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;dp[前から何番目を見てるか][c_iの値]=何通りか&lt;/code&gt;という DP を組むと&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;i=1&lt;/code&gt;の時，&lt;code&gt;a_1 &amp;lt;= j &amp;lt;= b_1&lt;/code&gt;の範囲で 1，それ以外は 0&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;i&amp;gt;1&lt;/code&gt;の時，&lt;code&gt;dp[i-1][a_i]~dp[i-1][j]&lt;/code&gt;までの総和&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;になる．&lt;/p&gt;&#xA;&lt;p&gt;総和の計算には累積和を使う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---red-and-blue-tree&#34;&gt;&#xA;  E - Red and Blue Tree&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---red-and-blue-tree&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;場合分けが漏れていて解き損ねた問題．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC220の解説</title>
      <link>https://t45k.github.io/kyopuro/abc220/</link>
      <pubDate>Wed, 06 Oct 2021 22:54:53 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc220/</guid>
      <description>&lt;p&gt;5 完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC220/&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---find-multiple&#34;&gt;&#xA;  A - Find Multiple&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---find-multiple&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ゴリゴリに計算して答えを出しても良いが，この手の問題は全探索しても間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---base-k&#34;&gt;&#xA;  B - Base K&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---base-k&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;10 進法に直してから計算する&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---long-sequence&#34;&gt;&#xA;  C - Long Sequence&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---long-sequence&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;A1 ～ AN までの 1 ループでの和を事前に計算しておき，X とその和の商と余りから k を求める．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---fg-operation&#34;&gt;&#xA;  D - FG operation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---fg-operation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;DP&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---distance-on-large-perfect-binary-tree&#34;&gt;&#xA;  E - Distance on Large Perfect Binary Tree&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---distance-on-large-perfect-binary-tree&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ある頂点について，ペアの作るための頂点の選び方は以下の 3 通りになる&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;自分の子孫から対となる頂点を選ぶ&lt;/li&gt;&#xA;&lt;li&gt;自分の先祖から対となる頂点を選ぶ&lt;/li&gt;&#xA;&lt;li&gt;自分の先祖を経由して，その先祖の自分側以外の子孫から対となる頂点を選ぶ&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;また，それぞれに関して，自分の深さを X とすると，以下の条件が設けられる&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;自分の深さから N までが D 以上，つまり &lt;code&gt;N-X &amp;gt;= D&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;1 から自分の深さまでが D 以上，つまり &lt;code&gt;X-1 &amp;gt;= D&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;ある先祖の深さが Y の時，Y を経由しても D に収まる，つまり &lt;code&gt;(X-Y)+(N-Y) &amp;gt;= D&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;あとはそれぞれに関して計算すればよい．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC219の解説</title>
      <link>https://t45k.github.io/kyopuro/abc219/</link>
      <pubDate>Wed, 06 Oct 2021 22:26:04 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc219/</guid>
      <description>&lt;p&gt;5 完 600 位で青パフォ．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC219/&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---atcoder-quiz-2&#34;&gt;&#xA;  A - AtCoder Quiz 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---atcoder-quiz-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．誤読して WA を出した&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---maritozzo&#34;&gt;&#xA;  B - Maritozzo&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---maritozzo&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;これもやるだけ．&#xA;S1~S3 を配列に入れて，T の各数字を int 型に変換してからそれぞれの S に map して一つの文字列に結合すると気持ち良く書ける．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s1 = scanner.next();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s2 = scanner.next();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s3 = scanner.next();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] s = {s1, s2, s3};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String t = scanner.next();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String answer = IntStream.range(0, t.length())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .map(i -&amp;gt; t.charAt(i) - &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .mapToObj(i -&amp;gt; s[i])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .collect(Collectors.joining());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;System.out.println(answer);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---neo-lexicographic-ordering&#34;&gt;&#xA;  C - Neo-lexicographic Ordering&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---neo-lexicographic-ordering&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;初めにバブルソートをやろうとして TLE を食らった問題&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC218の解説</title>
      <link>https://t45k.github.io/kyopuro/abc218/</link>
      <pubDate>Mon, 13 Sep 2021 16:37:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc218/</guid>
      <description>&lt;p&gt;初の 6 完で久々に盛れた．&#xA;&lt;a href=&#34;https://github.com/T45K/Kyopuro/tree/master/AtCoder/ABC/ABC218&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---weather-forecast&#34;&gt;&#xA;  A - Weather Forecast&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---weather-forecast&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;String#charAt&lt;/code&gt;使う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---qwerty&#34;&gt;&#xA;  B - qwerty&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---qwerty&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文内では辞書順という言葉を使っているが，単純に&lt;code&gt;(char)(&#39;a&#39; + P_i - 1)&lt;/code&gt;を出力するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---shapes&#34;&gt;&#xA;  c - Shapes&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---shapes&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;アルゴリズムは簡単だが実装が割としんどい問題．&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;#&lt;/code&gt;が存在する座標のリストを取得し，それらを左上詰めしたうえで比較する．&#xA;例えば，入力例 1 の S&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.....&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;..#..&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.###.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.....&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.....&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;は 0-indexed で&lt;code&gt;(1,2), (2,1), (2,2), (2,3)&lt;/code&gt;と表せられる．&#xA;このとき，行の最小値は 1，列の最小値は 1 なので，&#xA;左上詰めするとそれぞれの座標の行，列から 1 ずつ引いて&#xA;&lt;code&gt;(0,1), (1,0), (1,1), (1,2)&lt;/code&gt;と表せられる．&lt;/p&gt;&#xA;&lt;p&gt;これを S に対して 90° ずつ回転させたリストと T を比較する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---rectangles&#34;&gt;&#xA;  D - Rectangles&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---rectangles&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;条件から，求めたいのは，&#xA;&lt;code&gt;あるx_iをx座標に持つ点の集合と，あるx_jをx座標に持つ点の集合の間で，y座標が一致する点の集合から2つ選ぶ時の組み合わせの数&lt;/code&gt;になる．&#xA;これを実現するため，与えられた点を x 座標をキー，y 座標のリストを値に持つ Map に格納する．&#xA;この時，リストは事前にソートしておく．&#xA;あとは x 座標の各組合せに対して，一致する y 座標の数を数えておく．&#xA;ソートしているので尺取法的に数え上げると，この操作はリストの長さに線形で可能なので十分に間に合う．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC217の解説</title>
      <link>https://t45k.github.io/kyopuro/abc217/</link>
      <pubDate>Wed, 08 Sep 2021 18:47:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc217/</guid>
      <description>&lt;p&gt;ぎりぎり5完．&#xA;難しく考えてセグ木で殴りにいくことが多かった．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC217/&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---lexicographic-order&#34;&gt;&#xA;  A - Lexicographic Order&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---lexicographic-order&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Javaは&lt;code&gt;S.compareTo(T)&lt;/code&gt;するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---atcoder-quiz&#34;&gt;&#xA;  B - AtCoder Quiz&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---atcoder-quiz&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;初めに4つのコンテストをSet等で持っておいて，出てきたものを消す．&lt;/p&gt;&#xA;&lt;h2 id=&#34;inverse-of-permutation&#34;&gt;&#xA;  Inverse of Permutation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#inverse-of-permutation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文の解読にちょっと時間がかかった．&#xA;転置する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---cutting-woods&#34;&gt;&#xA;  D - Cutting Woods&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---cutting-woods&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;セグ木で殴った問題その1．&#xA;Javaだと&lt;code&gt;TreeSet&lt;/code&gt;でOK（&lt;code&gt;lower&lt;/code&gt;と&lt;code&gt;ceiling&lt;/code&gt;が使えることを知らなかった）．&#xA;別解を紹介する．&lt;/p&gt;&#xA;&lt;p&gt;まずminを返すセグ木とmaxを返すセグ木を用意する．&#xA;木材を切る度に，2つのセグ木のxiの位置をxiで更新する．&#xA;こうすると，線xiを含む木材の長さは，&lt;code&gt;(出てきた数値のうち，xi以上の最小値)-(xi以下の最大値)&lt;/code&gt;と表すことができ，&#xA;セグ木を使うことで&lt;code&gt;O(log N)&lt;/code&gt;で処理できる．&#xA;木材の長さは&lt;code&gt;10^9&lt;/code&gt;を取りうるので，木材を切る位置で座標圧縮する．&#xA;つまり，ci=1のクエリを先に全て集めて起き，それらのxiの値でリストを作り，&#xA;それをもとにセグ木を構築する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---sorting-queries&#34;&gt;&#xA;  E - Sorting Queries&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---sorting-queries&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;セグ木で殴った問題その2．&lt;/p&gt;&#xA;&lt;p&gt;これも初めに出てくるxを全て集めておきリストに入れる．&#xA;このリストをセグ木に入れる．&#xA;次にクエリを順番にみていき，以下の操作を行う．&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;操作1の時，Aの長さを表す変数&lt;code&gt;length&lt;/code&gt;を更新する．&lt;/li&gt;&#xA;&lt;li&gt;操作3の時，Aのどの部分までがソート済みかを表す変数&lt;code&gt;sortedPoint&lt;/code&gt;に&lt;code&gt;length&lt;/code&gt;を代入する．&lt;/li&gt;&#xA;&lt;li&gt;操作2の時，次に出力する数字が何個目か（&lt;code&gt;count&lt;/code&gt;）によって，操作を変える&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;sortedPoint&lt;/code&gt;以下なら，ソート済みの部分を出力するため，&lt;code&gt;count&lt;/code&gt;から&lt;code&gt;sortedPoint&lt;/code&gt;の範囲で最小値を出力する&#xA;（出力した数字は，次以降の操作で引っかからないように最大値で更新しておく）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;sortedPoint&lt;/code&gt;を超過していれば，リストの&lt;code&gt;count&lt;/code&gt;番目の数字をそのまま出力する．&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>ABC216の解説</title>
      <link>https://t45k.github.io/kyopuro/abc216/</link>
      <pubDate>Sat, 04 Sep 2021 20:29:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc216/</guid>
      <description>&lt;p&gt;カス4完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC216/&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---signed-difficulty&#34;&gt;&#xA;  A - Signed Difficulty&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---signed-difficulty&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&lt;/p&gt;&#xA;&lt;p&gt;doubleやfloatでなく文字列型で入力を受け取ってピリオドで分割したほうが良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---same-name&#34;&gt;&#xA;  B - Same Name&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---same-name&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;姓と名を結合した文字列（間に空白を挟む）をSet等で管理し，最終的にSetの要素数とNを比較すれば良い&#xA;（要素数がNと同じなら同姓同名は存在しない）．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---many-balls&#34;&gt;&#xA;  C - Many Balls&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---many-balls&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;元のNに対して&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Nが奇数なら1引いてから2で割る&lt;/li&gt;&#xA;&lt;li&gt;Nが偶数なら2で割る&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;という操作を行っていき，最後に行った操作を逆順に出力する&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---pair-of-balls&#34;&gt;&#xA;  D - Pair of Balls&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---pair-of-balls&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;考え方としては，筒の先頭を順番に見ていき，重複するボールがあればそれを取り除き，改めてその筒を見る，という操作の繰り返しである．&lt;/p&gt;&#xA;&lt;p&gt;「操作を行う対象の筒リスト」を用意し，1~Nを初めに挿入する．&#xA;次に，リストの先頭から取り出した番号の筒に対して，以下の操作を行っていく&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;筒の先頭の数字が「すでに出現した数字」の集合に含まれている場合，筒の先頭と集合中のその数字を取り除き，「操作を行う対象の筒リスト」に今見ている筒の番号を入れる．&lt;/li&gt;&#xA;&lt;li&gt;筒の先頭の数字が「すでに出現した数字」の集合に含まれていない場合，その数字を集合に入れる．&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;e---amusement-park&#34;&gt;&#xA;  E - Amusement Park&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---amusement-park&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ある楽しさXに対して，&lt;code&gt;Σ(max(Ai-X,0)) = K&lt;/code&gt;となるようなXが存在するときに，各アトラクションを楽しさがXになるまで乗るのが最適．&#xA;なので，そのXを二分探索を用いて探す．&lt;/p&gt;&#xA;&lt;h2 id=&#34;f--max-sum-counting&#34;&gt;&#xA;  F- Max Sum Counting&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#f--max-sum-counting&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Aを昇順に並べたとき，Aiを含む(1,&amp;hellip;,i)の空でない部分集合は必ず最大値がAiになる．&#xA;このことから，ソートした後の各iに対して，(1,&amp;hellip;,i)の空でない部分集合に対してBiの和を求めて，Ai以下のものの個数を足し合わせていけば良い．&#xA;部分集合の和はナップザック問題に帰着し，Aiの最大値は5,000なので，それ以下の範囲で計算すれば良い．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC215の解説</title>
      <link>https://t45k.github.io/kyopuro/abc215/</link>
      <pubDate>Mon, 23 Aug 2021 20:59:23 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc215/</guid>
      <description>&lt;p&gt;Dで沼って緑パフォ4完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC215&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---your-first-judge&#34;&gt;&#xA;  A - Your First Judge&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---your-first-judge&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;文字列判定&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---log2n&#34;&gt;&#xA;  B - log2(N)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---log2n&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;logを使うと誤差で通らなかったりする．&#xA;&lt;code&gt;N&amp;lt;=10^18&lt;/code&gt;からkは高々60程度なので愚直に計算してよい&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---one-more-aab-aba-baa&#34;&gt;&#xA;  C - One More aab aba baa&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---one-more-aab-aba-baa&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;|S|&amp;lt;=8&lt;/code&gt;から全てのパターンを列挙しても4*19^5程度なので，全て列挙してからソートすればよい．&#xA;C++だとpermutationを使えば良いが，Javaだと自分で実装する必要がある．&#xA;再帰を使うと楽．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---coprime-2&#34;&gt;&#xA;  D - Coprime 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---coprime-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;全然解法が思いつかなかった．&#xA;想定解とは別解を紹介する．&lt;/p&gt;&#xA;&lt;p&gt;問題の条件から，求めたい数は，各Aiが約数として持たない素数と，それらの合成数であることが分かる．&#xA;そこであらかじめ2以上M以下の約数を全て列挙した上で，それらの倍数とAiが一致しないかを確認していく．&#xA;素数の倍数を列挙するのはエラトステネスの篩と同じ計算量で行え，それらがAiと一致するかはAをSetで持つことで&lt;code&gt;O(1)&lt;/code&gt;でできる．&lt;/p&gt;&#xA;&lt;p&gt;また，合成数を作る処理だが，合成数の数は高々M個なので計算量は&lt;code&gt;O(M)&lt;/code&gt;以下となる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---chain-contestant&#34;&gt;&#xA;  E - Chain Contestant&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---chain-contestant&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解法は思いついたが時間内に実装できなかった問題．&lt;/p&gt;&#xA;&lt;p&gt;SがAからJまでの10種類しかないことに着目すると，2^10をやっても何となくいけそうな気になってくる．&#xA;以下のようなdpを組む．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dp[文字列のどこを見ているか][今までどの文字を通ってきたか][今どこの文字にいるか]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ここで，&lt;code&gt;今までどの文字を通ってきたか&lt;/code&gt;はbitで表現できる．&#xA;このようなdp[i][j][k]を組むと，更新式は以下の和となる．&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;dp[i-1][j][k]&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;jがi番目の文字を含んでおり，かつk==i．&#xA;これは，i-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに最後に参加したことを表している．&#xA;このとき，そのままi番目の文字のコンテストを受けることができる．&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;jがi番目の文字を含んでおらず，かつk!=i．&#xA;これはi-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに参加したことがなく，&#xA;初めてi番目の文字のコンテストに参加することを表している．&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;+1．これは，i-1番目までのコンテストのいずれにも参加しておらず，i番目のコンテストに初めて参加することを表す．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC214の解説</title>
      <link>https://t45k.github.io/kyopuro/abc214/</link>
      <pubDate>Sun, 15 Aug 2021 13:45:18 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc214/</guid>
      <description>&lt;p&gt;ABCDの四完．久々にD問題解けた．&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC214&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---new-generation-abc&#34;&gt;&#xA;  A - New Generation ABC&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---new-generation-abc&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;if文で分岐する&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---how-many&#34;&gt;&#xA;  B - How many?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---how-many&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;for文で全探索&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---distribution&#34;&gt;&#xA;  C - Distribution&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---distribution&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;意外と難しかったと感じた割には灰diffらしい．&lt;/p&gt;&#xA;&lt;p&gt;まずは簡単のために，時計回りに並んでいない場合を考える．&#xA;i番目のすぬけ君が初めて宝石をもらう時間を&lt;code&gt;time[i]&lt;/code&gt;とすると，&#xA;i(&amp;gt;=2)番目のすぬけ君が初めて宝石をもらうのは&#xA;&lt;code&gt;min(T_i, time[i-1]+S[i-1])&lt;/code&gt;となるので，&#xA;前から順番に計算していけば良い．&lt;/p&gt;&#xA;&lt;p&gt;実際には時計回りに並んでいるため，&#xA;1番目のすぬけ君がN番目のすぬけ君から宝石をもらうのが最速である場合がある．&#xA;これは&lt;code&gt;min(T_0, time[N]+S[N])&lt;/code&gt;となるので，先ほどの式と併せて&#xA;&lt;code&gt;min(T_i%N, time[(i-1)%N + S[(i-1)%N]])&lt;/code&gt;と一般化できる．&#xA;あとはこの式を2周ループすれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---sum-of-maximum-weights&#34;&gt;&#xA;  D - Sum of Maximum Weights&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---sum-of-maximum-weights&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;D問題にしては難しかった問題．&lt;/p&gt;&#xA;&lt;p&gt;まず，以下のことが言える．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;連結でない頂点u,vに対して辺(u,v)を考える時，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;その辺を最短パスに含む頂点の組の個数は&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(uの連結成分の個数)*(vの連結成分の個数)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上から，u，v連結でなく，辺(u,v)が「uの連結成分中の辺」「vの連結成分中の辺」の重みよりも大きい（つまり，辺(u,v)が重みの最大値）場合，&#xA;辺(u,v)を繋ぐことで重みの最大値の合計値は&#xA;&lt;code&gt;(辺(u,v)の重み)*(uの連結成分の個数)*(vの連結成分の個数)&lt;/code&gt;だけ増える．&lt;/p&gt;&#xA;&lt;p&gt;よって，重みの小さい辺から順番に連結していくことで，答えを求めることができる．&#xA;連結成分の個数はUnion Findなどで管理できる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---packing-under-range-regulations&#34;&gt;&#xA;  E - Packing Under Range Regulations&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---packing-under-range-regulations&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解説AC．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC211の解説</title>
      <link>https://t45k.github.io/kyopuro/abc211/</link>
      <pubDate>Mon, 26 Jul 2021 22:41:46 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc211/</guid>
      <description>&lt;p&gt;4完速解き失敗でレートが微減．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC211&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---blood-pressure&#34;&gt;&#xA;  A - Blood Pressure&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---blood-pressure&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;けつあつそくてい．&lt;code&gt;double&lt;/code&gt;で計算する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---cycle-hit&#34;&gt;&#xA;  B - Cycle Hit&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---cycle-hit&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;セットを使うなり事前にソートするなりする．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---chokudai&#34;&gt;&#xA;  C - chokudai&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---chokudai&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;一部で炎上していた問題．簡単なDP&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---number-of-shortest-paths&#34;&gt;&#xA;  D - Number of Shortest paths&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---number-of-shortest-paths&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;基本的にはダイクストラ．&lt;br&gt;&#xA;距離とは別に経路数の情報を持っておき，ある節点に到達したとき，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;その節点での距離の最小値を更新した場合，経路数をその経路の値に置き換える&lt;/li&gt;&#xA;&lt;li&gt;その節点での距離の最小値と同じ距離だった場合，経路数を足し合わせる&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;という操作を行う&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---red-polyomino&#34;&gt;&#xA;  E - Red Polyomino&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---red-polyomino&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解説AC．解きたかった．&#xA;赤に塗った盤面を全て記録しておいても十分メモリに余裕がある．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC210の解説</title>
      <link>https://t45k.github.io/kyopuro/abc210/</link>
      <pubDate>Sun, 18 Jul 2021 14:18:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc210/</guid>
      <description>&lt;p&gt;四完青パフォ。&#xA;今回は D 速解きがそこそこ上手くいった一方で、E に歯が立たなかったので精進したい。&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC210&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---cabbages&#34;&gt;&#xA;  A - Cabbages&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---cabbages&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;A &amp;gt; N&lt;/code&gt;になりうるのがポイント&lt;br&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A が N よりも小さい場合、A 個を X 円で買って、(N-A)個を Y 円で買う&lt;/li&gt;&#xA;&lt;li&gt;A が N 以上の場合、N 個を X 円で買う&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;と場合分けする。&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---bouzu-mekuri&#34;&gt;&#xA;  B - Bouzu Mekuri&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---bouzu-mekuri&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;愚直にシミュレーションする。&#xA;文字列を先頭から見ていき、初めに坊主を引いた方が負け。&lt;br&gt;&#xA;&lt;code&gt;Stream#findFirst&lt;/code&gt;を使うとすっきり書ける。&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---colorful-candies&#34;&gt;&#xA;  C - Colorful Candies&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---colorful-candies&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;範囲内の飴ちゃんの種類を最大にする問題&lt;br&gt;&#xA;範囲をスライドさせていく。&#xA;具体的には、&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;まずは先頭 K 個の飴の色と出現回数を辞書等を使って数えておく。この時の種類数を&lt;code&gt;X&lt;/code&gt;とする。&lt;/li&gt;&#xA;&lt;li&gt;K+1 個目の飴の出現回数を 1 増やし、1 個目の飴を出現回数を 1 減らす。&#xA;この時、K+1 個目の飴が初登場なら&lt;code&gt;X&lt;/code&gt;を 1 増やし、1 個目の飴の出現回数が 0 になったら&lt;code&gt;X&lt;/code&gt;を 1 減らす。&lt;/li&gt;&#xA;&lt;li&gt;上の操作を、範囲をずらしながら繰り返す&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;X&lt;/code&gt;の最大値が答え&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;d---national-railway&#34;&gt;&#xA;  D - National Railway&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---national-railway&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;意外と難しかったらしい。&lt;br&gt;&#xA;まずは簡単のために 1 行しかない場合を考える。&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC209の解説</title>
      <link>https://t45k.github.io/kyopuro/abc209/</link>
      <pubDate>Sat, 10 Jul 2021 23:14:52 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc209/</guid>
      <description>&lt;p&gt;四完速解きで青パフォ．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC209&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---counting&#34;&gt;&#xA;  A - Counting&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---counting&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;基本的には&lt;code&gt;B-A-1&lt;/code&gt;だが，&lt;code&gt;A&amp;gt;B&lt;/code&gt;の時に限り0となる.&#xA;&lt;code&gt;max(B-A-1, 0)&lt;/code&gt;とすれば多少は楽．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---can-you-buy-them-all&#34;&gt;&#xA;  B - Can you buy them all?&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---can-you-buy-them-all&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;偶数番目の商品だけ-1して総和を計算するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---not-equal&#34;&gt;&#xA;  C - Not Equal&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---not-equal&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まず，整数列を昇順にソートしても求めたい値は変わらない．&lt;br&gt;&#xA;1番目の値は全ての値から選ぶことができる．&#xA;2番目の値は1番目に選んだ値以外の値を選ぶので，&lt;code&gt;C2 - 1&lt;/code&gt;通りから選べる．&#xA;このとき，昇順にソートしているので選ぶ値の上限を考える必要がない．&#xA;このように考えると，i番目の値は&lt;code&gt;Ci - (i-1)&lt;/code&gt;から選ぶことができる．&#xA;このとき，&lt;code&gt;(i-1) &amp;gt;= Ci&lt;/code&gt;となると値を選べなくなるので答えは0になる．&lt;br&gt;&#xA;そうでない場合，答えは全ての選べる値を掛け合わせた値になる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---collision&#34;&gt;&#xA;  D - Collision&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---collision&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文から，与えられたグラフが木構造であることが分かる．&lt;br&gt;&#xA;木構造の場合，ある節点(a,b)の距離の偶奇は，頂点を一つ定めたときの&lt;code&gt;(頂点からaまでの距離)-(頂点からbまでの距離)&lt;/code&gt;となる．&lt;br&gt;&#xA;これは，例えば(a,b)の最小共通祖先をc，頂点（適当な節点）をd，二つの節点の距離を&lt;code&gt;dis(x,y)&lt;/code&gt;と表す時，&lt;code&gt;(頂点からaまでの距離)-(頂点からbまでの距離)&lt;/code&gt;の偶奇は&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(dis(d,a) - dis(d,b)) % 2 &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;= (dis(d,c) + dis(c,a) + dis(d,c) + dis(c,b)) % 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;= (dis(d,c) * 2 + dis(c,a) + dis(c,b)) % 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;= (dis(c,a) + dis(c,b)) % 2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;でa，b間の距離の偶奇と一致するからである．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC208の解説</title>
      <link>https://t45k.github.io/kyopuro/abc208/</link>
      <pubDate>Sun, 04 Jul 2021 23:45:41 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc208/</guid>
      <description>&lt;p&gt;5完．初の黄パフォ．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC208&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---rolling-dice&#34;&gt;&#xA;  A - Rolling Dice&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---rolling-dice&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Bの平均値について考えればよい．&#xA;平均が1以上6以下なら達成可能．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---factorial-yen-coin&#34;&gt;&#xA;  B - Factorial Yen Coin&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---factorial-yen-coin&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;大きい硬貨から貪欲に計算していく&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---fair-candy-distribution&#34;&gt;&#xA;  C - Fair Candy Distribution&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---fair-candy-distribution&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;初めに国民番号で国民をソートしておく．&#xA;国民番号の上位&lt;code&gt;K%N&lt;/code&gt;人は余計に1個多くもらえる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---shortest-path-queries-2&#34;&gt;&#xA;  D - Shortest Path Queries 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---shortest-path-queries-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ワーシャルフロイドを応用する．ワーシャルフロイドについては&lt;a href=&#34;../warshallfloyd/&#34; &gt;こちら&lt;/a&gt;を参照．&#xA;ワーシャルフロイドの中継点を&lt;code&gt;k&lt;/code&gt;とすると，&lt;code&gt;Math.min(graph[i][j], graph[i][k] + graph[k][j])&lt;/code&gt;はiスタートjゴールでk以下の箇所を経由した際の最短距離となるので，問題に適当．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---digit-products&#34;&gt;&#xA;  E - Digit Products&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---digit-products&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;たまたま解けた問題．桁DP．&lt;br&gt;&#xA;桁DPとは，ある値&lt;code&gt;N&lt;/code&gt;が与えられたときに各桁に対する遷移を以下のように行うDPを指す．&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一つ前で見ている桁の時点で，数字が&lt;code&gt;N&lt;/code&gt;以下であることが確定している場合，&lt;code&gt;0~9&lt;/code&gt;に遷移する&lt;/li&gt;&#xA;&lt;li&gt;数字が&lt;code&gt;N&lt;/code&gt;以下であることが確定していない場合，&lt;code&gt;0~(今見ている桁の数-1)&lt;/code&gt;への遷移（つまり，状態1に遷移する）と今見てる桁への遷移（状態2）への遷移を行う&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;今回は，各桁の積が&lt;code&gt;K&lt;/code&gt;以下になれば良いのだが，このとき積は十分に疎になるので連想配列などで持てば良い．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC200の解説</title>
      <link>https://t45k.github.io/kyopuro/abc200/</link>
      <pubDate>Sun, 16 May 2021 11:57:55 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc200/</guid>
      <description>&lt;p&gt;祝200回．&#xA;4完．&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---century&#34;&gt;&#xA;  A - Century&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---century&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&#xA;X00年はX世紀であることに注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---200th-abc-200&#34;&gt;&#xA;  B - 200th ABC-200&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---200th-abc-200&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---ringos-favorite-numbers-2&#34;&gt;&#xA;  C - Ringo&amp;rsquo;s Favorite Numbers 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---ringos-favorite-numbers-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Ai-Aj=200ということはAi≡Aj(mod 200)であることなので，&#xA;各Aを，200で割ったあまりでグルーピングして組み合わせを計算すればよい．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---happy-birthday-2&#34;&gt;&#xA;  D - Happy Birthday! 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---happy-birthday-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解説が賢い．&lt;/p&gt;&#xA;&lt;p&gt;先頭8個のAを見ると，2^8-1&amp;gt;200から鳩の巣原理から必ずmod200が被る和の組み合わせが存在する．&#xA;bit全探索するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---patisserie-abc-2&#34;&gt;&#xA;  E - Patisserie ABC 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---patisserie-abc-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;きれいさ，おいしさ，人気度をそれぞれa,b,cとする．&lt;/p&gt;&#xA;&lt;p&gt;a+b+cの小さい順に何通りあるかを確認していく(&lt;code&gt;3 &amp;lt;= sum &amp;lt;= 3*N&lt;/code&gt;)．&#xA;b,cが1以上N以下でないといけないことから，aの範囲は &lt;code&gt;max(1,sum-2n) &amp;lt;= a &amp;lt;= min(n,sum-2)&lt;/code&gt;．&#xA;このとき，bの範囲は &lt;code&gt;max(1,sum-a-n) &amp;lt;= b &amp;lt;= min(n,sum-a-1)&lt;/code&gt;．&#xA;a,bが決まればcは一意に定まる．&#xA;このことから，a+b+cの和がsumの時，&#xA;&lt;code&gt;Σ(a=max(1,sum-2n)~min(n,sum-2))(min(n,sum-a-1)-max(1,sum-a-n)+1)&lt;/code&gt; 通りの選び方がある．&#xA;これをO(1)で求める．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZONeエナジー プログラミングコンテスト “HELLO SPACE” の解説</title>
      <link>https://t45k.github.io/kyopuro/zone2021/</link>
      <pubDate>Sat, 15 May 2021 20:51:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/zone2021/</guid>
      <description>&lt;p&gt;奇跡的に5完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/zone2021&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---ufo襲来&#34;&gt;&#xA;  A - UFO襲来&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---ufo%e8%a5%b2%e6%9d%a5&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---友好の印&#34;&gt;&#xA;  B - 友好の印&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---%e5%8f%8b%e5%a5%bd%e3%81%ae%e5%8d%b0&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;UFOとタワーの頂上を通る直線のy切片を求める．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---mad-team&#34;&gt;&#xA;  C - MAD TEAM&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---mad-team&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;通したけど嘘解法っぽい．&#xA;想定解法は二分探索．&lt;/p&gt;&#xA;&lt;p&gt;3人選ばないといけないのに対してN=3,000から二重ループまでしか回せない．&#xA;各要素が大きい人を選ぶほど良い結果を期待できる．&#xA;つまり，各要素でソートして，上三つだけ残しておく．&#xA;そして，ある二人を選んだ後に各要素のトップを加えてみて総合力を計算すれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---宇宙人からのメッセージ&#34;&gt;&#xA;  D - 宇宙人からのメッセージ&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---%e5%ae%87%e5%ae%99%e4%ba%ba%e3%81%8b%e3%82%89%e3%81%ae%e3%83%a1%e3%83%83%e3%82%bb%e3%83%bc%e3%82%b8&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;両端キューなどに対して文字を突っ込んでいく．&#xA;このときに重複を排除する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---潜入&#34;&gt;&#xA;  E - 潜入&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---%e6%bd%9c%e5%85%a5&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ダイクストラをする．&lt;/p&gt;</description>
    </item>
    <item>
      <title>第二回日本最強プログラマー学生選手権の解説</title>
      <link>https://t45k.github.io/kyopuro/jsc2021/</link>
      <pubDate>Sun, 02 May 2021 17:02:14 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/jsc2021/</guid>
      <description>&lt;p&gt;5完393位でパフォーマンス爆盛りした回。&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/jsc2021&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---competition&#34;&gt;&#xA;  A - Competition&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---competition&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;X,Y,Z&amp;lt;=10^3&lt;/code&gt;から、整数iに対して&lt;code&gt;Y/X &amp;gt; i/Z&lt;/code&gt;を満たす最大の値を探す。&#xA;&lt;code&gt;X=1,Y=1000,Z=1000&lt;/code&gt;の時&lt;code&gt;i=999999&lt;/code&gt;で最大になるので、そこから降順に探す。&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---xor-of-sequences&#34;&gt;&#xA;  B - Xor of Sequences&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---xor-of-sequences&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ。&#xA;Set等で管理する。&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---max-gcd-2&#34;&gt;&#xA;  C - Max GCD 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---max-gcd-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;2からBの間で、AからBの間に2つの倍数を持つ最大の整数を求めれば良い。&#xA;ある整数をiとすると、A以上の最小のiの倍数は&lt;code&gt;(A + i - 1) / i * i&lt;/code&gt;、&#xA;B以下の最大のiの倍数は&lt;code&gt;B/i*i&lt;/code&gt;で求まるので、この二つの値が異なる最大のiを求める。&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---nowhere-p&#34;&gt;&#xA;  D - Nowhere P&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---nowhere-p&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まず&lt;code&gt;A_1&lt;/code&gt;は1からP-1の&lt;code&gt;P-1&lt;/code&gt;通り選べる。&#xA;次に&lt;code&gt;A_2&lt;/code&gt;については1からP-1で、&lt;code&gt;P-A_1&lt;/code&gt;でない&lt;code&gt;P-2&lt;/code&gt;通りが選べる。&#xA;&lt;code&gt;A_3&lt;/code&gt;以降についても、&lt;code&gt;P-sum%P&lt;/code&gt;以外の&lt;code&gt;P-2&lt;/code&gt;通りが選べるので、答えは&lt;code&gt;(P-1)*(P-2)^(N-1)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---level-k-palindrome&#34;&gt;&#xA;  E - Level K Palindrome&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---level-k-palindrome&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;基本的には、回文で対応する文字に対して、一番出現する文字に書き換えていく。&lt;/p&gt;&#xA;&lt;p&gt;まずはレベルを満たす最小の文字列に分解していく。&#xA;基本的には文字列を半分にするのを繰り返していく。&#xA;この時、各折り返し点が異なっている場合は書き換える。&lt;/p&gt;&#xA;&lt;p&gt;次に、それぞれの文字列を同一にしていく。&#xA;これは、各文字列の同じ位置に存在する文字のうち、マジョリティに書き換える。&lt;/p&gt;&#xA;&lt;p&gt;最後に各文字列が回文だった場合、そうならない様に書き換える。&#xA;これは、一つ前のマジョリティに書き換える処理を行う際に2番目に多い文字を記録しておき、&#xA;（中間点以外の）どこか一箇所をそれに書き換えれば良い。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JavaでN個の入力を良い感じにリストにする方法</title>
      <link>https://t45k.github.io/kyopuro/stream/</link>
      <pubDate>Sun, 18 Apr 2021 18:05:46 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/stream/</guid>
      <description>&lt;p&gt;これが多分ベスト&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Stream.generate(scanner::nextInt)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .limit(N)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .collect(Collectors.toList());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配列にしたいときは&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Stream.generate(scanner::nextInt)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .limit(N)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .mapToInt(Integer::intValue)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  .toArray();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>ABC198の解説</title>
      <link>https://t45k.github.io/kyopuro/abc198/</link>
      <pubDate>Sun, 18 Apr 2021 17:47:27 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc198/</guid>
      <description>&lt;p&gt;ABCEの4完。&#xA;その後Dを通した。&#xA;惜しかった。&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC198&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---div&#34;&gt;&#xA;  A - Div&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---div&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;A君1個B君N-1個~A君N-1個B君1個までのN-1通り&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---palindrome-with-leading-zeros&#34;&gt;&#xA;  B - Palindrome with leading zeros&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---palindrome-with-leading-zeros&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;意外と面倒臭い&lt;br&gt;&#xA;後ろの0を全て削ってから回文確認をする&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---compass-walking&#34;&gt;&#xA;  C - Compass Walking&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---compass-walking&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;点(X,Y)までの距離がRの倍数だったらそのまま割る。&#xA;そうでなければ、直前まで直線に向かい、そこから2歩使って到着するのが最善。&lt;br&gt;&#xA;点(X,Y)がR未満の時答えが2になることに注意。&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---send-more-money&#34;&gt;&#xA;  D - Send More Money&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---send-more-money&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;覆面算の条件から、使えるアルファベットは10種類以内になる（逆に、アルファベットが11種類以上の時、鳩の巣原理から数字が被ってしまう）。&#xA;あとは0~9までの順列をアルファベットに対応させて検証すれば良い。&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---unique-color&#34;&gt;&#xA;  E - Unique Color&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---unique-color&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;木を深さ優先探索する。&#xA;今までに出現した色を記録する配列を&lt;code&gt;boolean[10^5+1]&lt;/code&gt;とすると、以下のようなdfsで答えが求まる。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;頂点&lt;code&gt;x&lt;/code&gt;に到達した時、&lt;code&gt;x&lt;/code&gt;の色に対応する配列の値が&lt;code&gt;false&lt;/code&gt;だった場合、&#xA;&lt;code&gt;x&lt;/code&gt;と頂点1からのパスに&lt;code&gt;x&lt;/code&gt;の色が存在しないので、&lt;code&gt;x&lt;/code&gt;はよい頂点になる。&lt;/li&gt;&#xA;&lt;li&gt;逆に配列が&lt;code&gt;true&lt;/code&gt;だった場合、よい頂点ではない。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;x&lt;/code&gt;の色に対応する配列の値を&lt;code&gt;true&lt;/code&gt;にする。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;x&lt;/code&gt;の子に対して再帰的に上の手順を当てる。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;x&lt;/code&gt;から登っていく（再帰関数を抜ける）時、&lt;code&gt;x&lt;/code&gt;がよい頂点だったら、配列の値を&lt;code&gt;false&lt;/code&gt;にしておく。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>ABC196の解説</title>
      <link>https://t45k.github.io/kyopuro/abc196/</link>
      <pubDate>Sat, 20 Mar 2021 23:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc196/</guid>
      <description>&lt;p&gt;惜しくも4完．&#xA;E問題で一ヵ所凡ミスがあって1WAだった．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC196&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---difference-max&#34;&gt;&#xA;  A - Difference Max&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---difference-max&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;x-y&lt;/code&gt;が最大になるのは&lt;code&gt;x&lt;/code&gt;が最大かつ&lt;code&gt;y&lt;/code&gt;が最小の時．&#xA;&lt;code&gt;x&lt;/code&gt;の最大値は&lt;code&gt;b&lt;/code&gt;であり，&lt;code&gt;y&lt;/code&gt;の最小値は&lt;code&gt;c&lt;/code&gt;なので，答えは&lt;code&gt;b-c&lt;/code&gt;．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---round-down&#34;&gt;&#xA;  B - Round Down&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---round-down&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;100桁の小数が与えられるので，Xを数値として読み込むのは厳しい．&#xA;一旦文字列として読み込み，それの整数部を計算する．&#xA;文字列中に&lt;code&gt;.&lt;/code&gt;が存在しないならその文字列をそのまま，&#xA;存在するなら&lt;code&gt;.&lt;/code&gt;で分割し，前半の文字列を出力すれ良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---doubled&#34;&gt;&#xA;  C - Doubled&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---doubled&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;一見難しそうに見えるが，全探索すれば良い．&#xA;12桁の整数全ては調べられないが，条件は&lt;code&gt;前半と後半が等しい&lt;/code&gt;なので，&#xA;下6桁まで(&lt;code&gt;1~999,999&lt;/code&gt;)だけを確認すれば良い．&#xA;&lt;code&gt;1~999,999&lt;/code&gt;までの数値を2回繰り返した整数がNよりも小さいかを判定する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---hanjo&#34;&gt;&#xA;  D - Hanjo&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---hanjo&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;HW &amp;lt;= 16&lt;/code&gt;という条件から，全探索をしてみる．&#xA;1畳の畳の置き方の問題なので，半畳の方は考えなくて良い（余った箇所に詰めれる）．&#xA;部屋を1メートル毎に分割し&lt;code&gt;(i,j)&lt;/code&gt;と表現するとすると，&#xA;各&lt;code&gt;(i,j)&lt;/code&gt;に対して，&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;（置けるけど）畳を置かない&lt;/li&gt;&#xA;&lt;li&gt;畳を縦に置く&lt;/li&gt;&#xA;&lt;li&gt;畳を横に置く&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;の3通りの選び方があるので，再帰関数等を使って，&#xA;深さ優先探索で全てを試せば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---filters&#34;&gt;&#xA;  E - Filters&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---filters&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;N&amp;lt;=2*10^5&lt;/code&gt;，&lt;code&gt;Q&amp;lt;=2*10^5&lt;/code&gt;から全ての&lt;code&gt;xi&lt;/code&gt;に対して各関数を当てると間に合わないので，&#xA;1つの関数を全&lt;code&gt;X&lt;/code&gt;に&lt;code&gt;log(Q)&lt;/code&gt;に当てることを考える．&#xA;そうすると，先に&lt;code&gt;X&lt;/code&gt;をソートしておいて，&#xA;関数を当てる箇所を二分探索で探せば良いことが何となく分かる．&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ti=1&lt;/code&gt;のとき，&lt;code&gt;ai&lt;/code&gt;の値は最後に加算しても問題ない．&#xA;&lt;code&gt;sum&lt;/code&gt;などの変数に加算しておき，最後に計算する．&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ti=2(max)&lt;/code&gt;のとき，&amp;ldquo;ソート済み&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;ai&lt;/code&gt;以下の値が全て&lt;code&gt;ai&lt;/code&gt;になる&amp;quot;と考える．&#xA;二分探索で&lt;code&gt;ai&lt;/code&gt;以下の値の場所を求めて，その場所から左側の値は全て&lt;code&gt;ai&lt;/code&gt;になることを記録しておく．&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ti=3(min)&lt;/code&gt;のときも同様．&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>ARC113の解説</title>
      <link>https://t45k.github.io/kyopuro/arc113/</link>
      <pubDate>Mon, 22 Feb 2021 15:03:58 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/arc113/</guid>
      <description>&lt;p&gt;ABCの3完で緑パフォ．&lt;a href=&#34;https://github.com/T45k/kyopuro/tree/master/AtCoder/ARC/ARC113&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---abc&#34;&gt;&#xA;  A - A&lt;em&gt;B&lt;/em&gt;C&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---abc&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;実は一番時間がかかった問題．&#xA;Aを固定した時に，BとCの組み合わせは&lt;code&gt;O(K)&lt;/code&gt;で求まる&#xA;（BがNの時，Cは&lt;code&gt;1~K/N&lt;/code&gt;の値を取りうるので，組み合わせの個数は&lt;code&gt;K/N&lt;/code&gt;になる）．&#xA;よって，Aを1からKまで動かしつつ，&lt;code&gt;B*C&amp;lt;=K/A&lt;/code&gt;を満たすB*Cの組み合わせを求めることになる．&#xA;Aを動かしてもK/Aが変わらないときは，B，Cの組み合わせの個数も変わらない．&#xA;なので，B，Cの組み合わせの個数をメモしておく．&lt;/p&gt;&#xA;&lt;p&gt;個人的には計算量の見積もりが厳しい．&#xA;入力を考えるのは簡単なので，とりあえず実装してみて一番時間がかかりそうな入力（2*10^5）を突っ込んで時間計ってみるのが良さそう．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---abc&#34;&gt;&#xA;  B - A^B^C&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---abc&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;A^B^Cの1の位は10で割った余りなので，(A%10)^B^Cと答えは同じ．&#xA;次にA%10の累乗の1の位がループする回数を求める．&#xA;例えば，2の場合，2の累乗の1の位は&lt;code&gt;2 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt;  2&lt;/code&gt;と4回毎にループすることが分かる．&#xA;これから，ループする回数をNとすると，B^CをNで割った余りを求めれば良い．&#xA;繰り返し二乗法を使えば&lt;code&gt;O(log(C))&lt;/code&gt;で&lt;code&gt;B^C % N&lt;/code&gt;を求められるので十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---string-invasion&#34;&gt;&#xA;  C - String Invasion&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---string-invasion&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;あるアルファベット&lt;code&gt;α&lt;/code&gt;が二回連続で並んでいるときに，その後ろにあるアルファベットを全て&lt;code&gt;α&lt;/code&gt;に置換できると考えると楽．&#xA;このとき，αの後ろにある全てのアルファベットの内，αではないアルファベットの個数回操作を行える．&#xA;この操作はなるべく後ろからしていくのが最適なので，以下の手順で解けばよい．&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;後ろからアルファベットを見ていく．この時，アルファベットの種類毎の個数を記録する．&lt;/li&gt;&#xA;&lt;li&gt;二回連続しているアルファベット&lt;code&gt;α&lt;/code&gt;があれば，これまで記録してきた&lt;code&gt;α&lt;/code&gt;ではないアルファベットの個数回操作を行える．&lt;/li&gt;&#xA;&lt;li&gt;操作を行うと，今見ている以降の全てのアルファベットが&lt;code&gt;α&lt;/code&gt;になるので，そのように個数を記録し直す．&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>ABC192の解説</title>
      <link>https://t45k.github.io/kyopuro/abc192/</link>
      <pubDate>Sun, 21 Feb 2021 17:56:33 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc192/</guid>
      <description>&lt;p&gt;研究も一段落付いたので競プロに復帰します．&lt;/p&gt;&#xA;&lt;p&gt;今回はABCDの4完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC192&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---star&#34;&gt;&#xA;  A - Star&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---star&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Xは高々10^5なのでごり押しでもできますが，&#xA;100からXを100で割った余りを引くと&lt;code&gt;O(1)&lt;/code&gt;で求まります．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---unreadable-string&#34;&gt;&#xA;  B - uNrEaDaBlE sTrInG&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---unreadable-string&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;for文で回すだけ．&#xA;大文字，小文字判定はJavaだと&lt;code&gt;Character#isUpper(Lower)Case&lt;/code&gt;を使うと一発．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---kaprekar-number&#34;&gt;&#xA;  C - Kaprekar Number&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---kaprekar-number&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;一見難しそうに見えますが，&lt;code&gt;N&amp;lt;=10^9&lt;/code&gt;からNをソート対象の要素は高々9個なので，&#xA;K=10^5から毎回&lt;code&gt;f(x)&lt;/code&gt;を計算しても十分間に合います．&#xA;ということで&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;xをchar型配列に変換する&lt;/li&gt;&#xA;&lt;li&gt;g1がxを降順にソートして得られる値，g2が昇順ソートで得られる値になる&lt;/li&gt;&#xA;&lt;li&gt;x = f(x)&#xA;をK回繰り返せばOK&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;d---base-n&#34;&gt;&#xA;  D - Base n&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---base-n&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;E問題より解いた人が少なかったD問題．&lt;/p&gt;&#xA;&lt;p&gt;まずXが一文字の時，何進数であってもXのn進数表記の値は変わらないため，&#xA;&lt;code&gt;X &amp;lt;= M&lt;/code&gt;なら1，そうでなければ0を出力する．&lt;/p&gt;&#xA;&lt;p&gt;次にXが二文字以上の時は，伝家の宝刀二分探索をする．&#xA;dから10^18+1の範囲から初め，&#xA;XをN進数表記にしたときにMを超過しない最大のNを求める．&#xA;ちなみにXのN進数表記を計算するときは&lt;code&gt;BigInteger&lt;/code&gt;を使うことをオススメします&#xA;（オーバーフローを考慮したうえでlongを使うと1WAになった）．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---train&#34;&gt;&#xA;  E - Train&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---train&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;出発できる時刻を考慮したうえでDijkstraをするだけ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC177の解説</title>
      <link>https://t45k.github.io/kyopuro/abc177/</link>
      <pubDate>Sun, 30 Aug 2020 16:35:35 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc177/</guid>
      <description>&lt;p&gt;5完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC177&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---dont-be-late&#34;&gt;&#xA;  A - Don&amp;rsquo;t be late&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---dont-be-late&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;規定の時間歩き切った際の距離が待ち合わせ場所までの距離以上であれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---substring&#34;&gt;&#xA;  B - Substring&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---substring&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;制約が緩いのでSの0以上&lt;code&gt;|S|-|T|&lt;/code&gt;以下文字を先頭とした部分文字列とTを比較すれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---sum-of-product-of-pairs&#34;&gt;&#xA;  C - Sum of product of pairs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---sum-of-product-of-pairs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;愚直にやると時間に間に合わない．&lt;br&gt;&#xA;答えは&lt;code&gt;A1 * (A2 + A3 + ... An) + A2 * (A3 + ... + An) + ... + Ai * (Ai+1 + ... + An) + ...&lt;/code&gt;なので，&#xA;A2からAnまでの累積和を取ってから掛け算を行えば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---friends&#34;&gt;&#xA;  D - Friends&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---friends&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Union-Findで殴る．&lt;br&gt;&#xA;問題文から，Union-Findを使うと友達グループは簡単に求まる．&#xA;&lt;strong&gt;全ての人について「同じグループの中に友達がいない」という状況&lt;/strong&gt;を達成するためには，&#xA;一番大きい友達グループと同じサイズのグループに分割すれば良い．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC176の解説</title>
      <link>https://t45k.github.io/kyopuro/abc176/</link>
      <pubDate>Mon, 24 Aug 2020 17:05:57 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc176/</guid>
      <description>&lt;p&gt;気持ち良く5完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC176&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---takoyaki&#34;&gt;&#xA;  A - Takoyaki&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---takoyaki&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;日本語をきちんと噛み砕かないと解けない問題．&#xA;答え自体は&lt;code&gt;(X + N - 1) / N * T&lt;/code&gt;するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---multiple-of-9&#34;&gt;&#xA;  B - Multiple of 9&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---multiple-of-9&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;各桁の合計を9で割るだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---step&#34;&gt;&#xA;  C - Step&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---step&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;前から順番に見ていき，今見ている人の身長が前の人以上になるように踏み台を使うのが最適．&lt;br&gt;&#xA;なので，人iが見てきた中で最大の身長より小さければ，その差を足し合わせ，&#xA;それより大きければ身長の最大値を更新すれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---wizard-in-maze&#34;&gt;&#xA;  D - Wizard in Maze&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---wizard-in-maze&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;意外と解ける人が少なかった問題&lt;br&gt;．&#xA;移動をコスト0，ワープをコスト1としてダイクストラすれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---bomber&#34;&gt;&#xA;  E - Bomber&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---bomber&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;これが緑diffなの意外．&lt;br&gt;&#xA;最初に各列，行ごとの爆破対象の個数を数えていく．&#xA;次に，列，行ごとで爆破対象が最大のもののみをフィルターする．&#xA;最後に残った列，行を組み合わせた際に爆破対象が最大となるものを選ぶ．&#xA;この時，選んだ列，行の交差点に爆破対象がない場合合計個数は&lt;code&gt;列の値 + 行の値&lt;/code&gt;，&#xA;そうでない場合は&lt;code&gt;列の値 + 行の値 - 1&lt;/code&gt;になる．&#xA;なので，交差点に爆破対象がないように選びたい．&#xA;爆破対象の数は高々M個なので，交差点がMを超過するとき，必ず爆破対象が存在しない交差点がする．&#xA;逆にM以下の場合は，全ての交差点を確認しても制限時間に間に合う．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC175の解説</title>
      <link>https://t45k.github.io/kyopuro/abc175/</link>
      <pubDate>Sun, 16 Aug 2020 19:58:10 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc175/</guid>
      <description>&lt;p&gt;オンタイム参加せず．&#xA;バチャやると3完だったので参加しなくてよかった&amp;hellip;&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC175&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---rainy-season&#34;&gt;&#xA;  A - Rainy Season&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---rainy-season&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;高々3文字なので全ての場合を列挙した方が良さそう．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---making-triangle&#34;&gt;&#xA;  B - Making Triangle&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---making-triangle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;高々&lt;code&gt;N &amp;lt;= 100&lt;/code&gt;なので3重ループでOK．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---walking-takahashi&#34;&gt;&#xA;  C - Walking Takahashi&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---walking-takahashi&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;個人的に結構難しかった問題．&lt;br&gt;&#xA;Xは最初から絶対値として扱って良い．&#xA;&lt;code&gt;X &amp;gt;= K * D&lt;/code&gt;の場合は&lt;code&gt;X - K * D&lt;/code&gt;が最適となる．&lt;br&gt;&#xA;そうでない場合．まず　&lt;code&gt;K2 = X / D&lt;/code&gt;とすると&lt;code&gt;0 &amp;lt; X - K2 * D &amp;lt; D&lt;/code&gt;を満たすK2が得られる．&#xA;ここからK2の偶奇がKと一致する場合そのKを，一致しない場合はK2+1が答えとなる．&lt;br&gt;&#xA;&lt;code&gt;K * D&lt;/code&gt;が64bitに収まらないに注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---moving-piece&#34;&gt;&#xA;  D - Moving Piece&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---moving-piece&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;場合分けが面倒くさくて実装量が多くなる問題&lt;br&gt;．&#xA;まず初めにマスのグループ分けを行う．&#xA;というのも始める場所によっては行けないマスが存在することもあるからである（例えば&lt;code&gt;2 1 4 3&lt;/code&gt;だと1からスタートすると1 -&amp;gt; 2 -&amp;gt; 1を繰り返す）．&#xA;グループ分けは愚直にシミュレーションしても良いし，UnionFindTreeを用いてもできる．&lt;br&gt;&#xA;分けたグループそれぞれに対して，スコアを計算する．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC174の解説</title>
      <link>https://t45k.github.io/kyopuro/abc174/</link>
      <pubDate>Tue, 04 Aug 2020 13:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc174/</guid>
      <description>&lt;p&gt;5完．&#xA;Fが水diffだったのに解けなくて厳しい．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC174&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---air-conditioner&#34;&gt;&#xA;  A - Air Conditioner&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---air-conditioner&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;条件分岐するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---distance&#34;&gt;&#xA;  B - Distance&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---distance&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;与えられたN個の座標の原点からの距離を計算していくだけ．&lt;br&gt;&#xA;また，こういう時，小数点の計算などは誤差が発生しやすいので，平方根をとる計算はせず，&#xA;全て二乗で計算した方が良い．&#xA;int型だとオーバーフローするので注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---repsept&#34;&gt;&#xA;  C - Repsept&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---repsept&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;証明が難しい問題．&lt;br&gt;&#xA;C問題なので，時間いっぱい（10^7くらい）計算して答えが見つかれば答えを，見つかれなければ-1を出力する方針で解いた．&#xA;計算じたいは，最初に&lt;code&gt;X = 7, i = 1&lt;/code&gt;として，XがKで割れればiを出力し，&#xA;割れなければ&lt;code&gt;X &amp;lt;- (X * 10 + 7) % K, i &amp;lt;- i + 1&lt;/code&gt;と更新すれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---alter-altar&#34;&gt;&#xA;  D - Alter Altar&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---alter-altar&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;なんとなく解けた問題．&lt;br&gt;&#xA;答えは次のいずれかの小さい方&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;玉を赤か白に統一する&lt;/li&gt;&#xA;&lt;li&gt;swapして左側に赤，右側に白を揃える&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;下の方法だと，最左の白玉と最右の赤玉の間にある玉の赤と白の少ない方の個数が答えになる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---logs&#34;&gt;&#xA;  E - Logs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---logs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;なんとなく解けた問題．想定解はにぶたん．&lt;br&gt;&#xA;まず&lt;code&gt;K &amp;lt;= 10^9&lt;/code&gt;という条件を無視すると，丸太iとその切断回数jに対して，&#xA;i/jの天井関数の降順に並べるようにした&#xA;優先度付きキューに丸太を入れて，K回先頭の割る回数を増やすという操作で解ける(以降，操作O)．&#xA;なので，&lt;code&gt;K&lt;/code&gt;を10^5くらいにできれば，この操作で大丈夫である．&#xA;&lt;code&gt;K&lt;/code&gt;を減らす方法として，はじめに丸太iの長さに応じて適切な切断回数を決めておき，&#xA;その切断回数の総和を&lt;code&gt;K&lt;/code&gt;から引いた上で，操作Oに入ればよい．&#xA;初期切断回数として，丸太の長さの総和に対する割合を利用できる．&#xA;つまり，丸太の長さの総和Sに対して，丸太iの長さがLiの時，&#xA;&lt;code&gt;K * (Li / S)&lt;/code&gt;を初期切断回数とすれば良い．&lt;/p&gt;</description>
    </item>
    <item>
      <title>エイシングプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/aising2020/</link>
      <pubDate>Mon, 13 Jul 2020 18:19:23 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/aising2020/</guid>
      <description>&lt;p&gt;4完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/aising2020&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&#xA;実装が重かった印象．&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---number-of-multiples&#34;&gt;&#xA;  A - Number of Multiples&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---number-of-multiples&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;for文で回すだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---an-odd-problem&#34;&gt;&#xA;  B - An Odd Problem&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---an-odd-problem&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;for文で回すだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---xyz-triplets&#34;&gt;&#xA;  C - XYZ Triplets&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---xyz-triplets&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ゴリ押し全探索&lt;br&gt;&#xA;N&amp;lt;=10^4から，x,y,zそれぞれの最大値は10^2になることが分かる．&#xA;なので，x，yを1から10^2まで全探索しても計算量は全体で10^8に抑えられる．&lt;br&gt;&#xA;計算方法だが，xとyが決まればあとはzの二次方程式となるため，解の公式を使えば条件を満たすzが存在するかがO(1)で分かる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---anything-goes-to-zero&#34;&gt;&#xA;  D - Anything Goes to Zero&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---anything-goes-to-zero&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;意外と難しかったらしい問題&lt;br&gt;&#xA;条件から，各Xiを最初に割るのは，popcount(X)±1となる．&#xA;また桁iが0の時，&lt;code&gt;Xi = X + 2^i&lt;/code&gt;，1の時，&lt;code&gt;Xi = X - 2^1&lt;/code&gt;となることから，&#xA;Xの値と各2^iの値を最初に求めておけば，最初の余を求めるところ以降は愚直にやっても間に合う．&#xA;Xの値と各2^iの値は非常に大きくなる可能性があるので，何らかの値で割った余りを利用したい．&#xA;ここで，&lt;code&gt;条件から，各Xiを最初に割るのは，popcount(X)±1となる&lt;/code&gt;ので，popcount(X)±1で割った余りを記録して，&#xA;桁iの値で使い分ければ良い.&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC173の解説</title>
      <link>https://t45k.github.io/kyopuro/abc173/</link>
      <pubDate>Mon, 13 Jul 2020 17:52:00 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc173/</guid>
      <description>&lt;p&gt;4完．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC173&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---payment&#34;&gt;&#xA;  A - Payment&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---payment&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;愚直にforループを回しても良いが，Nが最大10,000なのを踏まえて，&#xA;&lt;code&gt;10,000 - N&lt;/code&gt;をしてお釣りを1000で割った余りを求めると早い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---judge-status-summary&#34;&gt;&#xA;  B - Judge Status Summary&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---judge-status-summary&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;switch文で数え上げるだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---h-and-v&#34;&gt;&#xA;  C - H and V&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---h-and-v&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;典型的なbit全探索の問題．&#xA;縦，横でbit全探索して，該当行を赤く塗った後に盤上の黒いマスの個数を数える．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---chat-in-a-circle&#34;&gt;&#xA;  D - Chat in a Circle&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---chat-in-a-circle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;なぜ解けたかよくわからなかった．&#xA;直感的には，Aiをソートした後に&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A1 A2を列に加える&lt;/li&gt;&#xA;&lt;li&gt;A3，A4を交互に列に加える．A1 A3 A2 A4となる&lt;/li&gt;&#xA;&lt;li&gt;A5，A6，A7，A8を交互に列に加える．A1 A5 A3 A6 A2 A7 A4 A8となる&lt;/li&gt;&#xA;&lt;li&gt;これを繰り返す．&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;みたいな．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC172の解説</title>
      <link>https://t45k.github.io/kyopuro/abc172/</link>
      <pubDate>Wed, 01 Jul 2020 10:38:47 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc172/</guid>
      <description>&lt;p&gt;C，D問題に緑diffが出て結構阿鼻叫喚な人が多かった回．&#xA;4完．&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC172&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---calc&#34;&gt;&#xA;  A - Calc&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---calc&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;計算するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---minor-change&#34;&gt;&#xA;  B - Minor Change&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---minor-change&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文から，SとTの同じ位置で文字が異なる回数を数え上げれば良いことが分かる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---tsundoku&#34;&gt;&#xA;  C - Tsundoku&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---tsundoku&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;貪欲だと解けない問題．&lt;br&gt;&#xA;A，Bどちらの本も上限が10^5なので，全ての組み合わせを見ると時間が足りなくなる．&#xA;ここで，&lt;strong&gt;本は上から見ていく&lt;/strong&gt;というルールから，累積和をとっても問題ないことに気付ける．&#xA;累積和が取れるので，Aは前から見ていき，Bは二分探索できることに気付けるので，あとは実装するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---sum-of-divisors&#34;&gt;&#xA;  D - Sum of Divisors&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---sum-of-divisors&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;最近流行のエラトステネス的問題．&lt;br&gt;&#xA;全ての数字の約数の個数をそれぞれ求めていたら遅いので，前から素数を見て，その素数を約数として持つ値に約数として加えていく方針でやる．&lt;br&gt;&#xA;実装としては，以下のようにする．&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;長さNの配列を2つ用意する．&#xA;配列Aは1で，配列Bはその添字で初期化する．&#xA;配列Aは約数の個数を，配列Bは素数かどうかを判定するのに使う．&lt;/li&gt;&#xA;&lt;li&gt;2 &amp;lt;= i &amp;lt;= √Nとして，配列を順番に見ていく．&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Biが2以上の時，iは素数となる．なので，iの倍数jに対して，jがiでk回割れる(= log(i,j))とすると&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Ak *= k + 1&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Bk /= i ^ k&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;と更新する&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Biが1の時，iは素数なので何もしない&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;配列Aに約数の個数が記録できたので，√N以上の素数に注意しながら欲しい値を計算する．&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>ABC171の解説</title>
      <link>https://t45k.github.io/kyopuro/abc171/</link>
      <pubDate>Tue, 30 Jun 2020 22:33:15 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc171/</guid>
      <description>&lt;p&gt;難易度が暴落した回．&lt;br&gt;&#xA;5完．&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC171&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---αlphabet&#34;&gt;&#xA;  A - αlphabet&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---%ce%b1lphabet&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&#xA;Javaなら&lt;code&gt;Character#isUpperCase&lt;/code&gt;とかが使える．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---mix-juice&#34;&gt;&#xA;  B - Mix Juice&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---mix-juice&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ソートして前からK個選ぶ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---one-quadrillion-and-one-dalmatians&#34;&gt;&#xA;  C - One Quadrillion and One Dalmatians&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---one-quadrillion-and-one-dalmatians&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;与えられた数字を26進数に変換する問題．&lt;br&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Nをデクリメントし&lt;/li&gt;&#xA;&lt;li&gt;Nを26で割ったあまりを求め(これを使う)&lt;/li&gt;&#xA;&lt;li&gt;N /= 26 をする&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;を繰り返す．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---replacing&#34;&gt;&#xA;  D - Replacing&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---replacing&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;C問題よりわかりやすい．&lt;br&gt;&#xA;最初に全ての和Sと，それぞれの数字が何回出てくるかを記録しておく．&#xA;各クエリ毎に以下の操作をすれば良い．&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;与えられたCに対して，SからC*(Cの出現回数)を引く&lt;/li&gt;&#xA;&lt;li&gt;与えられたDに対して，SにD*(Cの出現回数)を加える&lt;/li&gt;&#xA;&lt;li&gt;Dの出現回数にCの出現回数を加える&lt;/li&gt;&#xA;&lt;li&gt;Cの出現回数を0にする&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;e---red-scarf&#34;&gt;&#xA;  E - Red Scarf&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---red-scarf&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まさかの茶diff．Nが偶数という制約があるのを知らんかった&amp;hellip;&lt;br&gt;&#xA;すぬけ君iのスカーフに書かれた整数をbiとすると&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a1 =      b2 ^ b3 ^ ... ^ bn&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a2 = b1 ^      b3 ^ ... ^ bn&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a3 = b1 ^ b2 ^      ... ^ bn&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;であることが分かる．&#xA;また，排他的論理和の性質から&lt;code&gt;x ^ x = 0&lt;/code&gt;なので，以下が成り立つ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC170の解説</title>
      <link>https://t45k.github.io/kyopuro/abc170/</link>
      <pubDate>Sat, 20 Jun 2020 11:52:18 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc170/</guid>
      <description>&lt;p&gt;無念の3完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC170&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---five-variables&#34;&gt;&#xA;  A - &#x9;Five Variables&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---five-variables&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&#xA;Listを作って&lt;code&gt;List#indexOf&lt;/code&gt;で探すと楽．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---crane-and-turtle&#34;&gt;&#xA;  B - Crane and Turtle&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---crane-and-turtle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ツルカメ算．&#xA;ループを回す．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---forbidden-list&#34;&gt;&#xA;  C - Forbidden List&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---forbidden-list&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解答が燃えた問題．&lt;br&gt;&#xA;Xが100以下なので，答えは101以下になる．&#xA;したがって，0から101までの，数列に含まれていない数字に対してXとの差を計算するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---not-divisible&#34;&gt;&#xA;  D - Not Divisible&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---not-divisible&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解けなかった．&lt;br&gt;&#xA;エラトステネスの篩のイメージ．&#xA;数列A中の最大値をAmaxとすると，数列Aを昇順に見て&lt;code&gt;sqrt(Amax)&lt;/code&gt;までの数字の倍数を全て消す作業をする．&#xA;最後に残った数字の中でダブりがないものが答え．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---smart-infants&#34;&gt;&#xA;  E - Smart Infants&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---smart-infants&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;データ構造で殴る問題．&#xA;Javaの標準ライブラリにMultiSetはないので少し考える必要がある．&#xA;今回は各幼稚園の園児のレートをTreeSetで，全ての幼稚園の最小値をセグ木で持つと，転園は以下の操作で行われる．&#xA;また，各園児が現在所属している幼稚園の情報を持つとする．&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Cjの園児が所属している幼稚園(TreeSet)からCjを消す．&lt;/li&gt;&#xA;&lt;li&gt;その幼稚園に関してセグ木の値を更新する．もし幼稚園に園児がいないなら&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;とする．&lt;/li&gt;&#xA;&lt;li&gt;幼稚園DjにCjを加える．&lt;/li&gt;&#xA;&lt;li&gt;幼稚園Djに関してセグ木の値を更新する．&lt;/li&gt;&#xA;&lt;li&gt;セグ木の全ての範囲に対してクエリを投げる．これが平等さになる．&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>東京海上日動プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/tokiomarine2020/</link>
      <pubDate>Sun, 14 Jun 2020 18:55:26 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/tokiomarine2020/</guid>
      <description>&lt;p&gt;3完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/other/tokiomarine2020&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---nickname&#34;&gt;&#xA;  A - Nickname&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---nickname&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;与えられた文字列の先頭3文字を抜き出すだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---tag&#34;&gt;&#xA;  B - Tag&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---tag&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;非鬼が鬼より右側にいる場合，BはAに捕まらいためには右側に逃げるのが最適となる．&#xA;鬼と非鬼がT秒移動した時にいる箇所は，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;鬼: &lt;code&gt;A + V*T&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;非鬼: &lt;code&gt;B + W*T&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;となる．&#xA;鬼の座標が非鬼の座標以上に右側にいる(=より座標が大きい)と捕まるので，それを判定するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---lamps&#34;&gt;&#xA;  C - Lamps&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---lamps&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://imoz.jp/algorithms/imos_method.html&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;いもす法&lt;/a&gt;をすると1回の操作はO(N)で達成できるので，K回やるとO(NK)となる(いもす法のやり方: Aiの値がdの時，座標&lt;code&gt;i-d&lt;/code&gt;に+1，座標&lt;code&gt;i+d+1&lt;/code&gt;に-1を加え，最後に累積和する)．&#xA;O(NK)なので，最大で4*10^10程度の計算量となってしまいそうだが，ここで問題文から以下のことが言える．&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;全ての電球の明るさが&lt;code&gt;N&lt;/code&gt;となった場合，それ以降の操作で明るさは増えないため，そこで操作を打ち切って良い&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;操作回数が最大になるのはN=10^5，K=10^5，全ての電球の明るさの初期値が0の時なので，これを試してみると時間に十分間に合う．&lt;/p&gt;&#xA;&lt;p&gt;あとはやるだけ．&lt;/p&gt;&#xA;&lt;p&gt;解答を見ると，操作回数はO(log N)で抑えられるらしい．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC169の解説</title>
      <link>https://t45k.github.io/kyopuro/abc169/</link>
      <pubDate>Mon, 01 Jun 2020 13:25:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc169/</guid>
      <description>&lt;p&gt;久々のABC水パフォ．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC169&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---multiplication-1&#34;&gt;&#xA;  A - Multiplication 1&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---multiplication-1&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;読み込んで掛け算して出力するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---multiplication-2&#34;&gt;&#xA;  B - Multiplication 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---multiplication-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;与えられた数字の中に0があれば確定で0．&#xA;それ以外の場合，それぞれ掛けて10^18を越えるかを確認すれば良い．&#xA;Javaだと&lt;code&gt;BigInteger&lt;/code&gt;が使える．&#xA;比較は&lt;code&gt;BigInteger#compareTo&lt;/code&gt;で，0より大きければ1が返るっぽい．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---multiplication-3&#34;&gt;&#xA;  C - Multiplication 3&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---multiplication-3&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;罠．&lt;br&gt;&#xA;Javaだと&lt;code&gt;BigDecimal&lt;/code&gt;が使える．&#xA;解説通りにやるとするなら，一旦文字列で読み込んで，小数点を消した上で整数に変換すると良さそう．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---div-game&#34;&gt;&#xA;  D - Div Game&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---div-game&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;まずは素因数分解する．&#xA;問題の条件から素数pに対して，p^1，p^2，p^3，&amp;hellip;，p^kと割っていくのが最適となる．&#xA;したがって，各素数の出現回数からkを求めれば良い．&#xA;p^kまで作るには，出現回数は&lt;code&gt;1+2+3+...k=k(k+1)/2&lt;/code&gt;個必要となる．&#xA;これは，kを1から全部列挙して探せば良い．&#xA;出現回数の最大値は，N&amp;lt;=10^12≒2^40から高々40回程度なので，全列挙しても十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---count-median&#34;&gt;&#xA;  E - Count Median&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---count-median&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;たまたま解けた．&lt;br&gt;&#xA;とても単純化してみる．&lt;/p&gt;&#xA;&lt;h3 id=&#34;nが奇数の時&#34;&gt;&#xA;  Nが奇数の時&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#n%e3%81%8c%e5%a5%87%e6%95%b0%e3%81%ae%e6%99%82&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;N=3で，以下のような時を考える．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;|---|  |---|  |---|&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a   b  c   d  e   f&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この時，明らかに中央値はc~dの整数値になる．&lt;br&gt;&#xA;このことから，何となく中央値は(0-indexedで)前からN/2番目の開始位置と後ろからN/2番目の終了位置の間の整数値であると考えられる．&lt;/p&gt;</description>
    </item>
    <item>
      <title>NOMURA プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/nomura2020/</link>
      <pubDate>Sun, 31 May 2020 15:57:56 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/nomura2020/</guid>
      <description>&lt;p&gt;何とか3完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/nomura2020&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---study-scheduling&#34;&gt;&#xA;  A - Study Scheduling&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---study-scheduling&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;時間を分に直して引き算するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---postdocs&#34;&gt;&#xA;  B - Postdocs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---postdocs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;例えば，&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;P&lt;/code&gt;にした場合，その右側に&lt;code&gt;D&lt;/code&gt;がある時だけ指数が1増えるのに対して，&lt;code&gt;D&lt;/code&gt;にすると確実に指数が1増えることから，全ての&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;D&lt;/code&gt;に変換するのが最適になる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---folia&#34;&gt;&#xA;  C - Folia&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---folia&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;解けてる人多くてびっくりした．&#xA;厳密な証明はeditorial参照．&lt;br&gt;&#xA;初めに木を上から下の方へ見ていって，それぞれの深さでの葉でない頂点(以降，節)の最大値数を求めていく．&#xA;深さiの葉の数がAiの時，深さi-1での節の数がAi/2未満の時，Ai個の葉を生成できないので条件を満たす木は存在しない．&lt;br&gt;&#xA;次に，木を下から上へ見ていき，各深さでの節の数を最適化していく．&#xA;木の頂点数を最大にするためには，各深さiに対して節の数を最大化したい．&#xA;節の数は，深さi+1の頂点数より大きくできない（全ての節は1つ以上の子を持つ），また，初めの操作により，深さiの節の個数から(深さi+1の頂点)個の子を産めることが分かっている．&#xA;したがって，深さiでの節の数の最大値は&lt;code&gt;min(深さiでの節の数，深さi+1での頂点の数)&lt;/code&gt;となる．&#xA;あとはこれを再帰的に計算して足し合わせるだけ．&lt;br&gt;&#xA;この解き方だと，n=0がコーナーケースになることに注意(&lt;code&gt;n=0&lt;/code&gt;, &lt;code&gt;A0=1&lt;/code&gt;の時のみ答えが&lt;code&gt;1&lt;/code&gt;で，それ以外は&lt;code&gt;-1&lt;/code&gt;)&lt;/p&gt;</description>
    </item>
    <item>
      <title>AGC044の解説</title>
      <link>https://t45k.github.io/kyopuro/agc044/</link>
      <pubDate>Wed, 27 May 2020 23:41:26 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/agc044/</guid>
      <description>&lt;p&gt;太陽でしたがNoSubなのでレートは変わらなかったです(NoSubというシステムをよく理解していなかったので，入力するのではないかとドキドキしてました)．&#xA;A，Bの解説．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/AGC/AGC044&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---pay-to-win&#34;&gt;&#xA;  A - Pay to Win&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---pay-to-win&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;400点問題だと高を括って望んだら痛い目にあった．&lt;br&gt;&#xA;簡単に説明するとNから2，3，5で割っていくだけ．&#xA;メモ化(b|d)fs．&#xA;メモは値をキー，コストをバリューとしたMapで持つ．&#xA;bfsで解く場合は，キューから取り出した値Kに対して&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;2で割れるか試す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(a,d*K/2)&lt;/code&gt;（2で割るか，同じ値だけ1を引くかのコストが小さい方）がメモ[K/2]を更新できなければ何もしない．更新できれば，K/2をキューに追加する．&lt;/li&gt;&#xA;&lt;li&gt;破れない場合: K+1とK-1は2で割れるので，割れる場合と同じ処理をする．&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3で割れるか試す&#xA;&lt;ul&gt;&#xA;&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(b,d*2*K/3)&lt;/code&gt;がメモ[K/3]を更新できなければ何もしない．更新できれば，K/3をキューに追加する．&lt;/li&gt;&#xA;&lt;li&gt;破れない場合: K-K%3とK+3-K%3はKで割り切れるので，割れる場合と同じ処理をする&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;5で割れるか試す．略&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;をやるだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---joker&#34;&gt;&#xA;  B - Joker&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---joker&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;計算量の見積もりが難しい問題．&lt;br&gt;&#xA;N&amp;lt;=500に対して，与えられる座標の数はN^2なので，座標が与えられる度に(d|b)fsすると間に合わないように見える．&#xA;しかし，実は間に合う．&#xA;1回の(b|d)fsでいくつかの座標の端からの距離が減る&#xA;では全ての走査で行われる操作は合計でO(n^3)で収まる&#xA;例えばN=6の時，最初の各座標の端からの距離は以下のようになる&lt;br&gt;&#xA;0 0 0 0 0 0&lt;br&gt;&#xA;0 1 1 1 1 0&lt;br&gt;&#xA;0 1 2 2 1 0&lt;br&gt;&#xA;0 1 2 2 1 0&lt;br&gt;&#xA;0 1 1 1 1 0&lt;br&gt;&#xA;0 0 0 0 0 0&lt;br&gt;&#xA;全てを走査しきる（= 各座標の端からの距離が0になる）のは 4*4 + 2*2(四角形を狭めていくイメージ)回の操作が必要となる．&#xA;合計するとだいたい (N^3)/6 らしいので条件下で間に合う．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC168の解説</title>
      <link>https://t45k.github.io/kyopuro/abc168/</link>
      <pubDate>Tue, 19 May 2020 19:54:50 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc168/</guid>
      <description>&lt;p&gt;速解き回だったけど速解き失敗．&#xA;4完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC168&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a----therefore&#34;&gt;&#xA;  A - ∴ (Therefore)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a----therefore&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;文を使う問題．&#xA;コードが長くなりがち．&#xA;Kotlinだと気持ちよく書ける．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;fun main() &lt;span style=&#34;&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Scanner(System.`&lt;span style=&#34;font-weight:bold&#34;&gt;in&lt;/span&gt;`)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .run &lt;span style=&#34;&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;when&lt;/span&gt; (this.nextInt() % 10) &lt;span style=&#34;&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                3 -&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;bon&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                0, 1, 6, 8 -&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;pon&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;font-weight:bold&#34;&gt;else&lt;/span&gt; -&amp;gt; &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#34;hon&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;&#34;&gt;}&lt;/span&gt;.apply(::println)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;b----triple-dots&#34;&gt;&#xA;  B - &amp;hellip; (Triple Dots)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b----triple-dots&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&#xA;Sの長さがKを上回っているとき，&lt;code&gt;S.substring(0, K.length)&lt;/code&gt;．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c----colon&#34;&gt;&#xA;  C - : (Colon)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c----colon&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;数学．&lt;br&gt;&#xA;極座標か余弦定理を使うと簡単に解ける．&#xA;意外と二つの針の間の角度を求めるのが曲者．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d----double-dots&#34;&gt;&#xA;  D - .. (Double Dots)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d----double-dots&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;嫌な気持ちになります．&lt;br&gt;&#xA;問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC167の解説</title>
      <link>https://t45k.github.io/kyopuro/abc167/</link>
      <pubDate>Mon, 11 May 2020 11:43:31 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc167/</guid>
      <description>&lt;p&gt;4完．&#xA;&lt;a href=&#34;https://github.com/t45k/tree/master/AtCoder/ABC/ABC167&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---registration&#34;&gt;&#xA;  A - Registration&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---registration&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;文字列Sと文字列Tの最後の文字を消した文字列が同等か確認する．&#xA;javaだと &lt;code&gt;S.equals(T.substring(0, S.length))&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---easy-linear-programming&#34;&gt;&#xA;  B - Easy Linear Programming&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---easy-linear-programming&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;A,B,Cの順番になるべく多くカードを取ると最大値になるので&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;KがA以下なら1のカードをK枚取って和はK&lt;/li&gt;&#xA;&lt;li&gt;Kが(A+B)以下なら，1のカードをA枚，0のカードを取れるだけ取って和はA&lt;/li&gt;&#xA;&lt;li&gt;それ以外なら1をA枚，0をB枚，-1を(K-(A+B))枚取って和は2A+B+K&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;c---skill-up&#34;&gt;&#xA;  C - Skill Up&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---skill-up&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;bit全探索するだけ問題．&lt;br&gt;&#xA;N&amp;lt;=12なので，全て試しても2^12≒4000通りなので十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---teleporter&#34;&gt;&#xA;  D - Teleporter&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---teleporter&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ABC030_Dとほぼ同じ問題．&lt;br&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;knのとき&#34;&gt;&#xA;  K&amp;lt;=Nのとき&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#kn%e3%81%ae%e3%81%a8%e3%81%8d&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;K回のテレポートを愚直に計算しても間に合う．&lt;/p&gt;&#xA;&lt;h3 id=&#34;knの時&#34;&gt;&#xA;  K&amp;gt;Nの時&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#kn%e3%81%ae%e6%99%82&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;鳩の巣原理的に考えると，必ずどこかでループが発生することになる．&#xA;なので，1ループで訪れる町の数でmodを取る．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---colorful-blocks&#34;&gt;&#xA;  E - Colorful Blocks&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---colorful-blocks&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;時間内に解けなかった．&lt;br&gt;&#xA;全て隣り合わない組み合わせは m*(m-1)^(n-1)になる．&#xA;1組隣り合う場合，その隣り同士は同じ色なので ↑/(m-1)&#xA;↑に組み合わせをかける．一つ右とペアになると考えれば n-1C1 通り&#xA;2組以降も同じように考える．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC166の解説</title>
      <link>https://t45k.github.io/kyopuro/abc166/</link>
      <pubDate>Mon, 04 May 2020 22:58:09 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc166/</guid>
      <description>&lt;p&gt;二日連続ABCの二日目．&#xA;ABCEの4完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC166&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---ac&#34;&gt;&#xA;  A - A?C&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---ac&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;分岐するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---trick-or-treat&#34;&gt;&#xA;  B - Trick or Treat&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---trick-or-treat&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;数え上げるだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---peaks&#34;&gt;&#xA;  C - Peaks&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---peaks&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;結構誤読してた人が多かった問題&lt;br&gt;．&#xA;問題文から，i番目の展望台が地震を含めて繋がっている展望台の中で一番高ければ良いことが分かる．&#xA;つまり，繋がっている展望台のどれか一つでも自身より高いものが良い展望台となる．&#xA;なので，各A,Bに対して大きい方だけ残していくという戦略を取れば，残ったものが良い展望台である．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---i-hate-factorization&#34;&gt;&#xA;  D - I hate Factorization&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---i-hate-factorization&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;&#xA;問題文を誤読しないように．&#xA;&lt;strong&gt;任意の&lt;/strong&gt;Xについて成り立っているのではなく，&lt;strong&gt;テストケースとして与えられる&lt;/strong&gt;Xについて成り立つ．&#xA;およそ200くらいが上限となるらしいので，それについて全探索するだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---this-message-will-self-destruct-in-5s&#34;&gt;&#xA;  E - This Message Will Self-Destruct in 5s&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---this-message-will-self-destruct-in-5s&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;条件は添字i,jに対して&lt;code&gt;i - j = Ai + Aj&lt;/code&gt;であり，これを式変形すると&lt;code&gt;i - Ai = j + Aj&lt;/code&gt;となる．&#xA;つまり，(添字と身長の差)と(添字と身長の和)が同じ値になるペアが条件を満たす．&#xA;なので各Aに対して添字との差と和をあらかじめ計算しておけば解ける&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC165の解説</title>
      <link>https://t45k.github.io/kyopuro/abc165/</link>
      <pubDate>Mon, 04 May 2020 22:58:03 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc165/</guid>
      <description>&lt;p&gt;二日連続ABCの一日目．&#xA;3完．&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC165&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---we-love-golf&#34;&gt;&#xA;  A - We Love Golf&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---we-love-golf&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;きちんと数学して解くこともできるが，制約が小さいので全探索しても間に合う．&#xA;AからBまでの閉区間内にKの倍数があるか確認する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---1&#34;&gt;&#xA;  B - 1%&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---1&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;これもきちんと数学して解けるけど全探索で解ける系．&#xA;入力例から分かるように，10^18が与えられても出力は3760になるので，1~3760までの区間を探索するだけで良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---many-requirements&#34;&gt;&#xA;  C - Many Requirements&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---many-requirements&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;&#xA;これも全探索するだけ問題．&#xA;考えられる数列を全列挙して特典の最大値を探す．&lt;br&gt;&#xA;全列挙に必要な計算量が10^10だと思っていたので試さなかったが，実際にはボールとしきりの要領で組み合わせを考えると計算量は*O(N * C(N+M-1,N))*なので，全列挙しても十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---floor-function&#34;&gt;&#xA;  D - Floor Function&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---floor-function&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;数学．editorialが分かりやすいです．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---rotation-matching&#34;&gt;&#xA;  E - Rotation Matching&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---rotation-matching&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;同じ組み合わせを避けていく問題．&lt;br&gt;&#xA;例えば，組み合わせ(1,N)は(1,2)と同じ組み合わせになる．&#xA;したがって，(組み合わせの方の大きい方)-(小さい方)を&lt;strong&gt;組み合わせの距離&lt;/strong&gt;と定義すると，距離N-iと距離iは同じ組み合わせである．&#xA;これを念頭に入れてN-1からN-mまでの組み合わせを考えていく．&#xA;(1,N)(2,N-1)&amp;hellip;と作っていくと距離N-1,N-3&amp;hellip;と1飛ばしに組み合わせを作れる．&#xA;途中で折り返しをうまく調整して距離N-2,N-4&amp;hellip;の組み合わせを作る．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC164の解説</title>
      <link>https://t45k.github.io/kyopuro/abc164/</link>
      <pubDate>Mon, 27 Apr 2020 23:38:04 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc164/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/atcoder/abc/abc164&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---sheep-and-wolves&#34;&gt;&#xA;  A - Sheep and Wolves&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---sheep-and-wolves&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;if文で分岐するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---battle&#34;&gt;&#xA;  B - Battle&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---battle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;割った余りを求めるのがスマートだけで，先攻後攻の概念があるので愚直に互いに引いていった方が安全．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---gacha&#34;&gt;&#xA;  C - gacha&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---gacha&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;JavaだとSetに打ち込めば良い．&#xA;&lt;code&gt;Stream#distinct&lt;/code&gt;からの&lt;code&gt;Stream#count&lt;/code&gt;で多少スマートに書ける．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---multiple-of-2019&#34;&gt;&#xA;  D - Multiple of 2019&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---multiple-of-2019&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;各桁に対して，i桁目の数字がDiとして&lt;code&gt;Si = (10 ^ i * Di + Si-1) % 2019&lt;/code&gt;を計算すると，Siが同じ値の桁間の数字は2019の倍数になる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---two-currencies&#34;&gt;&#xA;  E - Two Currencies&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---two-currencies&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;むずかしかった．&lt;br&gt;&#xA;(頂点番号, 所持金)を一つの頂点としてダイクストラする．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC163の解説</title>
      <link>https://t45k.github.io/kyopuro/abc163/</link>
      <pubDate>Tue, 21 Apr 2020 16:22:58 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc163/</guid>
      <description>&lt;p&gt;3完．&#xA;unratedで良かった&amp;hellip;&#xA;&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/ABC/ABC163&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---circle-pond&#34;&gt;&#xA;  A - Circle Pond&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---circle-pond&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&lt;br&gt;&#xA;円周は&lt;code&gt;2 * r * 円周率&lt;/code&gt;．&#xA;Javaだと円周率は&lt;code&gt;java.lang.Math.PI&lt;/code&gt;が使える．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---homework&#34;&gt;&#xA;  B - Homework&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---homework&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;全ての宿題をやるには&lt;code&gt;Σ Ai&lt;/code&gt;日かかるので，それを&lt;code&gt;M&lt;/code&gt;と比較する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---management&#34;&gt;&#xA;  C - management&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---management&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;問題文が若干ややこしい．&#xA;やることは特定の数字が何回出てくるかを数えるだけ．&#xA;はじめに配列&lt;code&gt;array[N + 1]&lt;/code&gt;を用意して，各&lt;code&gt;Ai&lt;/code&gt;に対して&lt;code&gt;array[Ai]++&lt;/code&gt;する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---sum-of-large-numbers&#34;&gt;&#xA;  D - Sum of Large Numbers&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---sum-of-large-numbers&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;時間内に解けなかった．&#xA;組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった&amp;hellip;&lt;br&gt;&#xA;各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない．&#xA;あるiに対して&lt;code&gt;front_sum&lt;/code&gt;を0からi-1までの和，&lt;code&gt;back_sum&lt;/code&gt;をn-i+1からnまでの和とすると，&#xA;i個選択する時の組み合わせによって得られる和は&lt;code&gt;i * 10^100 + front_sum&lt;/code&gt;から&lt;code&gt;i * 10^100 + back_sum&lt;/code&gt;までの間に収まる．&#xA;つまり，&lt;code&gt;back_sum - front_sum + 1&lt;/code&gt;通りになる．&#xA;&lt;code&gt;front_sum&lt;/code&gt;と&lt;code&gt;back_sum&lt;/code&gt;は累積和で取れるので，iをKからNまで動かして足し合わせれば良い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---active-infants&#34;&gt;&#xA;  E - Active Infants&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---active-infants&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;原始的なDP（ほんまか？）．&lt;br&gt;&#xA;活発度が高い順に左か右に移動させる．&#xA;活発度を降順にソートした時，&lt;code&gt;dp[i][j]&lt;/code&gt;を，&lt;strong&gt;(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさ&lt;/strong&gt;という風に考える．&#xA;そうすると，&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;strong&gt;左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させる&lt;/strong&gt;か&lt;strong&gt;左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させる&lt;/strong&gt;の嬉しさが大きい方になる．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC162の解説</title>
      <link>https://t45k.github.io/kyopuro/abc162/</link>
      <pubDate>Mon, 13 Apr 2020 16:57:30 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc162/</guid>
      <description>&lt;p&gt;祝参加者1万人越え．無念の4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC162&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---lucky-7&#34;&gt;&#xA;  A - Lucky 7&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---lucky-7&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．文字列で読み込んで&lt;code&gt;String#contains&lt;/code&gt;を使うと早い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---fizzbuzz-sum&#34;&gt;&#xA;  B - FizzBuzz Sum&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---fizzbuzz-sum&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;これもやるだけ．&lt;code&gt;LongStream&lt;/code&gt;できれいに書ける．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LongStream.rangeClosed(1, scanner.nextInt())&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .filter(i -&amp;gt; i % 3 != 0 &amp;amp;&amp;amp; i % 5 != 0)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .sum();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---sum-of-gcd-of-tuples-easy&#34;&gt;&#xA;  C - Sum of gcd of Tuples (Easy)&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---sum-of-gcd-of-tuples-easy&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;三重ループを回すだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---rgb-triplets&#34;&gt;&#xA;  D - RGB Triplets&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---rgb-triplets&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;N &amp;lt;= 4,000&lt;/code&gt;なので二重ループで回すことを考える．&#xA;ある座標以降のそれぞれの色が何個あるかを記録する．&#xA;これは後ろから累積和をとることで可能．&#xA;こうすることで，例えば&lt;code&gt;i&lt;/code&gt;が赤色，&lt;code&gt;j&lt;/code&gt;が緑色のとき，&lt;code&gt;j+1&lt;/code&gt;以降の青色の個数を&lt;code&gt;O(1)&lt;/code&gt;で得られる．&#xA;また，&lt;code&gt;k-j ≠ j-i&lt;/code&gt;の条件を満たすために，k-j = j-iとなるkに対して&lt;code&gt;(j+1以降の数) - (k以降の数) + (k+1以降の数)&lt;/code&gt;と計算すれば良い(累積和の性質から)．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC161の解説</title>
      <link>https://t45k.github.io/kyopuro/abc161/</link>
      <pubDate>Sat, 04 Apr 2020 22:53:03 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc161/</guid>
      <description>&lt;p&gt;100-200-300-400-600の5完．&#xA;人生初のオンサイト600点問題AC．&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC161&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---abc-swap&#34;&gt;&#xA;  A - ABC Swap&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---abc-swap&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Z，X，Yを順に出力するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---popular-vote&#34;&gt;&#xA;  B - Popular Vote&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---popular-vote&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;やるだけ．&lt;br&gt;&#xA;割り算の結果を比較するときは，&lt;code&gt;a &amp;gt; b / c&lt;/code&gt;ではなく&lt;code&gt;a * c &amp;gt; b&lt;/code&gt;のように書いたほうが正確．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---replacing-integer&#34;&gt;&#xA;  C - Replacing Integer&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---replacing-integer&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;方針立てるのに時間かかった問題．&lt;br&gt;&#xA;直感的には分かりづらいけど以下のように言い換えられる(chokudaiさんのツイート)．&lt;/p&gt;&#xA;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C問題、数学の問題といえばそうなんだけど、「無限に長いすごろくがあります。ゴールまでの距離がxです。Kマスずつ進めますが、ゴールを通り過ぎてしまう場合は折り返します。最もゴールに近づく時の残りマス数を答えなさい」みたいにすると、まぁ一応ちゃんとしたストーリーはつくよね。&lt;/p&gt;&amp;mdash; chokudai(高橋 直大)🌸🍆🍡 (@chokudai) &lt;a href=&#34;https://twitter.com/chokudai/status/1246435428476973063?ref_src=twsrc%5Etfw&#34;&gt;April 4, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&#xA;&lt;p&gt;というわけで，&lt;code&gt;N % K&lt;/code&gt;と&lt;code&gt;(N - (N % K)) % K&lt;/code&gt;の小さい方を求める．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---lunlun-number&#34;&gt;&#xA;  D - Lunlun Number&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---lunlun-number&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;想定解が天才すぎる．愚直に解いた．&lt;br&gt;&#xA;i番目の数字に対して，i + 1番目の数字を次のように決める．各桁を下から順番に見ていく．もし見ている桁が9でなく，かつ次の桁の数字より1小さいか同じなら，その桁をインクリメントし，それ以降の桁をルンルン数かつ最小となるように調整(つまり，&amp;lsquo;上の桁 - 1&amp;rsquo;か&#39;0&amp;rsquo;)した値がi + 1番目の数になる．どの桁も条件に当てはまらなければ，一番大きい桁をインクリメントする．&lt;br&gt;&#xA;各桁を確認，操作する場合は，数字をいったんchar型配列にするとやりやすいかも．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC160の解説</title>
      <link>https://t45k.github.io/kyopuro/abc160/</link>
      <pubDate>Sat, 28 Mar 2020 23:27:57 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc160/</guid>
      <description>&lt;p&gt;5完．&lt;a href=&#34;https://github.com/T45K/tree/master/AtCoder/ABC/ABC160&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---coffee&#34;&gt;&#xA;  A - Coffee&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---coffee&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;書かれてることをするだけ．&lt;code&gt;String#charAt&lt;/code&gt;を使う&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---golden-coins&#34;&gt;&#xA;  B - Golden Coins&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---golden-coins&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;なるべく多くの500円に換金した方が良いので，まずは&lt;code&gt;X&lt;/code&gt;を500で割る．&#xA;余りを50で割って，それぞれの商に1000と5を掛けて出力．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---traveling-salesman-around-lake&#34;&gt;&#xA;  C - Traveling Salesman around Lake&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---traveling-salesman-around-lake&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ある家からその一つ手前の家までをぐるっと一周回ってくるのが最適となる．&#xA;1番目の家からN番目の家までに移動距離は&lt;code&gt;Ai - AN&lt;/code&gt;，それ以外の家iから家i - 1までは&lt;code&gt;K - Ai + Ai-1&lt;/code&gt;になるので，その中の最小値が答え．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---line&#34;&gt;&#xA;  D - &#x9;Line++&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---line&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ワーシャルフロイドっぽい問題．&lt;br&gt;&#xA;まず初めにX，Yを経由しない場合の全ての頂点間の距離を求める．&#xA;これはグラフを隣接行列で表すと&lt;code&gt;graph[i][j] = |i - j|&lt;/code&gt;となる．&lt;br&gt;&#xA;次に，XまたはYを経由した場合を考えた上で，全ての頂点間の最短距離を求める．&#xA;これは&lt;code&gt;graph[i][j] = min(graph[i][j], graph[i][X] + graph[X][j])&lt;/code&gt;となる．&lt;br&gt;&#xA;最後に，隣接行列の中で各距離の出現回数を記録し，それを出力する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---red-and-green-apples&#34;&gt;&#xA;  E - Red and Green Apples&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---red-and-green-apples&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;貪欲にやるだけ．&lt;br&gt;&#xA;美味しさを最大化したいとき，赤リンゴを降順に並べたときのX+1つ目以降と緑リンゴを降順に並べたときののY+1つ目以降は捨ててもよい．&#xA;後はそれぞれのリンゴの小さいものを順番に無色のものと入れ替えるだけ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC159の解説</title>
      <link>https://t45k.github.io/kyopuro/abc159/</link>
      <pubDate>Sun, 22 Mar 2020 22:48:22 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc159/</guid>
      <description>&lt;p&gt;奇跡的に5完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC159&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---the-number-of-even-pairs&#34;&gt;&#xA;  A - The Number of Even Pairs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---the-number-of-even-pairs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;和が正になるのは&lt;code&gt;even + even&lt;/code&gt;か&lt;code&gt;odd + odd&lt;/code&gt;の時なので，偶奇それぞれに対して組み合わせ(&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;)を計算して足し合わせる．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---string-palindrome&#34;&gt;&#xA;  B - String Palindrome&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---string-palindrome&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;書かれてることをするだけ．&#xA;回文系の問題は以下のようなメソッドを作っとくと便利かも．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; isPalindrome(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; end, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; ; i++) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (start + i &amp;gt;= end - i) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.charAt(start + i) != s.charAt(end - i)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---maximum-volume&#34;&gt;&#xA;  C - Maximum Volume&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---maximum-volume&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Lの1/3の3乗&lt;/p&gt;</description>
    </item>
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>&lt;script async src=&#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;&#xA;&lt;p&gt;1完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/AGC/AGC043&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---range-flip-find-route&#34;&gt;&#xA;  A - Range Flip Find Route&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---range-flip-find-route&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）．&#xA;なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる．&#xA;ダイクストラ法を使うと計算量は頂点数&lt;code&gt;V&lt;/code&gt;と辺数&lt;code&gt;E&lt;/code&gt;に対して&lt;code&gt;O(V * log(E))&lt;/code&gt;となる．&#xA;今回の頂点数Vは&lt;code&gt;V &amp;lt;= H * W = 10 ^ 4&lt;/code&gt;となる．&#xA;また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---123-triangle&#34;&gt;&#xA;  B - 123 Triangle&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---123-triangle&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)&lt;/p&gt;&#xA;&lt;p&gt;答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する．&#xA;各aは先に1引いといても問題ない．&#xA;偶奇判定なので，&lt;code&gt;abs(a - b)&lt;/code&gt;ではなく&lt;code&gt;a xor b&lt;/code&gt;で良い．&#xA;そうすると，&#xA;&lt;math&gt;&#xA;&lt;msub&gt;&#xA;&lt;mi&gt;x&lt;/mi&gt;&#xA;&lt;mn&gt;n,1&lt;/mn&gt;&#xA;&lt;/msub&gt;&#xA;&lt;mo&gt;=&lt;/mo&gt;&#xA;&lt;mo&gt;(&lt;/mo&gt;&#xA;&lt;mmultiscripts&gt;&#xA;&lt;mo&gt;C&lt;/mo&gt;&#xA;&lt;mn&gt;0&lt;/mn&gt;&#xA;&lt;none /&gt;&#xA;&lt;mprescripts /&gt;&#xA;&lt;mi&gt;n-1&lt;/mi&gt;&#xA;&lt;none /&gt;&#xA;&lt;/mmultiscripts&gt;&#xA;&lt;mo&gt;⁢&lt;/mo&gt;&#xA;&lt;msub&gt;&#xA;&lt;mi&gt;x&lt;/mi&gt;&#xA;&lt;mn&gt;1,1&lt;/mn&gt;&#xA;&lt;/msub&gt;&#xA;&lt;mo&gt;^&lt;/mo&gt;&#xA;&lt;mmultiscripts&gt;&#xA;&lt;mo&gt;C&lt;/mo&gt;&#xA;&lt;mn&gt;1&lt;/mn&gt;&#xA;&lt;none /&gt;&#xA;&lt;mprescripts /&gt;&#xA;&lt;mi&gt;n-1&lt;/mi&gt;&#xA;&lt;none /&gt;&#xA;&lt;/mmultiscripts&gt;&#xA;&lt;mo&gt;⁢&lt;/mo&gt;&#xA;&lt;msub&gt;&#xA;&lt;mi&gt;x&lt;/mi&gt;&#xA;&lt;mn&gt;1,2&lt;/mn&gt;&#xA;&lt;/msub&gt;&#xA;&lt;mo&gt;^&lt;/mo&gt;&#xA;&lt;mo&gt;&amp;hellip;&lt;/mo&gt;&#xA;&lt;mo&gt;^&lt;/mo&gt;&#xA;&lt;mmultiscripts&gt;&#xA;&lt;mo&gt;C&lt;/mo&gt;&#xA;&lt;mi&gt;n-1&lt;/mi&gt;&#xA;&lt;none /&gt;&#xA;&lt;mprescripts /&gt;&#xA;&lt;mi&gt;n-1&lt;/mi&gt;&#xA;&lt;none /&gt;&#xA;&lt;/mmultiscripts&gt;&#xA;&lt;mo&gt;⁢&lt;/mo&gt;&#xA;&lt;msub&gt;&#xA;&lt;mi&gt;x&lt;/mi&gt;&#xA;&lt;mn&gt;1,n&lt;/mn&gt;&#xA;&lt;/msub&gt;&#xA;&lt;mo&gt;)&lt;/mo&gt;&#xA;&lt;mo&gt;%&lt;/mo&gt;&#xA;&lt;mn&gt;2&lt;/mn&gt;&#xA;&lt;/math&gt;&#xA;となる．&#xA;そのため，各組み合わせを計算すれば良い．&lt;br&gt;&#xA;今回は偶奇が欲しいので，各組み合わせの2で割った余りだけで十分である．&#xA;そこで&lt;a href=&#34;https://mathtrain.jp/lucastheorem&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;strong&gt;Lucasの定理&lt;/strong&gt;&lt;/a&gt;を用いる(リンク参照)．&#xA;定理に従うと手順はこう．&lt;/p&gt;</description>
    </item>
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/pana20&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---kth-term&#34;&gt;&#xA;  A - Kth Term&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---kth-term&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;実装するだけ．&#xA;Javaの場合は問題文をコピペして&lt;code&gt;final int[] array = {1, 1, ...};&lt;/code&gt;と宣言すると早い．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---bishop&#34;&gt;&#xA;  B - Bishop&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---bishop&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ここに一番時間を吸われた．&lt;br&gt;&#xA;問題例を見ると最終的に&lt;code&gt;(h * w + 1) / 2&lt;/code&gt;でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---sqrt-inequality&#34;&gt;&#xA;  C - Sqrt Inequality&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---sqrt-inequality&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;ここにも時間を吸われた．&lt;br&gt;&#xA;&lt;code&gt;Math#sqrt&lt;/code&gt;を使うと解けそうな気がするが，精度の都合上間違いになることがある．&#xA;今回は式変換を行うと&lt;code&gt;4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2ca&lt;/code&gt;に持っていけるので，そこに代入するだけ．&#xA;あるいは&lt;code&gt;BigDecimal&lt;/code&gt;を使っても大丈夫らしい．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---string-equivalence&#34;&gt;&#xA;  D - String Equivalence&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---string-equivalence&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;偶然通った問題．&lt;br&gt;&#xA;左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---three-substrings&#34;&gt;&#xA;  E - Three Substrings&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---three-substrings&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;全探索の問題．&lt;a href=&#34;https://www.hamayanhamayan.com/entry/2020/03/15/002311&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ここ&lt;/a&gt;を参考にした．&lt;br&gt;&#xA;Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう．&#xA;以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．&lt;br&gt;&#xA;まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる．&#xA;コードだとこんな感じ．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc061/tasks/abc061_d&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ABC061 D - Score Attack&lt;/a&gt;の別解．&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/ABC061/D/MainAlt.java&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;問題内容&#34;&gt;&#xA;  問題内容&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%95%8f%e9%a1%8c%e5%86%85%e5%ae%b9&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題．&#xA;解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている．&#xA;また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．&lt;/p&gt;&#xA;&lt;h2 id=&#34;別解&#34;&gt;&#xA;  別解&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%88%a5%e8%a7%a3&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;最長路検出と閉路検出について異なる方法を紹介する．&lt;/p&gt;&#xA;&lt;h3 id=&#34;最長路検出&#34;&gt;&#xA;  最長路検出&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%9c%80%e9%95%b7%e8%b7%af%e6%a4%9c%e5%87%ba&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である．&#xA;BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる．&#xA;BFSであることから，n ^ 2 回繰り返せば十分である．&lt;/p&gt;&#xA;&lt;h3 id=&#34;閉路検出&#34;&gt;&#xA;  閉路検出&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e9%96%89%e8%b7%af%e6%a4%9c%e5%87%ba&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない．&#xA;各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていれば&lt;code&gt;inf&lt;/code&gt;を出力すれば良い．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>&lt;p&gt;四完．&lt;a href=&#34;https://github.com/t45k/kyopuro/master/tree/abc158&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---station-and-bus&#34;&gt;&#xA;  A - Station and Bus&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---station-and-bus&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;連想配列にぶちこむ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---count-balls&#34;&gt;&#xA;  B - Count Balls&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---count-balls&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---tax-increase&#34;&gt;&#xA;  C - Tax Increase&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---tax-increase&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;1から20,000くらいまでの整数が条件を満たすか全探索．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---string-formation&#34;&gt;&#xA;  D - String Formation&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---string-formation&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する．&#xA;クエリが&lt;code&gt;1&lt;/code&gt;ならフラグ反転，クエリが&lt;code&gt;2&lt;/code&gt;の場合は，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;正順ならクエリ通りに文字追加&lt;/li&gt;&#xA;&lt;li&gt;逆順ならクエリとは逆に文字追加&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;をやる．&#xA;最終的にフラグを参照してから正しい方向で出力．&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;StringBuilder#insert&lt;/code&gt;を使うとTLEになりました．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>&lt;p&gt;なんとか四完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC157&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---duplex-printing&#34;&gt;&#xA;  A - Duplex Printing&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---duplex-printing&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;n&lt;/code&gt;に1足して2で割るだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---bingo&#34;&gt;&#xA;  B - Bingo&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---bingo&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;実装するだけだが実装量が多くなりがちな問題&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---guess-the-number&#34;&gt;&#xA;  C - Guess The Number&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---guess-the-number&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更．&#xA;桁数を満たす整数を昇順に条件を満たすか確認する．&#xA;余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---friend-suggestions&#34;&gt;&#xA;  D - Friend Suggestions&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---friend-suggestions&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Union-Find Treeで殴る問題．&#xA;友達関係を取得する時にUnion-Find Treeを構築します．&#xA;同時に，それぞれの人が何人友達がいるかを記録します．&lt;br&gt;&#xA;ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します．&#xA;この時，友達候補でない人を記録する必要はありません．&lt;br&gt;&#xA;最終的に，Union-Find Treeから&lt;strong&gt;自分，友達，ブロック関係を含めた自分と繋がっている人&lt;/strong&gt;を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．&lt;br&gt;&#xA;余談ですが，&lt;code&gt;Set&lt;/code&gt;をfor文で回すと異様に遅いので，for文を使う場合は&lt;code&gt;List&lt;/code&gt;を使った方が良いです．&lt;/p&gt;</description>
    </item>
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>&lt;p&gt;最小全域木という概念を知ったのでメモ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;最小全域木とは&#34;&gt;&#xA;  最小全域木とは&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%9c%80%e5%b0%8f%e5%85%a8%e5%9f%9f%e6%9c%a8%e3%81%a8%e3%81%af&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;em&gt;無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanning Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．&lt;/em&gt;（蟻本より）&lt;br&gt;&#xA;つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．&lt;br&gt;&#xA;&lt;a href=&#34;https://atcoder.jp/contests/abc065/tasks/arc076_b&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ABC065-D&lt;/a&gt;がこの問題に該当します．&lt;/p&gt;&#xA;&lt;h2 id=&#34;解き方&#34;&gt;&#xA;  解き方&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e8%a7%a3%e3%81%8d%e6%96%b9&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;有名なアルゴリズムとして，クラスカル法とプリム法があります．&#xA;今回はクラスカル法を紹介します．&lt;br&gt;&#xA;クラスカル法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります．&#xA;ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// edges は Edge(int label1, int label2, long cost) のリスト&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; UnionFindTree unionFindTree = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; UnionFindTree(n); &lt;span style=&#34;font-style:italic&#34;&gt;// 要素数nのUnion-Find Treeを構築&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;&#34;&gt;long&lt;/span&gt; sum = 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Edge edge : edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!unionFindTree.isSame(edge.label1, edge.label2)) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        unionFindTree.unit(edge.label1, edge.label2);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        sum += edge.cost;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;辺のソートに一番計算量を食われます．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>&lt;p&gt;ワーシャルフロイド法というアルゴリズムを知ったのでメモ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;ワーシャルフロイド法とは&#34;&gt;&#xA;  ワーシャルフロイド法とは&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e3%83%af%e3%83%bc%e3%82%b7%e3%83%a3%e3%83%ab%e3%83%95%e3%83%ad%e3%82%a4%e3%83%89%e6%b3%95%e3%81%a8%e3%81%af&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;グラフのある一点から任意の点への最短距離を求めるアルゴリズム．&#xA;計算量は点の個数nに対してO(n^3)．&#xA;似たようなアルゴリズムに&lt;strong&gt;ダイクストラ法&lt;/strong&gt;があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである．&#xA;計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．&lt;/p&gt;&#xA;&lt;h2 id=&#34;実装&#34;&gt;&#xA;  実装&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e5%ae%9f%e8%a3%85&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単．&#xA;二次元配列を用いた例がこちら．&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;void&lt;/span&gt; main(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] args) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[][] graph = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[n][n];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-style:italic&#34;&gt;// 初めに無限大の値で各要素を初期化&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Arrays.fill(graph[i], Integer.MAX_VALUE / 2); &lt;span style=&#34;font-style:italic&#34;&gt;// Integer.MAX_VALUEでないことに注意&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        graph[i][i] = 0;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-style:italic&#34;&gt;// グラフの各辺を与えられた値に変更&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-style:italic&#34;&gt;// ここからワーシャルフロイド&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; k = 0; k &amp;lt; graph.length; k++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 出発する点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; graph.length; j++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 到着する点&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点をとった方が短となるか判定&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三重ループを回すだけである．&#xA;注意点は，グラフの初期化時に&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;を代入しないこと．&#xA;&lt;code&gt;Math.min&lt;/code&gt;のタイミングでオーバーフローするため&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC156&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;解答&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---beginner&#34;&gt;&#xA;  A - Beginner&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---beginner&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;算数&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---digits&#34;&gt;&#xA;  B - Digits&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---digits&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;nが0になるまでkで割り続ける&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---rally&#34;&gt;&#xA;  C - Rally&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---rally&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---bouquet&#34;&gt;&#xA;  D - Bouquet&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---bouquet&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;組み合わせの問題．&lt;br&gt;&#xA;組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く．&#xA;組み合わせの総和は2^n - 1になる．&#xA;a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/util/Utility.java#L360-L390&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;modInvのJava実装の例&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>&lt;p&gt;無念の三冠．&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---poor&#34;&gt;&#xA;  A - Poor&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---poor&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;重複を調べる問題．&lt;br&gt;&#xA;愚直に比較しても良いけど，Setを使うのが早そう．&lt;br&gt;&#xA;JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---papers-please&#34;&gt;&#xA;  B - Papers, Please&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---papers-please&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;fizzbuzzみたいな問題．&lt;br&gt;&#xA;これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---poll&#34;&gt;&#xA;  C - Poll&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---poll&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;連想配列を使って数え上げる典型的な問題．&lt;br&gt;&#xA;StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくは&lt;code&gt;Collections#sort&lt;/code&gt;)．&#xA;C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---pairs&#34;&gt;&#xA;  D - Pairs&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---pairs&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;E問題より難しいD問題．&#xA;以下の要素が重なりあってきつい．&lt;/p&gt;&#xA;&lt;h3 id=&#34;決め打ち二分探索&#34;&gt;&#xA;  決め打ち二分探索&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#%e6%b1%ba%e3%82%81%e6%89%93%e3%81%a1%e4%ba%8c%e5%88%86%e6%8e%a2%e7%b4%a2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h3&gt;&#xA;&lt;p&gt;決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す．&#xA;単調性とは，ある数 &lt;code&gt;x&lt;/code&gt; に対してその問題が成り立つならば，&lt;code&gt;x&lt;/code&gt; 以降の数字に対しても成り立つような性質を指す．&lt;br&gt;&#xA;　実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 &lt;code&gt;isOk(...)&lt;/code&gt; を用意する．&#xA;D問題だと&lt;strong&gt;ある値 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;K&lt;/code&gt; が与えられた時に，積が &lt;code&gt;x&lt;/code&gt; 以下となるペアの個数が &lt;code&gt;K&lt;/code&gt; 以上の場合は真&lt;/strong&gt;のようになる．&lt;br&gt;&#xA;　次に，二分探索の対象を用意する．このとき，始点は &lt;code&gt;isOk&lt;/code&gt; が偽となり，かつ終点は真となるような範囲を用意する．&#xA;今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので &lt;code&gt;0 ~ 10^18&lt;/code&gt; のようになる．&lt;br&gt;&#xA;　そして二分探索する．&#xA;二分探索では通常範囲を指定するが，この時始点は &lt;code&gt;isOk&lt;/code&gt; が偽，終点は真となることを意識する．&#xA;通常の二分探索と同じく対象範囲の真ん中の値(&lt;code&gt;(始点 + 終点) / 2&lt;/code&gt;)をとり，それの真偽を判定する．&#xA;真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する．&#xA;この操作で，常に始点は偽，終点は真となる．&#xA;最終的に始点と終点が連続した値になるため，その終点を解として出力する．&lt;br&gt;&#xA;　要約すると，&lt;code&gt;isOk()&lt;/code&gt; を満たす範囲の下界を求める操作だと言える．&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>&lt;p&gt;A~Dまで．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/abc154&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---remaining-balls&#34;&gt;&#xA;  A - Remaining Balls&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---remaining-balls&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;Uで分岐&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---i-miss-you&#34;&gt;&#xA;  B - I miss you&amp;hellip;&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---i-miss-you&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;入力の文字列の長さの回数&amp;rsquo;x&amp;rsquo;を出力&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---distinct-or-not&#34;&gt;&#xA;  C - Distinct or Not&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---distinct-or-not&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;連想配列を使って数字が出現したかを確認&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---dice-in-line&#34;&gt;&#xA;  D - Dice in Line&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---dice-in-line&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく．&#xA;あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---almost-everywhere-zero&#34;&gt;&#xA;  E - Almost Everywhere Zero&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---almost-everywhere-zero&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;桁DP&lt;br&gt;&#xA;0でない(= 1 ~ 9)の数字がK回出る回数を数える．&#xA;桁を上から決定していき数え上げる．&#xA;桁の決定の仕方は，&lt;strong&gt;その桁を決める前の時点でNより小さいことが確定しているかどうか&lt;/strong&gt;で変わる．&lt;br&gt;&#xA;確定している場合を&lt;code&gt;dp[|N|][K + 1]&lt;/code&gt;と表現した時に，桁iでの状態遷移は以下のようになる&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;桁i-1での状態&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;桁iでの状態&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;確定している&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;0を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k]&lt;/code&gt;&lt;br&gt;0以外を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k - 1] * 9&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;確定していない&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;桁iが0の時: Nより小さくすることはできないので何もしない&lt;br&gt;桁iが0でない時: &lt;strong&gt;1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができる&lt;/strong&gt;ので，桁i-1までに0以外の数字が出現した回数をjとすると&lt;code&gt;dp[i][j + 1] += (桁iの数字 - 1)&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．&lt;br&gt;&#xA;最終的な出力は&lt;code&gt;dp[|N| - 1][K] + ((N自身が条件を満たす)? 1 : 0)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>&lt;p&gt;けもフレチックでした．&lt;/p&gt;&#xA;&lt;p&gt;A~Eまで&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---serval-vs-monster&#34;&gt;&#xA;  A - Serval vs Monster&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---serval-vs-monster&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;(H + A - 1) / A するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---common-raccoon-vs-monster&#34;&gt;&#xA;  B - Common Raccoon vs Monster&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---common-raccoon-vs-monster&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;必殺技の総和をとって大小比較&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---fennec-vs-monster&#34;&gt;&#xA;  C - Fennec vs Monster&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---fennec-vs-monster&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---caracal-vs-monster&#34;&gt;&#xA;  D - Caracal vs Monster&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---caracal-vs-monster&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;等比数列の和&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---crested-ibis-vs-monster&#34;&gt;&#xA;  E - Crested Ibis vs Monster&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---crested-ibis-vs-monster&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;DP&lt;/p&gt;&#xA;&lt;p&gt;ソースコード&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>&lt;p&gt;A~E問題まで．&lt;/p&gt;&#xA;&lt;h2 id=&#34;a---ac-or-wa&#34;&gt;&#xA;  A - AC or WA&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#a---ac-or-wa&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;if文で分岐するだけ&lt;/p&gt;&#xA;&lt;h2 id=&#34;b---comparing-strings&#34;&gt;&#xA;  B - Comparing Strings&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#b---comparing-strings&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される．&#xA;2数の大きい方の値の回数だけ，小さい方の値を出力する．&lt;/p&gt;&#xA;&lt;h2 id=&#34;c---low-elements&#34;&gt;&#xA;  C - Low Elements&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#c---low-elements&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．&lt;/p&gt;&#xA;&lt;h2 id=&#34;d---handstand-2&#34;&gt;&#xA;  D - Handstand 2&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#d---handstand-2&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく．&#xA;例えば334は34，398は38という感じ．&#xA;あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．&lt;/p&gt;&#xA;&lt;h2 id=&#34;e---flatten&#34;&gt;&#xA;  E - Flatten&#xA;  &lt;a class=&#34;heading-link&#34; href=&#34;#e---flatten&#34;&gt;&#xA;    &lt;i class=&#34;fa-solid fa-link&#34; aria-hidden=&#34;true&#34; title=&#34;見出しへのリンク&#34;&gt;&lt;/i&gt;&#xA;    &lt;span class=&#34;sr-only&#34;&gt;見出しへのリンク&lt;/span&gt;&#xA;  &lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;modの逆元を知らないと厳しい問題．&lt;a href=&#34;https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-1-mod-p-%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%89%B2%E3%82%8A%E7%AE%97%E3%81%A8%E3%81%AF&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;参考&lt;/a&gt;&lt;br&gt;&#xA;この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める．&#xA;LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．&lt;/p&gt;&#xA;&lt;p&gt;ソースコード&lt;br&gt;&#xA;&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&#34;  class=&#34;external-link&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://t45k.github.io/kyopuro/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://t45k.github.io/kyopuro/doc/</guid>
      <description>&lt;!DOCTYPE HTML&gt;&#xA;&lt;!-- NewPage --&gt;&#xA;&lt;html lang=&#34;ja&#34;&gt;&#xA;&lt;head&gt;&#xA;&lt;!-- Generated by javadoc (11.0.11) on Sun Nov 07 23:56:29 JST 2021 --&gt;&#xA;&lt;title&gt;生成されたドキュメント(タイトルなし)&lt;/title&gt;&#xA;&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt;&#xA;&lt;script type=&#34;text/javascript&#34;&gt;window.location.replace(&#39;library/package-summary.html&#39;)&lt;/script&gt;&#xA;&lt;noscript&gt;&#xA;&lt;meta http-equiv=&#34;Refresh&#34; content=&#34;0;library/package-summary.html&#34;&gt;&#xA;&lt;/noscript&gt;&#xA;&lt;link rel=&#34;canonical&#34; href=&#34;library/package-summary.html&#34;&gt;&#xA;&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;stylesheet.css&#34; title=&#34;Style&#34;&gt;&#xA;&lt;/head&gt;&#xA;&lt;body&gt;&#xA;&lt;main role=&#34;main&#34;&gt;&#xA;&lt;noscript&gt;&#xA;&lt;p&gt;ブラウザのJavaScriptが無効になっています。&lt;/p&gt;&#xA;&lt;/noscript&gt;&#xA;&lt;p&gt;&lt;a href=&#34;library/package-summary.html&#34;&gt;library/package-summary.html&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/main&gt;&#xA;&lt;/body&gt;&#xA;&lt;/html&gt;</description>
    </item>
  </channel>
</rss>
