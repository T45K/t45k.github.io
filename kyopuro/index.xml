<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kyopuros on T45K</title>
    <link>https://t45k.github.io/kyopuro/</link>
    <description>Recent content in Kyopuros on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 21 Mar 2020 23:37:35 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/kyopuro/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>1完．コード
A - Range Flip Find Route 全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;
右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）． なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる． ダイクストラ法を使うと計算量は頂点数Vと辺数Eに対してO(V * log(E))となる． 今回の頂点数VはV &amp;lt;= H * W = 10 ^ 4となる． また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．
B - 123 Triangle 誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)
答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する． 各aは先に1引いといても問題ない． 偶奇判定なので，abs(a - b)ではなくa xor bで良い． そうすると，   x n,1  = (  C 0 n-1  ⁢  x 1,1  ^  C 1 n-1  ⁢  x 1,2  ^ &amp;hellip; ^  C n-1 n-1  ⁢  x 1,n  ) % 2  となる． そのため，各組み合わせを計算すれば良い．</description>
    </item>
    
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>4完．コード
A - Kth Term 実装するだけ． Javaの場合は問題文をコピペしてfinal int[] array = {1, 1, ...};と宣言すると早い．
B - Bishop ここに一番時間を吸われた．
問題例を見ると最終的に(h * w + 1) / 2でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．
C - Sqrt Inequality ここにも時間を吸われた．
Math#sqrtを使うと解けそうな気がするが，精度の都合上間違いになることがある． 今回は式変換を行うと4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2caに持っていけるので，そこに代入するだけ． あるいはBigDecimalを使っても大丈夫らしい．
D - String Equivalence 偶然通った問題．
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．
E - Three Substrings 全探索の問題．ここを参考にした．
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう． 以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる． コードだとこんな感じ．
private static boolean[] init(final int length, final String a, final String b) {// 配列の初期化  final boolean[] array = new boolean[length]; // lengthは十分大きい値  Arrays.</description>
    </item>
    
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>ABC061 D - Score Attackの別解．コード
問題内容 正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題． 解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている． また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．
別解 最長路検出と閉路検出について異なる方法を紹介する．
最長路検出 今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である． BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる． BFSであることから，n ^ 2 回繰り返せば十分である．
閉路検出 解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない． 各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていればinfを出力すれば良い．</description>
    </item>
    
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>四完．コード
A - Station and Bus 連想配列にぶちこむ．
B - Count Balls n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．
C - Tax Increase 1から20,000くらいまでの整数が条件を満たすか全探索．
D - String Formation 現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する． クエリが1ならフラグ反転，クエリが2の場合は，
 正順ならクエリ通りに文字追加 逆順ならクエリとは逆に文字追加  をやる． 最終的にフラグを参照してから正しい方向で出力．
StringBuilder#insertを使うとTLEになりました．</description>
    </item>
    
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>なんとか四完．コード
A - Duplex Printing nに1足して2で割るだけ
B - Bingo 実装するだけだが実装量が多くなりがちな問題
C - Guess The Number 条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更． 桁数を満たす整数を昇順に条件を満たすか確認する． 余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．
D - Friend Suggestions Union-Find Treeで殴る問題． 友達関係を取得する時にUnion-Find Treeを構築します． 同時に，それぞれの人が何人友達がいるかを記録します．
ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します． この時，友達候補でない人を記録する必要はありません．
最終的に，Union-Find Treeから自分，友達，ブロック関係を含めた自分と繋がっている人を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．
余談ですが，Setをfor文で回すと異様に遅いので，for文を使う場合はListを使った方が良いです．</description>
    </item>
    
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>最小全域木という概念を知ったのでメモ．
最小全域木とは 無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanningu Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．（蟻本より）
つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．
ABC065-Dがこの問題に該当します．
解き方 有名なアルゴリズムとして，クラスカル法とプリム法があります． 今回はプリム法を紹介します．
プリム法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります． ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．
// edges は Edge(int label1, int label2, long cost) のリスト edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost)); final UnionFindTree unionFindTree = new UnionFindTree(n); // 要素数nのUnion-Find Treeを構築 long sum = 0; for (final Edge edge : edges) { if (!unionFindTree.isSame(edge.label1, edge.label2)) { unionFindTree.unit(edge.label1, edge.label2); sum += edge.cost; } } 辺のソートに一番計算量を食われます．</description>
    </item>
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>ワーシャルフロイド法というアルゴリズムを知ったのでメモ．
ワーシャルフロイド法とは グラフのある一点から任意の点への最短距離を求めるアルゴリズム． 計算量は点の個数nに対してO(n^3)． 似たようなアルゴリズムにダイクストラ法があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである． 計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．
実装 このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単． 二次元配列を用いた例がこちら．
public static void main(final String[] args) { final int[][] graph = new int[n][n]; // 初めに無限大の値で各要素を初期化  for (int i = 0; i &amp;lt; graph.length; i++) { Arrays.fill(graph[i], Integer.MAX_VALUE / 2); // Integer.MAX_VALUEでないことに注意  graph[i][i] = 0; } // グラフの各辺を与えられた値に変更  // ここからワーシャルフロイド  for (int k = 0; k &amp;lt; graph.length; k++) { // 中継する点  for (int i = 0; i &amp;lt; graph.</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>4完．解答
A - Beginner 算数
B - Digits nが0になるまでkで割り続ける
C - Rally 座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．
D - Bouquet 組み合わせの問題．
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く． 組み合わせの総和は2^n - 1になる． a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．
modInvのJava実装の例</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>無念の三冠．
A - Poor 重複を調べる問題．
愚直に比較しても良いけど，Setを使うのが早そう．
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．
B - Papers, Please fizzbuzzみたいな問題．
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．
C - Poll 連想配列を使って数え上げる典型的な問題．
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくはCollections#sort)． C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．
D - Pairs E問題より難しいD問題． 以下の要素が重なりあってきつい．
決め打ち二分探索 決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す． 単調性とは，ある数 x に対してその問題が成り立つならば，x 以降の数字に対しても成り立つような性質を指す．
実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 isOk(...) を用意する． D問題だとある値 x と K が与えられた時に，積が x 以下となるペアの個数が K 以上の場合は真のようになる．
次に，二分探索の対象を用意する．このとき，始点は isOk が偽となり，かつ終点は真となるような範囲を用意する． 今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので 0 ~ 10^18 のようになる．
そして二分探索する． 二分探索では通常範囲を指定するが，この時始点は isOk が偽，終点は真となることを意識する． 通常の二分探索と同じく対象範囲の真ん中の値((始点 + 終点) / 2)をとり，それの真偽を判定する． 真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する． この操作で，常に始点は偽，終点は真となる． 最終的に始点と終点が連続した値になるため，その終点を解として出力する．
要約すると，isOk() を満たす範囲の下界を求める操作だと言える．
Lower Bound / Upper Bound Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた． 計算量もそこまで気にする必要はない． 今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある． そのため，Lower BoundやUpper Boundを用いる必要がある．</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>A~Dまで．コード
A - Remaining Balls Uで分岐
B - I miss you&amp;hellip; 入力の文字列の長さの回数&amp;rsquo;x&#39;を出力
C - Distinct or Not 連想配列を使って数字が出現したかを確認
D - Dice in Line 毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく． あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．
E - Almost Everywhere Zero 桁DP
0でない(= 1 ~ 9)の数字がK回出る回数を数える． 桁を上から決定していき数え上げる． 桁の決定の仕方は，その桁を決める前の時点でNより小さいことが確定しているかどうかで変わる．
確定している場合をdp[|N|][K + 1]と表現した時に，桁iでの状態遷移は以下のようになる
   桁i-1での状態 桁iでの状態     確定している 0を選択する: dp[i][k] += dp[i - 1][k]
0以外を選択する: dp[i][k] += dp[i - 1][k - 1] * 9   確定していない 桁iが0の時: Nより小さくすることはできないので何もしない</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>けもフレチックでした．
A~Eまで
A - Serval vs Monster (H + A - 1) / A するだけ
B - Common Raccoon vs Monster 必殺技の総和をとって大小比較
C - Fennec vs Monster 体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃
D - Caracal vs Monster 等比数列の和
E - Crested Ibis vs Monster DP
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC153</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>A~E問題まで．
A - AC or WA if文で分岐するだけ
B - Comparing Strings 辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される． 2数の大きい方の値の回数だけ，小さい方の値を出力する．
C - Low Elements 数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．
D - Handstand 2 与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく． 例えば334は34，398は38という感じ． あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．
E - Flatten modの逆元を知らないと厳しい問題．参考
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める． LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．
ソースコード
https://github.com/T45K/kyopuro/tree/master/ABC152</description>
    </item>
    
  </channel>
</rss>