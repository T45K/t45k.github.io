<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>T45K</title>
    <link>https://t45k.github.io/</link>
    <description>Recent content on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Mon, 24 Aug 2020 17:05:57 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ABC176の解説</title>
      <link>https://t45k.github.io/kyopuro/abc176/</link>
      <pubDate>Mon, 24 Aug 2020 17:05:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc176/</guid>
      <description>&lt;p&gt;気持ち良く5完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC176&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---takoyaki&#34;&gt;A - Takoyaki&lt;/h2&gt;
&lt;p&gt;日本語をきちんと噛み砕かないと解けない問題．
答え自体は&lt;code&gt;(X + N - 1) / N * T&lt;/code&gt;するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---multiple-of-9&#34;&gt;B - Multiple of 9&lt;/h2&gt;
&lt;p&gt;各桁の合計を9で割るだけ&lt;/p&gt;
&lt;h2 id=&#34;c---step&#34;&gt;C - Step&lt;/h2&gt;
&lt;p&gt;前から順番に見ていき，今見ている人の身長が前の人以上になるように踏み台を使うのが最適．&lt;br&gt;
なので，人iが見てきた中で最大の身長より小さければ，その差を足し合わせ，
それより大きければ身長の最大値を更新すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---wizard-in-maze&#34;&gt;D - Wizard in Maze&lt;/h2&gt;
&lt;p&gt;意外と解ける人が少なかった問題&lt;br&gt;．
移動をコスト0，ワープをコスト1としてダイクストラすれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---bomber&#34;&gt;E - Bomber&lt;/h2&gt;
&lt;p&gt;これが緑diffなの意外．&lt;br&gt;
最初に各列，行ごとの爆破対象の個数を数えていく．
次に，列，行ごとで爆破対象が最大のもののみをフィルターする．
最後に残った列，行を組み合わせた際に爆破対象が最大となるものを選ぶ．
この時，選んだ列，行の交差点に爆破対象がない場合合計個数は&lt;code&gt;列の値 + 行の値&lt;/code&gt;，
そうでない場合は&lt;code&gt;列の値 + 行の値 - 1&lt;/code&gt;になる．
なので，交差点に爆破対象がないように選びたい．
爆破対象の数は高々M個なので，交差点がMを超過するとき，必ず爆破対象が存在しない交差点がする．
逆にM以下の場合は，全ての交差点を確認しても制限時間に間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC175の解説</title>
      <link>https://t45k.github.io/kyopuro/abc175/</link>
      <pubDate>Sun, 16 Aug 2020 19:58:10 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc175/</guid>
      <description>&lt;p&gt;オンタイム参加せず．
バチャやると3完だったので参加しなくてよかった&amp;hellip;&lt;br&gt;
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC175&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---rainy-season&#34;&gt;A - Rainy Season&lt;/h2&gt;
&lt;p&gt;高々3文字なので全ての場合を列挙した方が良さそう．&lt;/p&gt;
&lt;h2 id=&#34;b---making-triangle&#34;&gt;B - Making Triangle&lt;/h2&gt;
&lt;p&gt;高々&lt;code&gt;N &amp;lt;= 100&lt;/code&gt;なので3重ループでOK．&lt;/p&gt;
&lt;h2 id=&#34;c---walking-takahashi&#34;&gt;C - Walking Takahashi&lt;/h2&gt;
&lt;p&gt;個人的に結構難しかった問題．&lt;br&gt;
Xは最初から絶対値として扱って良い．
&lt;code&gt;X &amp;gt;= K * D&lt;/code&gt;の場合は&lt;code&gt;X - K * D&lt;/code&gt;が最適となる．&lt;br&gt;
そうでない場合．まず　&lt;code&gt;K2 = X / D&lt;/code&gt;とすると&lt;code&gt;0 &amp;lt; X - K2 * D &amp;lt; D&lt;/code&gt;を満たすK2が得られる．
ここからK2の偶奇がKと一致する場合そのKを，一致しない場合はK2+1が答えとなる．&lt;br&gt;
&lt;code&gt;K * D&lt;/code&gt;が64bitに収まらないに注意．&lt;/p&gt;
&lt;h2 id=&#34;d---moving-piece&#34;&gt;D - Moving Piece&lt;/h2&gt;
&lt;p&gt;場合分けが面倒くさくて実装量が多くなる問題&lt;br&gt;．
まず初めにマスのグループ分けを行う．
というのも始める場所によっては行けないマスが存在することもあるからである（例えば&lt;code&gt;2 1 4 3&lt;/code&gt;だと1からスタートすると1 -&amp;gt; 2 -&amp;gt; 1を繰り返す）．
グループ分けは愚直にシミュレーションしても良いし，UnionFindTreeを用いてもできる．&lt;br&gt;
分けたグループそれぞれに対して，スコアを計算する．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kがグループのサイズ以下の場合&lt;br&gt;
グループに含まれる各値をスタート地点にして，シミュレーションする．
シミュレーションの途中のスコアも全て記録しておき，最大値を取得する&lt;/li&gt;
&lt;li&gt;Kがグループのサイズを超過する場合
&lt;ul&gt;
&lt;li&gt;グループの各数値iに対するCiの総和が
0より大きい場合&lt;br&gt;
なるべく多くループした方が良い．
&lt;code&gt;div = K / グループサイズ&lt;/code&gt;，&lt;code&gt;mod = K % グループサイズ&lt;/code&gt;とする．
&lt;ul&gt;
&lt;li&gt;modが0でない時&lt;br&gt;
余り回移動するシミュレーションを行い，その最大値を&lt;code&gt;総和 * div&lt;/code&gt;に足す．&lt;/li&gt;
&lt;li&gt;modが0の時&lt;br&gt;
ループを1回少なく行い，そこから最適な移動を行う場合を考える（Cに負の数が含まれる場合，総和 &amp;lt; 最適なシミュレーションになる）ので，グループサイズ回移動するシミュレーションを行い，その最大値を&lt;code&gt;総和 * (div - 1)&lt;/code&gt;に足す．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;0より小さい場合
ループしない方が良いので，グループサイズ回移動するシミュレーションを行う．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最終的に各グループに対して上の計算で出た値の最大値が答え．&lt;/p&gt;
&lt;h2 id=&#34;e---picking-goods&#34;&gt;E - Picking Goods&lt;/h2&gt;
&lt;p&gt;Dより簡単．DP．&lt;br&gt;
同じ行でいくつ宝箱を取得してかを表す要素を追加する．
&lt;code&gt;dp[R][C][3]&lt;/code&gt;．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC174の解説</title>
      <link>https://t45k.github.io/kyopuro/abc174/</link>
      <pubDate>Tue, 04 Aug 2020 13:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc174/</guid>
      <description>&lt;p&gt;5完．
Fが水diffだったのに解けなくて厳しい．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC174&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---air-conditioner&#34;&gt;A - Air Conditioner&lt;/h2&gt;
&lt;p&gt;条件分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---distance&#34;&gt;B - Distance&lt;/h2&gt;
&lt;p&gt;与えられたN個の座標の原点からの距離を計算していくだけ．&lt;br&gt;
また，こういう時，小数点の計算などは誤差が発生しやすいので，平方根をとる計算はせず，
全て二乗で計算した方が良い．
int型だとオーバーフローするので注意．&lt;/p&gt;
&lt;h2 id=&#34;c---repsept&#34;&gt;C - Repsept&lt;/h2&gt;
&lt;p&gt;証明が難しい問題．&lt;br&gt;
C問題なので，時間いっぱい（10^7くらい）計算して答えが見つかれば答えを，見つかれなければ-1を出力する方針で解いた．
計算じたいは，最初に&lt;code&gt;X = 7, i = 1&lt;/code&gt;として，XがKで割れればiを出力し，
割れなければ&lt;code&gt;X &amp;lt;- (X * 10 + 7) % K, i &amp;lt;- i + 1&lt;/code&gt;と更新すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---alter-altar&#34;&gt;D - Alter Altar&lt;/h2&gt;
&lt;p&gt;なんとなく解けた問題．&lt;br&gt;
答えは次のいずれかの小さい方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玉を赤か白に統一する&lt;/li&gt;
&lt;li&gt;swapして左側に赤，右側に白を揃える&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下の方法だと，最左の白玉と最右の赤玉の間にある玉の赤と白の少ない方の個数が答えになる．&lt;/p&gt;
&lt;h2 id=&#34;e---logs&#34;&gt;E - Logs&lt;/h2&gt;
&lt;p&gt;なんとなく解けた問題．想定解はにぶたん．&lt;br&gt;
まず&lt;code&gt;K &amp;lt;= 10^9&lt;/code&gt;という条件を無視すると，丸太iとその切断回数jに対して，
i/jの天井関数の降順に並べるようにした
優先度付きキューに丸太を入れて，K回先頭の割る回数を増やすという操作で解ける(以降，操作O)．
なので，&lt;code&gt;K&lt;/code&gt;を10^5くらいにできれば，この操作で大丈夫である．
&lt;code&gt;K&lt;/code&gt;を減らす方法として，はじめに丸太iの長さに応じて適切な切断回数を決めておき，
その切断回数の総和を&lt;code&gt;K&lt;/code&gt;から引いた上で，操作Oに入ればよい．
初期切断回数として，丸太の長さの総和に対する割合を利用できる．
つまり，丸太の長さの総和Sに対して，丸太iの長さがLiの時，
&lt;code&gt;K * (Li / S)&lt;/code&gt;を初期切断回数とすれば良い．&lt;/p&gt;
&lt;h2 id=&#34;f---range-set-query&#34;&gt;F - Range Set Query&lt;/h2&gt;
&lt;p&gt;解説AC．クエリをソートするという発想．&lt;br&gt;
クエリの右端を昇順に並べる．
クエリの右端までの玉の各種類について，最右なものの位置を記録していく．
最後に，クエリの左端より右側に位置している玉の数を数える（区間和なのでセグ木とかBIT）．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「きまぐれロボット」読了</title>
      <link>https://t45k.github.io/blog/kimagure_robot/</link>
      <pubDate>Sat, 25 Jul 2020 20:46:40 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/kimagure_robot/</guid>
      <description>&lt;p&gt;星新一のきまぐれロボットを読みました．&lt;/p&gt;
&lt;p&gt;この本を読んだ経緯ですが，楽天で買い物をしたときにもらった
電子書籍の割引券の使い道に困っていたところ，
友人に星新一を進められたのがきっかけです．&lt;/p&gt;
&lt;p&gt;ついこの間までしばらく本をあまり読んでいなかったうえに，
ここ最近は長めのミステリばかり読んでいたので，
ショートショートは本当に久しぶり（もしかしたら初めて）でした．
伏線を積み重ねまくって最後にひっくり返すミステリに対して，
ショートショートは長くても3ページ程度でオチがつくので，
スッと読み進められました．
また，すぐ話が切り替わるので，飽きることなく最後まで読めました．&lt;/p&gt;
&lt;p&gt;思ったよりショートショートが面白かったので，
また電子書籍のクーポンをもらえたら星新一の本をもう一冊買っても良いかなと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「ジョーカー 旧約探偵神話」読了</title>
      <link>https://t45k.github.io/blog/joker/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:49 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/joker/</guid>
      <description>&lt;p&gt;清涼院流水の「ジョーカー 旧約探偵神話」を読みました．&lt;/p&gt;
&lt;p&gt;全編を通して「メタミステリ」「過去のミステリに対する挑発」がひしひしと伝わってくる内容でした．
特にミステリ四大奇書である「ドグラマグラ」「匣の中の失楽」「虚無への供物」「黒死館殺人事件」は文中で何度も言及されており，
リスペクトが感じられました．
本文中でミステリの30の原則を挙げ，それを達成しようとする姿勢から，ミステリの総決算だと評されるのもうなずけました．&lt;/p&gt;
&lt;p&gt;内容自体は前作コズミックと被っている部分もありましたが（作中作など），どんでん返しからのどんでん返しなど目を見張るような場面もいくつもありました．
ラスト（真犯人）自体は読了直後はあまり納得いきませんでしたが，この直後にコズミックの内容がくることを考えるとなんとなく理解できました．&lt;/p&gt;
&lt;p&gt;少し残念なところは，今作は時系列的に前作の前の話であり，前作中で今作の事件内容が言及されることもあったため，
誰が殺されないかなどが薄々わかってしまったことです．&lt;/p&gt;
&lt;p&gt;次回は，同じく清涼院流水のカーニバル・イブを読む予定です．
そろそろ目的だった舞城王太郎の九十九十九を読んでも良いかもです．
また，いつかミステリ四大奇書も読める日が来ればなぁとは感じています．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>エイシングプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/aising2020/</link>
      <pubDate>Mon, 13 Jul 2020 18:19:23 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/aising2020/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/aising2020&#34;&gt;コード&lt;/a&gt;
実装が重かった印象．&lt;/p&gt;
&lt;h2 id=&#34;a---number-of-multiples&#34;&gt;A - Number of Multiples&lt;/h2&gt;
&lt;p&gt;for文で回すだけ&lt;/p&gt;
&lt;h2 id=&#34;b---an-odd-problem&#34;&gt;B - An Odd Problem&lt;/h2&gt;
&lt;p&gt;for文で回すだけ&lt;/p&gt;
&lt;h2 id=&#34;c---xyz-triplets&#34;&gt;C - XYZ Triplets&lt;/h2&gt;
&lt;p&gt;ゴリ押し全探索&lt;br&gt;
N&amp;lt;=10^4から，x,y,zそれぞれの最大値は10^2になることが分かる．
なので，x，yを1から10^2まで全探索しても計算量は全体で10^8に抑えられる．&lt;br&gt;
計算方法だが，xとyが決まればあとはzの二次方程式となるため，解の公式を使えば条件を満たすzが存在するかがO(1)で分かる．&lt;/p&gt;
&lt;h2 id=&#34;d---anything-goes-to-zero&#34;&gt;D - Anything Goes to Zero&lt;/h2&gt;
&lt;p&gt;意外と難しかったらしい問題&lt;br&gt;
条件から，各Xiを最初に割るのは，popcount(X)±1となる．
また桁iが0の時，&lt;code&gt;Xi = X + 2^i&lt;/code&gt;，1の時，&lt;code&gt;Xi = X - 2^1&lt;/code&gt;となることから，
Xの値と各2^iの値を最初に求めておけば，最初の余を求めるところ以降は愚直にやっても間に合う．
Xの値と各2^iの値は非常に大きくなる可能性があるので，何らかの値で割った余りを利用したい．
ここで，&lt;code&gt;条件から，各Xiを最初に割るのは，popcount(X)±1となる&lt;/code&gt;ので，popcount(X)±1で割った余りを記録して，
桁iの値で使い分ければ良い.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC173の解説</title>
      <link>https://t45k.github.io/kyopuro/abc173/</link>
      <pubDate>Mon, 13 Jul 2020 17:52:00 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc173/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC173&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---payment&#34;&gt;A - Payment&lt;/h2&gt;
&lt;p&gt;愚直にforループを回しても良いが，Nが最大10,000なのを踏まえて，
&lt;code&gt;10,000 - N&lt;/code&gt;をしてお釣りを1000で割った余りを求めると早い．&lt;/p&gt;
&lt;h2 id=&#34;b---judge-status-summary&#34;&gt;B - Judge Status Summary&lt;/h2&gt;
&lt;p&gt;switch文で数え上げるだけ．&lt;/p&gt;
&lt;h2 id=&#34;c---h-and-v&#34;&gt;C - H and V&lt;/h2&gt;
&lt;p&gt;典型的なbit全探索の問題．
縦，横でbit全探索して，該当行を赤く塗った後に盤上の黒いマスの個数を数える．&lt;/p&gt;
&lt;h2 id=&#34;d---chat-in-a-circle&#34;&gt;D - Chat in a Circle&lt;/h2&gt;
&lt;p&gt;なぜ解けたかよくわからなかった．
直感的には，Aiをソートした後に&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A1 A2を列に加える&lt;/li&gt;
&lt;li&gt;A3，A4を交互に列に加える．A1 A3 A2 A4となる&lt;/li&gt;
&lt;li&gt;A5，A6，A7，A8を交互に列に加える．A1 A5 A3 A6 A2 A7 A4 A8となる&lt;/li&gt;
&lt;li&gt;これを繰り返す．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;みたいな．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「コズミック 世紀末探偵神話」読了</title>
      <link>https://t45k.github.io/blog/cosmic/</link>
      <pubDate>Wed, 01 Jul 2020 11:05:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/cosmic/</guid>
      <description>&lt;p&gt;清涼院流水の「コズミック 世紀末探偵神話」を読みました．&lt;/p&gt;
&lt;p&gt;清涼院流水は，僕が敬愛する作家である西尾維新や舞城王太郎が影響を受けたと公言している作家なので，どんな本を書いているのか昔から非常に興味がありました．&lt;/p&gt;
&lt;p&gt;読んだ感想ですが，久しぶりにページを捲る手が止まらない本を読んだ気がします．
最初は分厚い上に延々と殺人事件が続くので若干退屈でしたが，探偵の推理パートに入ると一気に面白くなりました．
特に，最後の九十九十九が推理をする直前，読者への挑戦状あたりはずっと興奮していました．&lt;/p&gt;
&lt;p&gt;犯人は実は作者みたいなメタ的な展開を予想していたのですが，きれいに納得のいく形で完結していたのも良いと思いました．
前半の作中作が大きなヒントになっていたとは思わなかったです．&lt;/p&gt;
&lt;p&gt;この流れで，次も清涼院流水のジョーカーを読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC172の解説</title>
      <link>https://t45k.github.io/kyopuro/abc172/</link>
      <pubDate>Wed, 01 Jul 2020 10:38:47 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc172/</guid>
      <description>&lt;p&gt;C，D問題に緑diffが出て結構阿鼻叫喚な人が多かった回．
4完．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC172&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---calc&#34;&gt;A - Calc&lt;/h2&gt;
&lt;p&gt;計算するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---minor-change&#34;&gt;B - Minor Change&lt;/h2&gt;
&lt;p&gt;問題文から，SとTの同じ位置で文字が異なる回数を数え上げれば良いことが分かる．&lt;/p&gt;
&lt;h2 id=&#34;c---tsundoku&#34;&gt;C - Tsundoku&lt;/h2&gt;
&lt;p&gt;貪欲だと解けない問題．&lt;br&gt;
A，Bどちらの本も上限が10^5なので，全ての組み合わせを見ると時間が足りなくなる．
ここで，&lt;strong&gt;本は上から見ていく&lt;/strong&gt;というルールから，累積和をとっても問題ないことに気付ける．
累積和が取れるので，Aは前から見ていき，Bは二分探索できることに気付けるので，あとは実装するだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-divisors&#34;&gt;D - Sum of Divisors&lt;/h2&gt;
&lt;p&gt;最近流行のエラトステネス的問題．&lt;br&gt;
全ての数字の約数の個数をそれぞれ求めていたら遅いので，前から素数を見て，その素数を約数として持つ値に約数として加えていく方針でやる．&lt;br&gt;
実装としては，以下のようにする．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;長さNの配列を2つ用意する．
配列Aは1で，配列Bはその添字で初期化する．
配列Aは約数の個数を，配列Bは素数かどうかを判定するのに使う．&lt;/li&gt;
&lt;li&gt;2 &amp;lt;= i &amp;lt;= √Nとして，配列を順番に見ていく．
&lt;ul&gt;
&lt;li&gt;Biが2以上の時，iは素数となる．なので，iの倍数jに対して，jがiでk回割れる(= log(i,j))とすると&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;Ak *= k + 1
Bk /= i ^ k
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;と更新する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Biが1の時，iは素数なので何もしない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配列Aに約数の個数が記録できたので，√N以上の素数に注意しながら欲しい値を計算する．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ABC171の解説</title>
      <link>https://t45k.github.io/kyopuro/abc171/</link>
      <pubDate>Tue, 30 Jun 2020 22:33:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc171/</guid>
      <description>&lt;p&gt;難易度が暴落した回．&lt;br&gt;
5完．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC171&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---αlphabet&#34;&gt;A - αlphabet&lt;/h2&gt;
&lt;p&gt;やるだけ．
Javaなら&lt;code&gt;Character#isUpperCase&lt;/code&gt;とかが使える．&lt;/p&gt;
&lt;h2 id=&#34;b---mix-juice&#34;&gt;B - Mix Juice&lt;/h2&gt;
&lt;p&gt;ソートして前からK個選ぶ．&lt;/p&gt;
&lt;h2 id=&#34;c---one-quadrillion-and-one-dalmatians&#34;&gt;C - One Quadrillion and One Dalmatians&lt;/h2&gt;
&lt;p&gt;与えられた数字を26進数に変換する問題．&lt;br&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Nをデクリメントし&lt;/li&gt;
&lt;li&gt;Nを26で割ったあまりを求め(これを使う)&lt;/li&gt;
&lt;li&gt;N /= 26 をする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を繰り返す．&lt;/p&gt;
&lt;h2 id=&#34;d---replacing&#34;&gt;D - Replacing&lt;/h2&gt;
&lt;p&gt;C問題よりわかりやすい．&lt;br&gt;
最初に全ての和Sと，それぞれの数字が何回出てくるかを記録しておく．
各クエリ毎に以下の操作をすれば良い．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与えられたCに対して，SからC*(Cの出現回数)を引く&lt;/li&gt;
&lt;li&gt;与えられたDに対して，SにD*(Cの出現回数)を加える&lt;/li&gt;
&lt;li&gt;Dの出現回数にCの出現回数を加える&lt;/li&gt;
&lt;li&gt;Cの出現回数を0にする&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;e---red-scarf&#34;&gt;E - Red Scarf&lt;/h2&gt;
&lt;p&gt;まさかの茶diff．Nが偶数という制約があるのを知らんかった&amp;hellip;&lt;br&gt;
すぬけ君iのスカーフに書かれた整数をbiとすると&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 =      b2 ^ b3 ^ ... ^ bn
a2 = b1 ^      b3 ^ ... ^ bn
a3 = b1 ^ b2 ^      ... ^ bn
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;であることが分かる．
また，排他的論理和の性質から&lt;code&gt;x ^ x = 0&lt;/code&gt;なので，以下が成り立つ．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 ^ a2 ^ a3 ^ ... ^ an
= (b1 ^ b1 ^ ... ^ b1(= n-1回の排他的論理和)) ^ (b2 ^ b2 ^ ...) ^ ...
= b1 ^ b2 ^ ... ^bn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;つまり&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 ^ (a1 ^ a2 ^ ... ^ an)
= b1 ^ (b2 ^ b2) ^ (b3 ^ b3) ^ ...
= b1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;が成り立つ．&lt;br&gt;
つまり，biを求めるためには，全てのaの排他的論理和とaiの排他的論理和を求めれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC170の解説</title>
      <link>https://t45k.github.io/kyopuro/abc170/</link>
      <pubDate>Sat, 20 Jun 2020 11:52:18 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc170/</guid>
      <description>&lt;p&gt;無念の3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC170&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---five-variables&#34;&gt;A - 	Five Variables&lt;/h2&gt;
&lt;p&gt;やるだけ．
Listを作って&lt;code&gt;List#indexOf&lt;/code&gt;で探すと楽．&lt;/p&gt;
&lt;h2 id=&#34;b---crane-and-turtle&#34;&gt;B - Crane and Turtle&lt;/h2&gt;
&lt;p&gt;ツルカメ算．
ループを回す．&lt;/p&gt;
&lt;h2 id=&#34;c---forbidden-list&#34;&gt;C - Forbidden List&lt;/h2&gt;
&lt;p&gt;解答が燃えた問題．&lt;br&gt;
Xが100以下なので，答えは101以下になる．
したがって，0から101までの，数列に含まれていない数字に対してXとの差を計算するだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---not-divisible&#34;&gt;D - Not Divisible&lt;/h2&gt;
&lt;p&gt;解けなかった．&lt;br&gt;
エラトステネスの篩のイメージ．
数列A中の最大値をAmaxとすると，数列Aを昇順に見て&lt;code&gt;sqrt(Amax)&lt;/code&gt;までの数字の倍数を全て消す作業をする．
最後に残った数字の中でダブりがないものが答え．&lt;/p&gt;
&lt;h2 id=&#34;e---smart-infants&#34;&gt;E - Smart Infants&lt;/h2&gt;
&lt;p&gt;データ構造で殴る問題．
Javaの標準ライブラリにMultiSetはないので少し考える必要がある．
今回は各幼稚園の園児のレートをTreeSetで，全ての幼稚園の最小値をセグ木で持つと，転園は以下の操作で行われる．
また，各園児が現在所属している幼稚園の情報を持つとする．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cjの園児が所属している幼稚園(TreeSet)からCjを消す．&lt;/li&gt;
&lt;li&gt;その幼稚園に関してセグ木の値を更新する．もし幼稚園に園児がいないなら&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;とする．&lt;/li&gt;
&lt;li&gt;幼稚園DjにCjを加える．&lt;/li&gt;
&lt;li&gt;幼稚園Djに関してセグ木の値を更新する．&lt;/li&gt;
&lt;li&gt;セグ木の全ての範囲に対してクエリを投げる．これが平等さになる．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>東京海上日動プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/tokiomarine2020/</link>
      <pubDate>Sun, 14 Jun 2020 18:55:26 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/tokiomarine2020/</guid>
      <description>&lt;p&gt;3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/other/tokiomarine2020&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---nickname&#34;&gt;A - Nickname&lt;/h2&gt;
&lt;p&gt;与えられた文字列の先頭3文字を抜き出すだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---tag&#34;&gt;B - Tag&lt;/h2&gt;
&lt;p&gt;非鬼が鬼より右側にいる場合，BはAに捕まらいためには右側に逃げるのが最適となる．
鬼と非鬼がT秒移動した時にいる箇所は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鬼: &lt;code&gt;A + V*T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非鬼: &lt;code&gt;B + W*T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となる．
鬼の座標が非鬼の座標以上に右側にいる(=より座標が大きい)と捕まるので，それを判定するだけ&lt;/p&gt;
&lt;h2 id=&#34;c---lamps&#34;&gt;C - Lamps&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imoz.jp/algorithms/imos_method.html&#34;&gt;いもす法&lt;/a&gt;をすると1回の操作はO(N)で達成できるので，K回やるとO(NK)となる(いもす法のやり方: Aiの値がdの時，座標&lt;code&gt;i-d&lt;/code&gt;に+1，座標&lt;code&gt;i+d+1&lt;/code&gt;に-1を加え，最後に累積和する)．
O(NK)なので，最大で4*10^10程度の計算量となってしまいそうだが，ここで問題文から以下のことが言える．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全ての電球の明るさが&lt;code&gt;N&lt;/code&gt;となった場合，それ以降の操作で明るさは増えないため，そこで操作を打ち切って良い&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作回数が最大になるのはN=10^5，K=10^5，全ての電球の明るさの初期値が0の時なので，これを試してみると時間に十分間に合う．&lt;/p&gt;
&lt;p&gt;あとはやるだけ．&lt;/p&gt;
&lt;p&gt;解答を見ると，操作回数はO(log N)で抑えられるらしい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC169の解説</title>
      <link>https://t45k.github.io/kyopuro/abc169/</link>
      <pubDate>Mon, 01 Jun 2020 13:25:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc169/</guid>
      <description>&lt;p&gt;久々のABC水パフォ．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC169&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---multiplication-1&#34;&gt;A - Multiplication 1&lt;/h2&gt;
&lt;p&gt;読み込んで掛け算して出力するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---multiplication-2&#34;&gt;B - Multiplication 2&lt;/h2&gt;
&lt;p&gt;与えられた数字の中に0があれば確定で0．
それ以外の場合，それぞれ掛けて10^18を越えるかを確認すれば良い．
Javaだと&lt;code&gt;BigInteger&lt;/code&gt;が使える．
比較は&lt;code&gt;BigInteger#compareTo&lt;/code&gt;で，0より大きければ1が返るっぽい．&lt;/p&gt;
&lt;h2 id=&#34;c---multiplication-3&#34;&gt;C - Multiplication 3&lt;/h2&gt;
&lt;p&gt;罠．&lt;br&gt;
Javaだと&lt;code&gt;BigDecimal&lt;/code&gt;が使える．
解説通りにやるとするなら，一旦文字列で読み込んで，小数点を消した上で整数に変換すると良さそう．&lt;/p&gt;
&lt;h2 id=&#34;d---div-game&#34;&gt;D - Div Game&lt;/h2&gt;
&lt;p&gt;まずは素因数分解する．
問題の条件から素数pに対して，p^1，p^2，p^3，&amp;hellip;，p^kと割っていくのが最適となる．
したがって，各素数の出現回数からkを求めれば良い．
p^kまで作るには，出現回数は&lt;code&gt;1+2+3+...k=k(k+1)/2&lt;/code&gt;個必要となる．
これは，kを1から全部列挙して探せば良い．
出現回数の最大値は，N&amp;lt;=10^12≒2^40から高々40回程度なので，全列挙しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;e---count-median&#34;&gt;E - Count Median&lt;/h2&gt;
&lt;p&gt;たまたま解けた．&lt;br&gt;
とても単純化してみる．&lt;/p&gt;
&lt;h3 id=&#34;nが奇数の時&#34;&gt;Nが奇数の時&lt;/h3&gt;
&lt;p&gt;N=3で，以下のような時を考える．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;|---|  |---|  |---|
a   b  c   d  e   f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この時，明らかに中央値はc~dの整数値になる．&lt;br&gt;
このことから，何となく中央値は(0-indexedで)前からN/2番目の開始位置と後ろからN/2番目の終了位置の間の整数値であると考えられる．&lt;/p&gt;
&lt;h3 id=&#34;nが偶数の時&#34;&gt;Nが偶数の時&lt;/h3&gt;
&lt;p&gt;N=4で，以下のような時を考える．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;|---|  |---|  |---|  |---|
a   b  c   d  e   f  g   h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この時，中央値は((c~dの値)+(e~fの値))/2となる．
また，片方を1動かせば，中央値は1/2変化するので，中央値は1/2刻みとなる．
中央値候補の最小値は(c+e)/2，最大値は(d+f)/2となるので，その間の1/2刻みの値が中央値になると考えられる．&lt;/p&gt;
&lt;p&gt;一般性は，あります！&lt;/p&gt;
&lt;h2 id=&#34;f---knapsack-for-all-subsets&#34;&gt;F - Knapsack for All Subsets&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;br&gt;
最初に，dp[N][S]を用意する．
各1&amp;lt;=i&amp;lt;=Nに対して，iを加えるか加えないかの2通りがあるので，iの遷移の度に，dp[i][j]はi-1の各jの値*2となる
そしてAiを加えるかの判定をする．ここは普通のDP&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NOMURA プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/nomura2020/</link>
      <pubDate>Sun, 31 May 2020 15:57:56 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/nomura2020/</guid>
      <description>&lt;p&gt;何とか3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/nomura2020&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---study-scheduling&#34;&gt;A - Study Scheduling&lt;/h2&gt;
&lt;p&gt;時間を分に直して引き算するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---postdocs&#34;&gt;B - Postdocs&lt;/h2&gt;
&lt;p&gt;例えば，&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;P&lt;/code&gt;にした場合，その右側に&lt;code&gt;D&lt;/code&gt;がある時だけ指数が1増えるのに対して，&lt;code&gt;D&lt;/code&gt;にすると確実に指数が1増えることから，全ての&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;D&lt;/code&gt;に変換するのが最適になる．&lt;/p&gt;
&lt;h2 id=&#34;c---folia&#34;&gt;C - Folia&lt;/h2&gt;
&lt;p&gt;解けてる人多くてびっくりした．
厳密な証明はeditorial参照．&lt;br&gt;
初めに木を上から下の方へ見ていって，それぞれの深さでの葉でない頂点(以降，節)の最大値数を求めていく．
深さiの葉の数がAiの時，深さi-1での節の数がAi/2未満の時，Ai個の葉を生成できないので条件を満たす木は存在しない．&lt;br&gt;
次に，木を下から上へ見ていき，各深さでの節の数を最適化していく．
木の頂点数を最大にするためには，各深さiに対して節の数を最大化したい．
節の数は，深さi+1の頂点数より大きくできない（全ての節は1つ以上の子を持つ），また，初めの操作により，深さiの節の個数から(深さi+1の頂点)個の子を産めることが分かっている．
したがって，深さiでの節の数の最大値は&lt;code&gt;min(深さiでの節の数，深さi+1での頂点の数)&lt;/code&gt;となる．
あとはこれを再帰的に計算して足し合わせるだけ．&lt;br&gt;
この解き方だと，n=0がコーナーケースになることに注意(&lt;code&gt;n=0&lt;/code&gt;, &lt;code&gt;A0=1&lt;/code&gt;の時のみ答えが&lt;code&gt;1&lt;/code&gt;で，それ以外は&lt;code&gt;-1&lt;/code&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「阿修羅ガール」読了</title>
      <link>https://t45k.github.io/blog/ashura-girl/</link>
      <pubDate>Thu, 28 May 2020 00:23:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ashura-girl/</guid>
      <description>&lt;p&gt;舞城王太郎の阿修羅ガールを読みました．&lt;/p&gt;
&lt;p&gt;一人称視点で進んでいくのですが，主人公の心の声の喋り方がとても真に迫った感じだったのが印象的でした．
特に，第二部の後半の進め方がすごく理解しやすく，場面をイメージしやすかったです．
他に，ディスコ探偵水曜日でも登場した桜月淡雪が出てきたのはニヤリとしました．
舞城王太郎の作品で西暁が出てこないのは珍しいのではないでしょうか．&lt;/p&gt;
&lt;p&gt;今回，人生で初めて電子書籍を試してみました．
読んだページの量で達成感を感じる人なので，どのくらいのページ読んだのかが直感的にわからない電子書籍は読書の達成感は薄かったです．&lt;/p&gt;
&lt;p&gt;次は，舞城王太郎と西尾維新が崇拝している（であろう）清涼院流水の「コズミック」を読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AGC044の解説</title>
      <link>https://t45k.github.io/kyopuro/agc044/</link>
      <pubDate>Wed, 27 May 2020 23:41:26 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc044/</guid>
      <description>&lt;p&gt;太陽でしたがNoSubなのでレートは変わらなかったです(NoSubというシステムをよく理解していなかったので，入力するのではないかとドキドキしてました)．
A，Bの解説．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/AGC/AGC044&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---pay-to-win&#34;&gt;A - Pay to Win&lt;/h2&gt;
&lt;p&gt;400点問題だと高を括って望んだら痛い目にあった．&lt;br&gt;
簡単に説明するとNから2，3，5で割っていくだけ．
メモ化(b|d)fs．
メモは値をキー，コストをバリューとしたMapで持つ．
bfsで解く場合は，キューから取り出した値Kに対して&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(a,d*K/2)&lt;/code&gt;（2で割るか，同じ値だけ1を引くかのコストが小さい方）がメモ[K/2]を更新できなければ何もしない．更新できれば，K/2をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K+1とK-1は2で割れるので，割れる場合と同じ処理をする．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(b,d*2*K/3)&lt;/code&gt;がメモ[K/3]を更新できなければ何もしない．更新できれば，K/3をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K-K%3とK+3-K%3はKで割り切れるので，割れる場合と同じ処理をする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5で割れるか試す．略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;をやるだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---joker&#34;&gt;B - Joker&lt;/h2&gt;
&lt;p&gt;計算量の見積もりが難しい問題．&lt;br&gt;
N&amp;lt;=500に対して，与えられる座標の数はN^2なので，座標が与えられる度に(d|b)fsすると間に合わないように見える．
しかし，実は間に合う．
1回の(b|d)fsでいくつかの座標の端からの距離が減る
では全ての走査で行われる操作は合計でO(n^3)で収まる
例えばN=6の時，最初の各座標の端からの距離は以下のようになる&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
全てを走査しきる（= 各座標の端からの距離が0になる）のは 4*4 + 2*2(四角形を狭めていくイメージ)回の操作が必要となる．
合計するとだいたい (N^3)/6 らしいので条件下で間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC168の解説</title>
      <link>https://t45k.github.io/kyopuro/abc168/</link>
      <pubDate>Tue, 19 May 2020 19:54:50 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc168/</guid>
      <description>&lt;p&gt;速解き回だったけど速解き失敗．
4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC168&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a----therefore&#34;&gt;A - ∴ (Therefore)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;文を使う問題．
コードが長くなりがち．
Kotlinだと気持ちよく書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;fun main() {
    Scanner(System.`in`)
        .run {
            when (this.nextInt() % 10) {
                3 -&amp;gt; &amp;#34;bon&amp;#34;
                0, 1, 6, 8 -&amp;gt; &amp;#34;pon&amp;#34;
                else -&amp;gt; &amp;#34;hon&amp;#34;
            }.apply(::println)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;b----triple-dots&#34;&gt;B - &amp;hellip; (Triple Dots)&lt;/h2&gt;
&lt;p&gt;やるだけ．
Sの長さがKを上回っているとき，&lt;code&gt;S.substring(0, K.length)&lt;/code&gt;．&lt;/p&gt;
&lt;h2 id=&#34;c----colon&#34;&gt;C - : (Colon)&lt;/h2&gt;
&lt;p&gt;数学．&lt;br&gt;
極座標か余弦定理を使うと簡単に解ける．
意外と二つの針の間の角度を求めるのが曲者．&lt;/p&gt;
&lt;h2 id=&#34;d----double-dots&#34;&gt;D - .. (Double Dots)&lt;/h2&gt;
&lt;p&gt;嫌な気持ちになります．&lt;br&gt;
問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e----bullet&#34;&gt;E - ∙ (Bullet)&lt;/h2&gt;
&lt;p&gt;解説AC&lt;br&gt;
解く手順としては&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪いイワシを組み合わせないようにする方法&lt;/li&gt;
&lt;li&gt;最終的な組み合わせを数え上げる方法
の2つを考える．&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-仲の悪いイワシを組み合わせないようにする方法&#34;&gt;1. 仲の悪いイワシを組み合わせないようにする方法&lt;/h3&gt;
&lt;p&gt;Ai * Aj + Bi * Bj = 0という条件から，美味しさと香り高さがどちらも0のイワシは全てのイワシと仲が悪い．
それ以外のイワシについて考えると，仲が悪くなるにはAi = a, Bi =bの時，Aj = k&lt;em&gt;b, Bj = -k&lt;/em&gt;aとなる必要がある(kは0以外の整数)．
なのでイワシを2種類のグループに分ける．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致する&lt;/li&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致しない&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;そうすると，それぞれのグループを美味しさと香り高さを互いに素にした値のペアをキー，出現回数をバリューとしたマップにすると，それぞれのキーに対して仲の悪いイワシの数が分かる．
例えば，グループ1のキーを(美味しさの絶対値をGCDで割った値，香り高さの絶対値をGCDで割った値)，グループ2のキーを(香り高さの絶対値をGCDで割った値，美味しさの絶対値をGCDで割った値)にしておくと，グループ1とグループ2の共通するキーが仲の悪い組み合わせになる．&lt;/p&gt;
&lt;h3 id=&#34;2-最終的な組み合わせを数え上げる方法&#34;&gt;2. 最終的な組み合わせを数え上げる方法&lt;/h3&gt;
&lt;p&gt;まず，全てのイワシが仲が悪くないとき，組み合わせの総数は，どのイワシも選ばない組み合わせを除いて2^N-1になる．
これを踏まえると，先ほどのグループ1，2の各キーに対して，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪い組み合わがある場合，それぞれのバリューp,qに対して 2^p + 2^q - 1&lt;br&gt;
これはグループ1，2両方のイワシを同時に加えることはできないので別々に計算する．グループ1だけから選ぶ場合は2^p通り，グループ2からだけ選ぶ場合は2^q通りになる．最後に，グループ1，2両方とも選ばない場合が重複しているので1引く．&lt;/li&gt;
&lt;li&gt;仲の悪い組み合わせがない場合，そのバリューpに対して 2^p&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を掛けていき，最終的に1引いた値（どのイワシも選ばない組み合わせ）が答えになる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC167の解説</title>
      <link>https://t45k.github.io/kyopuro/abc167/</link>
      <pubDate>Mon, 11 May 2020 11:43:31 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc167/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/t45k/tree/master/AtCoder/ABC/ABC167&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---registration&#34;&gt;A - Registration&lt;/h2&gt;
&lt;p&gt;文字列Sと文字列Tの最後の文字を消した文字列が同等か確認する．
javaだと &lt;code&gt;S.equals(T.substring(0, S.length))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;b---easy-linear-programming&#34;&gt;B - Easy Linear Programming&lt;/h2&gt;
&lt;p&gt;A,B,Cの順番になるべく多くカードを取ると最大値になるので&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KがA以下なら1のカードをK枚取って和はK&lt;/li&gt;
&lt;li&gt;Kが(A+B)以下なら，1のカードをA枚，0のカードを取れるだけ取って和はA&lt;/li&gt;
&lt;li&gt;それ以外なら1をA枚，0をB枚，-1を(K-(A+B))枚取って和は2A+B+K&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c---skill-up&#34;&gt;C - Skill Up&lt;/h2&gt;
&lt;p&gt;bit全探索するだけ問題．&lt;br&gt;
N&amp;lt;=12なので，全て試しても2^12≒4000通りなので十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---teleporter&#34;&gt;D - Teleporter&lt;/h2&gt;
&lt;p&gt;ABC030_Dとほぼ同じ問題．&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;knのとき&#34;&gt;K&amp;lt;=Nのとき&lt;/h3&gt;
&lt;p&gt;K回のテレポートを愚直に計算しても間に合う．&lt;/p&gt;
&lt;h3 id=&#34;knの時&#34;&gt;K&amp;gt;Nの時&lt;/h3&gt;
&lt;p&gt;鳩の巣原理的に考えると，必ずどこかでループが発生することになる．
なので，1ループで訪れる町の数でmodを取る．&lt;/p&gt;
&lt;h2 id=&#34;e---colorful-blocks&#34;&gt;E - Colorful Blocks&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．&lt;br&gt;
全て隣り合わない組み合わせは m*(m-1)^(n-1)になる．
1組隣り合う場合，その隣り同士は同じ色なので ↑/(m-1)
↑に組み合わせをかける．一つ右とペアになると考えれば n-1C1 通り
2組以降も同じように考える．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「クビシメロマンチスト 人間失格・零崎人識」読了</title>
      <link>https://t45k.github.io/blog/easy_love_easy_no/</link>
      <pubDate>Wed, 06 May 2020 20:45:52 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/easy_love_easy_no/</guid>
      <description>&lt;p&gt;西尾維新の戯言シリーズ2作目であるクビシメロマンチストを読みました．
&lt;a href=&#34;https://www.amazon.co.jp/%E3%82%AF%E3%83%93%E3%82%B7%E3%83%A1%E3%83%AD%E3%83%9E%E3%83%B3%E3%83%81%E3%82%B9%E3%83%88-%E4%BA%BA%E9%96%93%E5%A4%B1%E6%A0%BC%E3%83%BB%E9%9B%B6%E5%B4%8E%E4%BA%BA%E8%AD%98-%E8%AC%9B%E8%AB%87%E7%A4%BE%E6%96%87%E5%BA%AB-%E8%A5%BF%E5%B0%BE%E7%B6%AD%E6%96%B0-ebook/dp/B01EV0NMIG/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2WNUAO24W551I&amp;amp;dchild=1&amp;amp;keywords=%E3%82%AF%E3%83%93%E3%82%B7%E3%83%A1%E3%83%AD%E3%83%9E%E3%83%B3%E3%83%81%E3%82%B9%E3%83%88&amp;amp;qid=1588765443&amp;amp;sprefix=%E3%81%8F%E3%81%B3%E3%81%97%E3%82%81%2Caps%2C293&amp;amp;sr=8-1&#34;&gt;amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高校生くらいの時に一度読んだのですが，面白かったのを覚えていたため古本で購入しました．
2度目でしたがやっぱり面白くかったです．
中二臭い言い回し，叙述トリック，そして完璧なラストと個人的にツボにはまる部分が多く，24年間生きてきて面白かった本暫定一位です．
西尾維新といえば物語シリーズが有名ですが，このシリーズも負けず劣らず面白いのでぜひ皆さんに読んで欲しいとは思います．
区分的にはライトノベルになるので，10年後，20年後にはまた違った感想を抱くかもしれません．&lt;/p&gt;
&lt;p&gt;アニメ化期待してます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>競プロ</title>
      <link>https://t45k.github.io/kyopuro_index/</link>
      <pubDate>Wed, 06 May 2020 18:26:46 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro_index/</guid>
      <description>&lt;p&gt;競プロの解説とか．
Javaでやっているのでコード例はJavaになります．&lt;br&gt;
リポジトリは&lt;a href=&#34;https://github.com/t45k/kyopuro&#34;&gt;こちら&lt;/a&gt;．&lt;br&gt;
自作ライブラリのドキュメントは&lt;a href=&#34;../kyopuro/doc/util/package-summary.html&#34;&gt;こちら&lt;/a&gt;．&lt;/p&gt;
&lt;script src=&#34;https://code.jquery.com/jquery-2.1.3.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function(){
      $(&#34;#cover&#34;).load(&#34;../kyopuro/index.html #for_outer&#34;);
    });
&lt;/script&gt;
&lt;div id=&#34;cover&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ブログ</title>
      <link>https://t45k.github.io/blog_index/</link>
      <pubDate>Wed, 06 May 2020 18:26:39 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog_index/</guid>
      <description>&lt;p&gt;近況や今まで読んできた本の感想などを書いていきます．&lt;/p&gt;
&lt;script src=&#34;https://code.jquery.com/jquery-2.1.3.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function(){
      $(&#34;#cover&#34;).load(&#34;../blog/index.html #for_outer&#34;);
    });
&lt;/script&gt;
&lt;div id=&#34;cover&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ABC166の解説</title>
      <link>https://t45k.github.io/kyopuro/abc166/</link>
      <pubDate>Mon, 04 May 2020 22:58:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc166/</guid>
      <description>&lt;p&gt;二日連続ABCの二日目．
ABCEの4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC166&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---ac&#34;&gt;A - A?C&lt;/h2&gt;
&lt;p&gt;分岐するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---trick-or-treat&#34;&gt;B - Trick or Treat&lt;/h2&gt;
&lt;p&gt;数え上げるだけ&lt;/p&gt;
&lt;h2 id=&#34;c---peaks&#34;&gt;C - Peaks&lt;/h2&gt;
&lt;p&gt;結構誤読してた人が多かった問題&lt;br&gt;．
問題文から，i番目の展望台が地震を含めて繋がっている展望台の中で一番高ければ良いことが分かる．
つまり，繋がっている展望台のどれか一つでも自身より高いものが良い展望台となる．
なので，各A,Bに対して大きい方だけ残していくという戦略を取れば，残ったものが良い展望台である．&lt;/p&gt;
&lt;h2 id=&#34;d---i-hate-factorization&#34;&gt;D - I hate Factorization&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
問題文を誤読しないように．
&lt;strong&gt;任意の&lt;/strong&gt;Xについて成り立っているのではなく，&lt;strong&gt;テストケースとして与えられる&lt;/strong&gt;Xについて成り立つ．
およそ200くらいが上限となるらしいので，それについて全探索するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---this-message-will-self-destruct-in-5s&#34;&gt;E - This Message Will Self-Destruct in 5s&lt;/h2&gt;
&lt;p&gt;条件は添字i,jに対して&lt;code&gt;i - j = Ai + Aj&lt;/code&gt;であり，これを式変形すると&lt;code&gt;i - Ai = j + Aj&lt;/code&gt;となる．
つまり，(添字と身長の差)と(添字と身長の和)が同じ値になるペアが条件を満たす．
なので各Aに対して添字との差と和をあらかじめ計算しておけば解ける&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC165の解説</title>
      <link>https://t45k.github.io/kyopuro/abc165/</link>
      <pubDate>Mon, 04 May 2020 22:58:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc165/</guid>
      <description>&lt;p&gt;二日連続ABCの一日目．
3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC165&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---we-love-golf&#34;&gt;A - We Love Golf&lt;/h2&gt;
&lt;p&gt;きちんと数学して解くこともできるが，制約が小さいので全探索しても間に合う．
AからBまでの閉区間内にKの倍数があるか確認する．&lt;/p&gt;
&lt;h2 id=&#34;b---1&#34;&gt;B - 1%&lt;/h2&gt;
&lt;p&gt;これもきちんと数学して解けるけど全探索で解ける系．
入力例から分かるように，10^18が与えられても出力は3760になるので，1~3760までの区間を探索するだけで良い．&lt;/p&gt;
&lt;h2 id=&#34;c---many-requirements&#34;&gt;C - Many Requirements&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
これも全探索するだけ問題．
考えられる数列を全列挙して特典の最大値を探す．&lt;br&gt;
全列挙に必要な計算量が10^10だと思っていたので試さなかったが，実際にはボールとしきりの要領で組み合わせを考えると計算量は*O(N * C(N+M-1,N))*なので，全列挙しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---floor-function&#34;&gt;D - Floor Function&lt;/h2&gt;
&lt;p&gt;数学．editorialが分かりやすいです．&lt;/p&gt;
&lt;h2 id=&#34;e---rotation-matching&#34;&gt;E - Rotation Matching&lt;/h2&gt;
&lt;p&gt;同じ組み合わせを避けていく問題．&lt;br&gt;
例えば，組み合わせ(1,N)は(1,2)と同じ組み合わせになる．
したがって，(組み合わせの方の大きい方)-(小さい方)を&lt;strong&gt;組み合わせの距離&lt;/strong&gt;と定義すると，距離N-iと距離iは同じ組み合わせである．
これを念頭に入れてN-1からN-mまでの組み合わせを考えていく．
(1,N)(2,N-1)&amp;hellip;と作っていくと距離N-1,N-3&amp;hellip;と1飛ばしに組み合わせを作れる．
途中で折り返しをうまく調整して距離N-2,N-4&amp;hellip;の組み合わせを作る．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC164の解説</title>
      <link>https://t45k.github.io/kyopuro/abc164/</link>
      <pubDate>Mon, 27 Apr 2020 23:38:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc164/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/atcoder/abc/abc164&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---sheep-and-wolves&#34;&gt;A - Sheep and Wolves&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---battle&#34;&gt;B - Battle&lt;/h2&gt;
&lt;p&gt;割った余りを求めるのがスマートだけで，先攻後攻の概念があるので愚直に互いに引いていった方が安全．&lt;/p&gt;
&lt;h2 id=&#34;c---gacha&#34;&gt;C - gacha&lt;/h2&gt;
&lt;p&gt;JavaだとSetに打ち込めば良い．
&lt;code&gt;Stream#distinct&lt;/code&gt;からの&lt;code&gt;Stream#count&lt;/code&gt;で多少スマートに書ける．&lt;/p&gt;
&lt;h2 id=&#34;d---multiple-of-2019&#34;&gt;D - Multiple of 2019&lt;/h2&gt;
&lt;p&gt;各桁に対して，i桁目の数字がDiとして&lt;code&gt;Si = (10 ^ i * Di + Si-1) % 2019&lt;/code&gt;を計算すると，Siが同じ値の桁間の数字は2019の倍数になる．&lt;/p&gt;
&lt;h2 id=&#34;e---two-currencies&#34;&gt;E - Two Currencies&lt;/h2&gt;
&lt;p&gt;むずかしかった．&lt;br&gt;
(頂点番号, 所持金)を一つの頂点としてダイクストラする．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K-Shoot MANIAが正しく動かなくなった原因とその対策</title>
      <link>https://t45k.github.io/blog/k-shoot_mania/</link>
      <pubDate>Sat, 25 Apr 2020 17:05:30 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/k-shoot_mania/</guid>
      <description>&lt;p&gt;K-Shoot MANIAの挙動がおかしい原因が分かったのでメモ&lt;/p&gt;
&lt;h2 id=&#34;症状&#34;&gt;症状&lt;/h2&gt;
&lt;p&gt;キーボードの入力が異様に遅くなる．
キーボードを押しっぱなしにして10秒後くらいにようやく反応する．
もちろんプレイもままならない．
Windowsのpreview版を使っていたのでそれが原因かなと思っていたが，違うPCでも同じ症状が出たためOSは関係なかった．&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;キーボードの入力を書き換えるソフトを使っていたのが原因．
&lt;a href=&#34;https://sites.google.com/site/craftware/keyhac-ja&#34;&gt;keyhac&lt;/a&gt;と&lt;a href=&#34;https://www.karakaram.com/alt-ime-on-off&#34;&gt;alt-ime&lt;/a&gt;を使っていたが，これのせいでキーボードの入力がケーシューに正しく反映されなくなってたっぽい．
対策は簡単で，該当ソフトを落とすだけ．&lt;/p&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに&lt;/h2&gt;
&lt;p&gt;LR2の反応がおかしかったのもこれが原因かも．
自宅ゲーセン環境で快適なひきこもり生活を．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ディスコ探偵水曜日 読了</title>
      <link>https://t45k.github.io/blog/disco_detective_wednesdayyy/</link>
      <pubDate>Fri, 24 Apr 2020 19:01:51 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/disco_detective_wednesdayyy/</guid>
      <description>&lt;p&gt;&lt;strong&gt;この世の出来事は全部運命と意志の相互作用で生まれるんだって、知ってる？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「ディスコ探偵水曜日」を読みました．
10年以上前の本なのでおそらく新品ではもう手に入りません．
僕はBook Offをはしごしました．&lt;/p&gt;
&lt;p&gt;上中下の3巻構成なのですが，下巻が異様に長い上にとても難解．
この本を読むのは2回目ですが，今回も内容を理解しきれませんでした．&lt;/p&gt;
&lt;p&gt;粗筋は割愛します．
個人的には中間の，名探偵が次々と推理を披露して死んでいくシーンと，そしてディスコが最後の推理をするシーンが，
舞城王太郎特有のスピード感があって好きです．&lt;/p&gt;
&lt;p&gt;1年に1回，イベントとしてこの本を読むことをありかなぁと思いました．&lt;/p&gt;
&lt;p&gt;次は西尾維新の「クビシメロマンチスト」を読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC163の解説</title>
      <link>https://t45k.github.io/kyopuro/abc163/</link>
      <pubDate>Tue, 21 Apr 2020 16:22:58 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc163/</guid>
      <description>&lt;p&gt;3完．
unratedで良かった&amp;hellip;
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/ABC/ABC163&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---circle-pond&#34;&gt;A - Circle Pond&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
円周は&lt;code&gt;2 * r * 円周率&lt;/code&gt;．
Javaだと円周率は&lt;code&gt;java.lang.Math.PI&lt;/code&gt;が使える．&lt;/p&gt;
&lt;h2 id=&#34;b---homework&#34;&gt;B - Homework&lt;/h2&gt;
&lt;p&gt;全ての宿題をやるには&lt;code&gt;Σ Ai&lt;/code&gt;日かかるので，それを&lt;code&gt;M&lt;/code&gt;と比較する．&lt;/p&gt;
&lt;h2 id=&#34;c---management&#34;&gt;C - management&lt;/h2&gt;
&lt;p&gt;問題文が若干ややこしい．
やることは特定の数字が何回出てくるかを数えるだけ．
はじめに配列&lt;code&gt;array[N + 1]&lt;/code&gt;を用意して，各&lt;code&gt;Ai&lt;/code&gt;に対して&lt;code&gt;array[Ai]++&lt;/code&gt;する．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-large-numbers&#34;&gt;D - Sum of Large Numbers&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．
組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった&amp;hellip;&lt;br&gt;
各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない．
あるiに対して&lt;code&gt;front_sum&lt;/code&gt;を0からi-1までの和，&lt;code&gt;back_sum&lt;/code&gt;をn-i+1からnまでの和とすると，
i個選択する時の組み合わせによって得られる和は&lt;code&gt;i * 10^100 + front_sum&lt;/code&gt;から&lt;code&gt;i * 10^100 + back_sum&lt;/code&gt;までの間に収まる．
つまり，&lt;code&gt;back_sum - front_sum + 1&lt;/code&gt;通りになる．
&lt;code&gt;front_sum&lt;/code&gt;と&lt;code&gt;back_sum&lt;/code&gt;は累積和で取れるので，iをKからNまで動かして足し合わせれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---active-infants&#34;&gt;E - Active Infants&lt;/h2&gt;
&lt;p&gt;原始的なDP（ほんまか？）．&lt;br&gt;
活発度が高い順に左か右に移動させる．
活発度を降順にソートした時，&lt;code&gt;dp[i][j]&lt;/code&gt;を，&lt;strong&gt;(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさ&lt;/strong&gt;という風に考える．
そうすると，&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;strong&gt;左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させる&lt;/strong&gt;か&lt;strong&gt;左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させる&lt;/strong&gt;の嬉しさが大きい方になる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacでIntelliJを使っているとクラッシュする問題と解決法</title>
      <link>https://t45k.github.io/blog/fix_mac_fault/</link>
      <pubDate>Mon, 13 Apr 2020 17:38:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/fix_mac_fault/</guid>
      <description>&lt;p&gt;MacBook Air 2020を買いました．詳しくは&lt;a href=&#34;https://t45k.github.io/blog/macbook_air&#34;&gt;ここ&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;普段はJavaやKotlinを書いているので迷いなくIntelliJ IDEAをインストールしたのですが，どうも挙動がおかしい．&lt;br&gt;
というのも，結構な頻度でIntelliJがクラッシュするし，場合によってはOSがクラッシュ強制的に再起動がかかります．
ひどい時にはOSがクラッシュして再起動がかかり，それが開けた2分後に再びクラッシュしたこともあります．&lt;/p&gt;
&lt;p&gt;実は&lt;a href=&#34;https://t45k.github.io/blog/line&#34;&gt;LINEのインターン&lt;/a&gt;で借りていたMacBook Pro 15inchでも似たような問題が起こっていたので，2度目の経験でした．&lt;br&gt;
インターンで借りていたパソコンは5日間で返すので我慢して使っていましたが，今回は長らく使っていく予定なので流石に直す必要がありました．&lt;/p&gt;
&lt;p&gt;修理も視野に入れながら解決法を探しました．&lt;/p&gt;
&lt;h2 id=&#34;解決法&#34;&gt;解決法&lt;/h2&gt;
&lt;p&gt;結論からいうと原因は分かりませんでしたが()，&lt;strong&gt;OSを再インストール&lt;/strong&gt;することで解決しました．詳しくは&lt;a href=&#34;https://support.apple.com/ja-jp/HT204904&#34;&gt;こちら&lt;/a&gt;．&lt;br&gt;
原因が分からないので全ての人がこれで直るかは分かりませんが，OS再インスコでデータが消えることはないため真っ先に試す価値はあります．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacBook Airを購入した話</title>
      <link>https://t45k.github.io/blog/macbook_air/</link>
      <pubDate>Mon, 13 Apr 2020 17:21:02 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/macbook_air/</guid>
      <description>&lt;h3 id=&#34;念願のmacbook-airを購入しました&#34;&gt;念願のMacBook Airを購入しました!&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/mba.JPG&#34; alt=&#34;mba&#34;&gt;&lt;/p&gt;
&lt;p&gt;構成は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU: 1.1GHzクアッド&lt;/li&gt;
&lt;li&gt;メモリ: 16GB&lt;/li&gt;
&lt;li&gt;SSD: 256GB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数ヶ月後に出ると噂のMacBook Proを待っている人もいるかもしれませんが，僕は以下のような理由でmbaを選びました．&lt;/p&gt;
&lt;h2 id=&#34;1---もう待てなかったから&#34;&gt;1 - もう待てなかったから&lt;/h2&gt;
&lt;p&gt;ずっと新しいmacが欲しいと思っていたのでこれ以上待てませんでした&lt;/p&gt;
&lt;h2 id=&#34;2---そこまでスペックを必要としていないかったから&#34;&gt;2 - そこまでスペックを必要としていないかったから&lt;/h2&gt;
&lt;p&gt;研究室からmbpを借りていますし，研究などでマシンパワーが必要な時は研究室のワークステーションを使えば良いだけなので&lt;/p&gt;
&lt;h2 id=&#34;3---touch-barが嫌いだから&#34;&gt;3 - Touch barが嫌いだから&lt;/h2&gt;
&lt;p&gt;バタフライキーボードはともかく，Touch barは賛否両論ありますが，僕はあまり好きになれませんでした．
たまに反応しなくなったりするし．&lt;/p&gt;
&lt;h2 id=&#34;4---安いから&#34;&gt;4 - 安いから&lt;/h2&gt;
&lt;p&gt;税込み13万で買えました．
mbpはこんなものじゃすまないと思います．&lt;/p&gt;
&lt;p&gt;理由としてはこんなところです．
付け加えるなら，自分の理想にとても近かったというのもあります．
これは去年の12月のツイート&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;はよmacbook air，13インチ，cpu4コア，RAM16GB，SSD256GB，ファンクションキー，シザーキーボードで10万くらいのやつ出てくれや&lt;/p&gt;&amp;mdash; task (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1203581420871905280?ref_src=twsrc%5Etfw&#34;&gt;December 8, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;使い心地&#34;&gt;使い心地&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://t45k.github.io/blog/fix_mac_fault&#34;&gt;ある一点&lt;/a&gt;を除いたら最高です（その一点も結局解決しました）．&lt;/p&gt;
&lt;p&gt;主にmbpとの比較になるのですが，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;軽い&lt;/li&gt;
&lt;li&gt;薄い&lt;/li&gt;
&lt;li&gt;開けやすい(mbaは切り欠けが下まで貫通している)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;みたいなところです．&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;こうなりました．
&lt;img src=&#34;https://t45k.github.io/img/blog/stecker.JPG&#34; alt=&#34;stecker&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC162の解説</title>
      <link>https://t45k.github.io/kyopuro/abc162/</link>
      <pubDate>Mon, 13 Apr 2020 16:57:30 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc162/</guid>
      <description>&lt;p&gt;祝参加者1万人越え．無念の4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC162&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---lucky-7&#34;&gt;A - Lucky 7&lt;/h2&gt;
&lt;p&gt;やるだけ．文字列で読み込んで&lt;code&gt;String#contains&lt;/code&gt;を使うと早い．&lt;/p&gt;
&lt;h2 id=&#34;b---fizzbuzz-sum&#34;&gt;B - FizzBuzz Sum&lt;/h2&gt;
&lt;p&gt;これもやるだけ．&lt;code&gt;LongStream&lt;/code&gt;できれいに書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;LongStream.rangeClosed(1, scanner.nextInt())
    .filter(i -&amp;gt; i % 3 != 0 &amp;amp;&amp;amp; i % 5 != 0)
    .sum();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---sum-of-gcd-of-tuples-easy&#34;&gt;C - Sum of gcd of Tuples (Easy)&lt;/h2&gt;
&lt;p&gt;三重ループを回すだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---rgb-triplets&#34;&gt;D - RGB Triplets&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;N &amp;lt;= 4,000&lt;/code&gt;なので二重ループで回すことを考える．
ある座標以降のそれぞれの色が何個あるかを記録する．
これは後ろから累積和をとることで可能．
こうすることで，例えば&lt;code&gt;i&lt;/code&gt;が赤色，&lt;code&gt;j&lt;/code&gt;が緑色のとき，&lt;code&gt;j+1&lt;/code&gt;以降の青色の個数を&lt;code&gt;O(1)&lt;/code&gt;で得られる．
また，&lt;code&gt;k-j ≠ j-i&lt;/code&gt;の条件を満たすために，k-j = j-iとなるkに対して&lt;code&gt;(j+1以降の数) - (k以降の数) + (k+1以降の数)&lt;/code&gt;と計算すれば良い(累積和の性質から)．&lt;/p&gt;
&lt;h2 id=&#34;e---sum-of-gcd-of-tuples-hard&#34;&gt;E - Sum of gcd of Tuples (Hard)&lt;/h2&gt;
&lt;p&gt;解法は思いついていたが計算量的にダメだと思っていて放置していたやつ&lt;br&gt;．
解答が詳しいのでそちらを参照．
繰り返し二乗法などを使うと速くなる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC161の解説</title>
      <link>https://t45k.github.io/kyopuro/abc161/</link>
      <pubDate>Sat, 04 Apr 2020 22:53:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc161/</guid>
      <description>&lt;p&gt;100-200-300-400-600の5完．
人生初のオンサイト600点問題AC．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC161&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---abc-swap&#34;&gt;A - ABC Swap&lt;/h2&gt;
&lt;p&gt;Z，X，Yを順に出力するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---popular-vote&#34;&gt;B - Popular Vote&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
割り算の結果を比較するときは，&lt;code&gt;a &amp;gt; b / c&lt;/code&gt;ではなく&lt;code&gt;a * c &amp;gt; b&lt;/code&gt;のように書いたほうが正確．&lt;/p&gt;
&lt;h2 id=&#34;c---replacing-integer&#34;&gt;C - Replacing Integer&lt;/h2&gt;
&lt;p&gt;方針立てるのに時間かかった問題．&lt;br&gt;
直感的には分かりづらいけど以下のように言い換えられる(chokudaiさんのツイート)．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C問題、数学の問題といえばそうなんだけど、「無限に長いすごろくがあります。ゴールまでの距離がxです。Kマスずつ進めますが、ゴールを通り過ぎてしまう場合は折り返します。最もゴールに近づく時の残りマス数を答えなさい」みたいにすると、まぁ一応ちゃんとしたストーリーはつくよね。&lt;/p&gt;&amp;mdash; chokudai(高橋 直大)🌸🍆🍡 (@chokudai) &lt;a href=&#34;https://twitter.com/chokudai/status/1246435428476973063?ref_src=twsrc%5Etfw&#34;&gt;April 4, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;というわけで，&lt;code&gt;N % K&lt;/code&gt;と&lt;code&gt;(N - (N % K)) % K&lt;/code&gt;の小さい方を求める．&lt;/p&gt;
&lt;h2 id=&#34;d---lunlun-number&#34;&gt;D - Lunlun Number&lt;/h2&gt;
&lt;p&gt;想定解が天才すぎる．愚直に解いた．&lt;br&gt;
i番目の数字に対して，i + 1番目の数字を次のように決める．各桁を下から順番に見ていく．もし見ている桁が9でなく，かつ次の桁の数字より1小さいか同じなら，その桁をインクリメントし，それ以降の桁をルンルン数かつ最小となるように調整(つまり，&amp;lsquo;上の桁 - 1&amp;rsquo;か&#39;0&amp;rsquo;)した値がi + 1番目の数になる．どの桁も条件に当てはまらなければ，一番大きい桁をインクリメントする．&lt;br&gt;
各桁を確認，操作する場合は，数字をいったんchar型配列にするとやりやすいかも．&lt;/p&gt;
&lt;h2 id=&#34;e---yutori&#34;&gt;E - Yutori&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;br&gt;
前から貪欲と後ろから貪欲の結果を比較するだけ．解説に登場する配列L，Rを求めなくても，二分探索しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;f---division-or-substraction&#34;&gt;F - Division or Substraction&lt;/h2&gt;
&lt;p&gt;E問題よりACが多いF問題．&lt;br&gt;
まずNに対して以下の数字は必ず条件を満たす&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2: 偶数は割っていくと，奇数は引いていくと最終的に1になるため&lt;/li&gt;
&lt;li&gt;N - 1: 引くと1になるため&lt;/li&gt;
&lt;li&gt;N: 割ると1になるため&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それ以外に関しては関しては次のようになる．
ちなみに&amp;quot;何回か引いた後にに，何回か割る&amp;quot;という操作は発生しない．&lt;/p&gt;
&lt;h3 id=&#34;引くことしか考えない&#34;&gt;引くことしか考えない&lt;/h3&gt;
&lt;p&gt;N % L == 1 となるLを考えればよい．
このLは，N - 1の約数列挙を行うことで求まる．&lt;/p&gt;
&lt;h3 id=&#34;何回か割って何回か引く&#34;&gt;何回か割って，何回か引く&lt;/h3&gt;
&lt;p&gt;これは 3 ~ sqrt(N) (sqrt(N)を超過すると，1回割っただけで割る数を下回ってしまうので考えなくて良い)の各値iに対して，余りが0である間可能な限りiで割った後に，&lt;code&gt;N % i == 1&lt;/code&gt;となるかを確認すれば良い．&lt;/p&gt;
&lt;p&gt;これらの結果を足し合わせるだけ．
この解法だと&lt;strong&gt;2&lt;/strong&gt;がコーナーケースになることに注意．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderで水色になりました</title>
      <link>https://t45k.github.io/blog/nyusui/</link>
      <pubDate>Sun, 29 Mar 2020 00:16:31 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/nyusui/</guid>
      <description>&lt;p&gt;先日行われた&lt;a href=&#34;https://atcoder.jp/contests/abc160&#34;&gt;ABC160&lt;/a&gt;にて無事に入水を果たしたのでポエムを書きます．
&lt;img src=&#34;https://t45k.github.io/img/blog/nyusui.png&#34; height=&#34;75%&#34; width=&#34;75%&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;感じたこと&#34;&gt;感じたこと&lt;/h2&gt;
&lt;p&gt;一つの目標だった水色に到達してほっとしています．
人によっては10回かそこらでなる人もいる中，53回目でようやくなれた自分の才能とセンスのなさには本当に辟易しています．
精進が大事．
蟻本は最初の章しか読めてないけど結構役に立ちました．&lt;/p&gt;
&lt;h2 id=&#34;次は&#34;&gt;次は&lt;/h2&gt;
&lt;p&gt;せっかくなので青色を目指します．
ここ2回のABCは青パフォが出てるので，この調子で頑張っていきたいです．&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;毎回楽しいコンテストを開催してくれているAtCoder社と，その問題を用意してくれているWriter，Testerの皆様に心から感謝します．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC160の解説</title>
      <link>https://t45k.github.io/kyopuro/abc160/</link>
      <pubDate>Sat, 28 Mar 2020 23:27:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc160/</guid>
      <description>&lt;p&gt;5完．&lt;a href=&#34;https://github.com/T45K/tree/master/AtCoder/ABC/ABC160&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---coffee&#34;&gt;A - Coffee&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．&lt;code&gt;String#charAt&lt;/code&gt;を使う&lt;/p&gt;
&lt;h2 id=&#34;b---golden-coins&#34;&gt;B - Golden Coins&lt;/h2&gt;
&lt;p&gt;なるべく多くの500円に換金した方が良いので，まずは&lt;code&gt;X&lt;/code&gt;を500で割る．
余りを50で割って，それぞれの商に1000と5を掛けて出力．&lt;/p&gt;
&lt;h2 id=&#34;c---traveling-salesman-around-lake&#34;&gt;C - Traveling Salesman around Lake&lt;/h2&gt;
&lt;p&gt;ある家からその一つ手前の家までをぐるっと一周回ってくるのが最適となる．
1番目の家からN番目の家までに移動距離は&lt;code&gt;Ai - AN&lt;/code&gt;，それ以外の家iから家i - 1までは&lt;code&gt;K - Ai + Ai-1&lt;/code&gt;になるので，その中の最小値が答え．&lt;/p&gt;
&lt;h2 id=&#34;d---line&#34;&gt;D - 	Line++&lt;/h2&gt;
&lt;p&gt;ワーシャルフロイドっぽい問題．&lt;br&gt;
まず初めにX，Yを経由しない場合の全ての頂点間の距離を求める．
これはグラフを隣接行列で表すと&lt;code&gt;graph[i][j] = |i - j|&lt;/code&gt;となる．&lt;br&gt;
次に，XまたはYを経由した場合を考えた上で，全ての頂点間の最短距離を求める．
これは&lt;code&gt;graph[i][j] = min(graph[i][j], graph[i][X] + graph[X][j])&lt;/code&gt;となる．&lt;br&gt;
最後に，隣接行列の中で各距離の出現回数を記録し，それを出力する．&lt;/p&gt;
&lt;h2 id=&#34;e---red-and-green-apples&#34;&gt;E - Red and Green Apples&lt;/h2&gt;
&lt;p&gt;貪欲にやるだけ．&lt;br&gt;
美味しさを最大化したいとき，赤リンゴを降順に並べたときのX+1つ目以降と緑リンゴを降順に並べたときののY+1つ目以降は捨ててもよい．
後はそれぞれのリンゴの小さいものを順番に無色のものと入れ替えるだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC159の解説</title>
      <link>https://t45k.github.io/kyopuro/abc159/</link>
      <pubDate>Sun, 22 Mar 2020 22:48:22 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc159/</guid>
      <description>&lt;p&gt;奇跡的に5完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC159&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---the-number-of-even-pairs&#34;&gt;A - The Number of Even Pairs&lt;/h2&gt;
&lt;p&gt;和が正になるのは&lt;code&gt;even + even&lt;/code&gt;か&lt;code&gt;odd + odd&lt;/code&gt;の時なので，偶奇それぞれに対して組み合わせ(&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;)を計算して足し合わせる．&lt;/p&gt;
&lt;h2 id=&#34;b---string-palindrome&#34;&gt;B - String Palindrome&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．
回文系の問題は以下のようなメソッドを作っとくと便利かも．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; isPalindrome(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; end, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; ; i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (start + i &amp;gt;= end - i) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.charAt(start + i) != s.charAt(end - i)) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---maximum-volume&#34;&gt;C - Maximum Volume&lt;/h2&gt;
&lt;p&gt;Lの1/3の3乗&lt;/p&gt;
&lt;h2 id=&#34;d---banned-k&#34;&gt;D - Banned K&lt;/h2&gt;
&lt;p&gt;考えた方としては，初めに何も取り除かないときの組み合わせの総数を求めておいて，それを使って取り除いた数字の組み合わせを計算し直すという感じ．&lt;br&gt;
初めに全ての組み合わせの和を計算する．
これは連想配列を用いてどの数字が何回出てくるかを数え上げて，各回数に対して&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を計算して足し合わせるだけ．
次に，各数字を取り除いた場合を考える．
取り除いた数字の組み合わせは&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;になってしまうので，総和から&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を引いて&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;を足した数が求めたい数字になる．&lt;/p&gt;
&lt;h2 id=&#34;e---dividing-chocolate&#34;&gt;E - Dividing Chocolate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;が大きなヒント．&lt;br&gt;
&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;から，横方向に切る組み合わせは全探索を使える(&lt;code&gt;2 ^ 10 ≒ 10 ^ 3&lt;/code&gt;)．
横方向に切った結果から，Kを超えないように縦方向に切らないといけない回数を貪欲に算出できる．&lt;/p&gt;
&lt;h2 id=&#34;f----knapsack-for-all-segments&#34;&gt;F -  Knapsack for All Segments&lt;/h2&gt;
&lt;p&gt;解説AC．なぜか解説通りに実装するとTLEになったため別の方針を採用(&lt;a href=&#34;https://atcoder.jp/contests/abc159/submissions/11164623&#34;&gt;https://atcoder.jp/contests/abc159/submissions/11164623&lt;/a&gt;)．&lt;br&gt;
&lt;code&gt;Ax1 + Ax2 + ... Axn = S&lt;/code&gt;を満たす時，&lt;code&gt;s = 1, 2, ..., x1&lt;/code&gt;，&lt;code&gt;e = xn, xn + 1, ..., N&lt;/code&gt;とすると，sからeまでの文字列は全て条件を満たす．
そこで，始点と終点を決めるためのDPを行う．&lt;br&gt;
答えを表す変数&lt;code&gt;ans&lt;/code&gt;，dp[N][S]を用意し，次の場合分けを考える．j = 0 .. S - 1 に対して，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;場合分け&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Ai を足さない&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;dp[N][j] = dp[N - 1][j]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Ai を足す&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Ai を始点にする場合 dp[N][j] += dp[N - 1][j] + i&lt;br&gt;Ai を始点にしない場合 dp[N][j + Ai] += dp[N - 1][j]&lt;br&gt;Ai を終点にする場合 answer += dp[N - 1][S - Ai] * (n - i)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>&lt;script async src=&#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;
&lt;p&gt;1完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/AGC/AGC043&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---range-flip-find-route&#34;&gt;A - Range Flip Find Route&lt;/h2&gt;
&lt;p&gt;全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;&lt;/p&gt;
&lt;p&gt;右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）．
なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる．
ダイクストラ法を使うと計算量は頂点数&lt;code&gt;V&lt;/code&gt;と辺数&lt;code&gt;E&lt;/code&gt;に対して&lt;code&gt;O(V * log(E))&lt;/code&gt;となる．
今回の頂点数Vは&lt;code&gt;V &amp;lt;= H * W = 10 ^ 4&lt;/code&gt;となる．
また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;b---123-triangle&#34;&gt;B - 123 Triangle&lt;/h2&gt;
&lt;p&gt;誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)&lt;/p&gt;
&lt;p&gt;答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する．
各aは先に1引いといても問題ない．
偶奇判定なので，&lt;code&gt;abs(a - b)&lt;/code&gt;ではなく&lt;code&gt;a xor b&lt;/code&gt;で良い．
そうすると，
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mo&gt;(&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,2&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mo&gt;&amp;hellip;&lt;/mo&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,n&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;)&lt;/mo&gt;
&lt;mo&gt;%&lt;/mo&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/math&gt;
となる．
そのため，各組み合わせを計算すれば良い．&lt;br&gt;
今回は偶奇が欲しいので，各組み合わせの2で割った余りだけで十分である．
そこで&lt;a href=&#34;https://mathtrain.jp/lucastheorem&#34;&gt;&lt;strong&gt;Lucasの定理&lt;/strong&gt;&lt;/a&gt;を用いる(リンク参照)．
定理に従うと手順はこう．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初めに&lt;code&gt;n - 1&lt;/code&gt;を二進数に変換する&lt;/li&gt;
&lt;li&gt;各aを二進数に変換する(&lt;code&gt;n - 1&lt;/code&gt;の二進数表現と桁を揃えることに注意)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n - 1&lt;/code&gt;と&lt;code&gt;a&lt;/code&gt;の二進数表現の各桁(それぞれm，nとする)に対して組み合わせ(つまり，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;m&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;
)を計算する(各桁は0か1なので，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;の時だけ0でそれ以外は1になる)&lt;/li&gt;
&lt;li&gt;組み合わせの計算結果をかけ合わせる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これで
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;/math&gt;
の偶奇が出るので，答えが1かどうかが分かる．&lt;br&gt;
答えが奇数の場合は，数字列中に1が含まれていれば答えは0となる&lt;br&gt;
それでも決まらなければ，各aを2で割った上でもう一度偶奇を計算すると0か2が確定する．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>みんな元気。読了</title>
      <link>https://t45k.github.io/blog/all_fine/</link>
      <pubDate>Fri, 20 Mar 2020 12:00:53 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/all_fine/</guid>
      <description>&lt;p&gt;&lt;strong&gt;みんな大丈夫。みんな元気。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「みんな元気。」を読みました．&lt;a href=&#34;https://www.amazon.co.jp/%E3%81%BF%E3%82%93%E3%81%AA%E5%85%83%E6%B0%97%E3%80%82-%E8%88%9E%E5%9F%8E%E7%8E%8B%E5%A4%AA%E9%83%8E-ebook/dp/B00CL6N332/ref=sr_1_5?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;dchild=1&amp;amp;keywords=%E3%81%BF%E3%82%93%E3%81%AA%E5%85%83%E6%B0%97&amp;amp;qid=1584673351&amp;amp;sr=8-5&#34;&gt;Amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この本は，表題である「みんな元気。(副題: Cuckoos &amp;amp; The Invisible Devil)」と短編4編で構成されています．
例によってきっかけはDJ Technorch．&lt;/p&gt;
&lt;p&gt;粗筋は，空飛ぶ家族が主人公の妹を拐いに来てなんやかんやある感じです．
相変わらず難解だった気がします．
この物語は，「選択」が主題の一つだと思います．
副題のカッコウから，拐われた妹が実は托卵だったみたいな展開を予想しましたが全然そんなことありませんでした．
風呂敷をめちゃくちゃに広げたうえで畳むことなく急に終わる感じなのですが，終わり方が納得できるというかとても爽やかでした．&lt;/p&gt;
&lt;p&gt;短編集の中では，「スクールアタック・シンドローム」が好きです．&lt;/p&gt;
&lt;p&gt;なんとなく，舞城王太郎特有のスピード感的なものを理解してきた気がしました．&lt;/p&gt;
&lt;p&gt;次はおそらく「九十九十九」を読みます．&lt;/p&gt;
&lt;p&gt;最後に&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/-71fQjkZ0X8&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/pana20&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---kth-term&#34;&gt;A - Kth Term&lt;/h2&gt;
&lt;p&gt;実装するだけ．
Javaの場合は問題文をコピペして&lt;code&gt;final int[] array = {1, 1, ...};&lt;/code&gt;と宣言すると早い．&lt;/p&gt;
&lt;h2 id=&#34;b---bishop&#34;&gt;B - Bishop&lt;/h2&gt;
&lt;p&gt;ここに一番時間を吸われた．&lt;br&gt;
問題例を見ると最終的に&lt;code&gt;(h * w + 1) / 2&lt;/code&gt;でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．&lt;/p&gt;
&lt;h2 id=&#34;c---sqrt-inequality&#34;&gt;C - Sqrt Inequality&lt;/h2&gt;
&lt;p&gt;ここにも時間を吸われた．&lt;br&gt;
&lt;code&gt;Math#sqrt&lt;/code&gt;を使うと解けそうな気がするが，精度の都合上間違いになることがある．
今回は式変換を行うと&lt;code&gt;4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2ca&lt;/code&gt;に持っていけるので，そこに代入するだけ．
あるいは&lt;code&gt;BigDecimal&lt;/code&gt;を使っても大丈夫らしい．&lt;/p&gt;
&lt;h2 id=&#34;d---string-equivalence&#34;&gt;D - String Equivalence&lt;/h2&gt;
&lt;p&gt;偶然通った問題．&lt;br&gt;
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;e---three-substrings&#34;&gt;E - Three Substrings&lt;/h2&gt;
&lt;p&gt;全探索の問題．&lt;a href=&#34;https://www.hamayanhamayan.com/entry/2020/03/15/002311&#34;&gt;ここ&lt;/a&gt;を参考にした．&lt;br&gt;
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう．
以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．&lt;br&gt;
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる．
コードだとこんな感じ．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] init(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; length, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String b) {&lt;span style=&#34;font-style:italic&#34;&gt;// 配列の初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] array = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[length]; &lt;span style=&#34;font-style:italic&#34;&gt;// lengthは十分大きい値
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    Arrays.fill(array, &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;);
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; a.length(); i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; b.length() &amp;amp;&amp;amp; i + j &amp;lt; a.length(); j++) {
            &lt;span style=&#34;font-style:italic&#34;&gt;// 文字列aの位置i以降がbと被っているかの確認
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!match(a.charAt(i + j), b.charAt(j))) { 
                array[i] = &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
                &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            }
        }
    }
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; array;
}
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; match(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; b) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; a == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || b == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || a == b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;それぞれの結果をab，ac，bcとする．&lt;br&gt;
これらの配列の&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab[i] == true&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc[j] == true&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に対して&lt;code&gt;ac[i + j] == true&lt;/code&gt;となれば，その配置は矛盾がないことになる．
図だとこんな感じ&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://t45k.github.io/img/kyopuro/pana2020_e.png&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;iの探索範囲は0からaの長さ，jの探索範囲はbの長さかiからaの終端までの長さの長い方になる．&lt;br&gt;
あとは長さの最小値を出すだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc061/tasks/abc061_d&#34;&gt;ABC061 D - Score Attack&lt;/a&gt;の別解．&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/ABC061/D/MainAlt.java&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;問題内容&#34;&gt;問題内容&lt;/h2&gt;
&lt;p&gt;正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題．
解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている．
また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;別解&#34;&gt;別解&lt;/h2&gt;
&lt;p&gt;最長路検出と閉路検出について異なる方法を紹介する．&lt;/p&gt;
&lt;h3 id=&#34;最長路検出&#34;&gt;最長路検出&lt;/h3&gt;
&lt;p&gt;今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である．
BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる．
BFSであることから，n ^ 2 回繰り返せば十分である．&lt;/p&gt;
&lt;h3 id=&#34;閉路検出&#34;&gt;閉路検出&lt;/h3&gt;
&lt;p&gt;解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない．
各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていれば&lt;code&gt;inf&lt;/code&gt;を出力すれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>&lt;p&gt;四完．&lt;a href=&#34;https://github.com/t45k/kyopuro/master/tree/abc158&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---station-and-bus&#34;&gt;A - Station and Bus&lt;/h2&gt;
&lt;p&gt;連想配列にぶちこむ．&lt;/p&gt;
&lt;h2 id=&#34;b---count-balls&#34;&gt;B - Count Balls&lt;/h2&gt;
&lt;p&gt;n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．&lt;/p&gt;
&lt;h2 id=&#34;c---tax-increase&#34;&gt;C - Tax Increase&lt;/h2&gt;
&lt;p&gt;1から20,000くらいまでの整数が条件を満たすか全探索．&lt;/p&gt;
&lt;h2 id=&#34;d---string-formation&#34;&gt;D - String Formation&lt;/h2&gt;
&lt;p&gt;現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する．
クエリが&lt;code&gt;1&lt;/code&gt;ならフラグ反転，クエリが&lt;code&gt;2&lt;/code&gt;の場合は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正順ならクエリ通りに文字追加&lt;/li&gt;
&lt;li&gt;逆順ならクエリとは逆に文字追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をやる．
最終的にフラグを参照してから正しい方向で出力．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StringBuilder#insert&lt;/code&gt;を使うとTLEになりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>好き好き大好き長愛してる。 読了</title>
      <link>https://t45k.github.io/blog/love_love_love_you_i_love_you/</link>
      <pubDate>Tue, 03 Mar 2020 16:20:18 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/love_love_love_you_i_love_you/</guid>
      <description>&lt;p&gt;&lt;strong&gt;愛は祈りだ。僕は祈る。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「好き好き大好き超愛してる。」を読みました．&lt;a href=&#34;https://www.amazon.co.jp/%E5%A5%BD%E3%81%8D%E5%A5%BD%E3%81%8D%E5%A4%A7%E5%A5%BD%E3%81%8D%E8%B6%85%E6%84%9B%E3%81%97%E3%81%A6%E3%82%8B%E3%80%82-%E8%AC%9B%E8%AB%87%E7%A4%BE%E6%96%87%E5%BA%AB-%E8%88%9E%E5%9F%8E-%E7%8E%8B%E5%A4%AA%E9%83%8E/dp/4062760819/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;keywords=%E5%A5%BD%E3%81%8D%E5%A5%BD%E3%81%8D%E5%A4%A7%E5%A5%BD%E3%81%8D%E8%B6%85%E6%84%9B%E3%81%97%E3%81%A6%E3%82%8B&amp;amp;qid=1583220082&amp;amp;sr=8-1&#34;&gt;Amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;きっかけはDJ Technorchの楽曲「Love Love Love You I Love You」．&lt;br&gt;
舞城王太郎作品は，以前「ディスコ探偵水曜日」を読んでめちゃくちゃ読みにくいなと思っていたので，読む前に少し構えました．&lt;br&gt;
「愛は祈りだ。」の一文から始まるこの本は，一貫して「愛」と「物語」についての小説です．
一文目がこれほど全体を象徴している作品は個人的にはこれが初めてで，おそらく長く記憶に残るんだろうなぁという感じです（余談ですが，最後の一文が一番記憶に残っている作品は西尾維新の「クビシメロマンチスト」）．
読みやすい方ではありますが，理解するのは難しいと感じました．&lt;/p&gt;
&lt;p&gt;次は「みんな元気。」を読みます．&lt;/p&gt;
&lt;p&gt;最後に，きっかけとなった楽曲を貼っときます．&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lTrDY-60mMg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>&lt;p&gt;なんとか四完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC157&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---duplex-printing&#34;&gt;A - Duplex Printing&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt;に1足して2で割るだけ&lt;/p&gt;
&lt;h2 id=&#34;b---bingo&#34;&gt;B - Bingo&lt;/h2&gt;
&lt;p&gt;実装するだけだが実装量が多くなりがちな問題&lt;/p&gt;
&lt;h2 id=&#34;c---guess-the-number&#34;&gt;C - Guess The Number&lt;/h2&gt;
&lt;p&gt;条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更．
桁数を満たす整数を昇順に条件を満たすか確認する．
余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．&lt;/p&gt;
&lt;h2 id=&#34;d---friend-suggestions&#34;&gt;D - Friend Suggestions&lt;/h2&gt;
&lt;p&gt;Union-Find Treeで殴る問題．
友達関係を取得する時にUnion-Find Treeを構築します．
同時に，それぞれの人が何人友達がいるかを記録します．&lt;br&gt;
ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します．
この時，友達候補でない人を記録する必要はありません．&lt;br&gt;
最終的に，Union-Find Treeから&lt;strong&gt;自分，友達，ブロック関係を含めた自分と繋がっている人&lt;/strong&gt;を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．&lt;br&gt;
余談ですが，&lt;code&gt;Set&lt;/code&gt;をfor文で回すと異様に遅いので，for文を使う場合は&lt;code&gt;List&lt;/code&gt;を使った方が良いです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>&lt;p&gt;最小全域木という概念を知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;最小全域木とは&#34;&gt;最小全域木とは&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanningu Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．&lt;/em&gt;（蟻本より）&lt;br&gt;
つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc065/tasks/arc076_b&#34;&gt;ABC065-D&lt;/a&gt;がこの問題に該当します．&lt;/p&gt;
&lt;h2 id=&#34;解き方&#34;&gt;解き方&lt;/h2&gt;
&lt;p&gt;有名なアルゴリズムとして，クラスカル法とプリム法があります．
今回はプリム法を紹介します．&lt;br&gt;
プリム法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります．
ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// edges は Edge(int label1, int label2, long cost) のリスト
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost));
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; UnionFindTree unionFindTree = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; UnionFindTree(n); &lt;span style=&#34;font-style:italic&#34;&gt;// 要素数nのUnion-Find Treeを構築
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;long&lt;/span&gt; sum = 0;
&lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Edge edge : edges) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!unionFindTree.isSame(edge.label1, edge.label2)) {
        unionFindTree.unit(edge.label1, edge.label2);
        sum += edge.cost;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;辺のソートに一番計算量を食われます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>&lt;p&gt;ワーシャルフロイド法というアルゴリズムを知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;ワーシャルフロイド法とは&#34;&gt;ワーシャルフロイド法とは&lt;/h2&gt;
&lt;p&gt;グラフのある一点から任意の点への最短距離を求めるアルゴリズム．
計算量は点の個数nに対してO(n^3)．
似たようなアルゴリズムに&lt;strong&gt;ダイクストラ法&lt;/strong&gt;があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである．
計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．&lt;/p&gt;
&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;
&lt;p&gt;このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単．
二次元配列を用いた例がこちら．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;void&lt;/span&gt; main(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] args) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[][] graph = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[n][n];
    &lt;span style=&#34;font-style:italic&#34;&gt;// 初めに無限大の値で各要素を初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) {
        Arrays.fill(graph[i], Integer.MAX_VALUE / 2); &lt;span style=&#34;font-style:italic&#34;&gt;// Integer.MAX_VALUEでないことに注意
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        graph[i][i] = 0;
    }

    &lt;span style=&#34;font-style:italic&#34;&gt;// グラフの各辺を与えられた値に変更
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;font-style:italic&#34;&gt;// ここからワーシャルフロイド
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; k = 0; k &amp;lt; graph.length; k++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 出発する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; graph.length; j++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 到着する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;                graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点をとった方が短となるか判定
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三重ループを回すだけである．
注意点は，グラフの初期化時に&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;を代入しないこと．
&lt;code&gt;Math.min&lt;/code&gt;のタイミングでオーバーフローするため&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC156&#34;&gt;解答&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---beginner&#34;&gt;A - Beginner&lt;/h2&gt;
&lt;p&gt;算数&lt;/p&gt;
&lt;h2 id=&#34;b---digits&#34;&gt;B - Digits&lt;/h2&gt;
&lt;p&gt;nが0になるまでkで割り続ける&lt;/p&gt;
&lt;h2 id=&#34;c---rally&#34;&gt;C - Rally&lt;/h2&gt;
&lt;p&gt;座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．&lt;/p&gt;
&lt;h2 id=&#34;d---bouquet&#34;&gt;D - Bouquet&lt;/h2&gt;
&lt;p&gt;組み合わせの問題．&lt;br&gt;
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く．
組み合わせの総和は2^n - 1になる．
a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/util/Utility.java#L360-L390&#34;&gt;modInvのJava実装の例&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>&lt;p&gt;無念の三冠．&lt;/p&gt;
&lt;h2 id=&#34;a---poor&#34;&gt;A - Poor&lt;/h2&gt;
&lt;p&gt;重複を調べる問題．&lt;br&gt;
愚直に比較しても良いけど，Setを使うのが早そう．&lt;br&gt;
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．&lt;/p&gt;
&lt;h2 id=&#34;b---papers-please&#34;&gt;B - Papers, Please&lt;/h2&gt;
&lt;p&gt;fizzbuzzみたいな問題．&lt;br&gt;
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．&lt;/p&gt;
&lt;h2 id=&#34;c---poll&#34;&gt;C - Poll&lt;/h2&gt;
&lt;p&gt;連想配列を使って数え上げる典型的な問題．&lt;br&gt;
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくは&lt;code&gt;Collections#sort&lt;/code&gt;)．
C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．&lt;/p&gt;
&lt;h2 id=&#34;d---pairs&#34;&gt;D - Pairs&lt;/h2&gt;
&lt;p&gt;E問題より難しいD問題．
以下の要素が重なりあってきつい．&lt;/p&gt;
&lt;h3 id=&#34;決め打ち二分探索&#34;&gt;決め打ち二分探索&lt;/h3&gt;
&lt;p&gt;決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す．
単調性とは，ある数 &lt;code&gt;x&lt;/code&gt; に対してその問題が成り立つならば，&lt;code&gt;x&lt;/code&gt; 以降の数字に対しても成り立つような性質を指す．&lt;br&gt;
　実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 &lt;code&gt;isOk(...)&lt;/code&gt; を用意する．
D問題だと&lt;strong&gt;ある値 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;K&lt;/code&gt; が与えられた時に，積が &lt;code&gt;x&lt;/code&gt; 以下となるペアの個数が &lt;code&gt;K&lt;/code&gt; 以上の場合は真&lt;/strong&gt;のようになる．&lt;br&gt;
　次に，二分探索の対象を用意する．このとき，始点は &lt;code&gt;isOk&lt;/code&gt; が偽となり，かつ終点は真となるような範囲を用意する．
今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので &lt;code&gt;0 ~ 10^18&lt;/code&gt; のようになる．&lt;br&gt;
　そして二分探索する．
二分探索では通常範囲を指定するが，この時始点は &lt;code&gt;isOk&lt;/code&gt; が偽，終点は真となることを意識する．
通常の二分探索と同じく対象範囲の真ん中の値(&lt;code&gt;(始点 + 終点) / 2&lt;/code&gt;)をとり，それの真偽を判定する．
真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する．
この操作で，常に始点は偽，終点は真となる．
最終的に始点と終点が連続した値になるため，その終点を解として出力する．&lt;br&gt;
　要約すると，&lt;code&gt;isOk()&lt;/code&gt; を満たす範囲の下界を求める操作だと言える．&lt;/p&gt;
&lt;h3 id=&#34;lower-bound--upper-bound&#34;&gt;Lower Bound / Upper Bound&lt;/h3&gt;
&lt;p&gt;Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた．
計算量もそこまで気にする必要はない．
今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある．
そのため，&lt;strong&gt;Lower Bound&lt;/strong&gt;や&lt;strong&gt;Upper Bound&lt;/strong&gt;を用いる必要がある．&lt;br&gt;
Lower Boundは指定した値&lt;strong&gt;以上&lt;/strong&gt;の要素が初めて出現する場所を取得する．&lt;br&gt;
一方，Upper Boundは指定した値&lt;strong&gt;より大きい要素&lt;/strong&gt;が初めて出現する場所を取得する．&lt;br&gt;
C++ではこれらが標準ライブラリとして提供されているが，Javaにはない．
Javaでは，&lt;code&gt;Collections#binarySearch&lt;/code&gt; の第三引数に以下の &lt;code&gt;Comparator&lt;/code&gt; オブジェクトを渡すことで実現できる．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// 例: List&amp;lt;Long&amp;gt; に対する Comparator
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; lowerBoundComparator = (x, y) -&amp;gt; x &amp;gt;= y ? 1 : -1;
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; upperBoundComparator = (x, y) -&amp;gt; x &amp;gt; y ? 1 : -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ちなみに，これに限らずJavaの標準ライブラリの &lt;code&gt;binarySearch&lt;/code&gt; の結果として負の数が帰ってきた場合，bit反転( &lt;code&gt;~&lt;/code&gt; 演算子)を使うと良い感じになる．&lt;/p&gt;
&lt;h3 id=&#34;負の数の大小比較&#34;&gt;負の数の大小比較&lt;/h3&gt;
&lt;p&gt;今回は負の数の大小を比較したり，負の数の席を求めたりする場面がある．
負の数の大小比較や掛け算は直感と反する場合が多く，考察段階では考えることが増えてしまうことが多い．
そのため，一度負の数を正の数に反転した上で大小比較し，最後に辻褄を合わすようにするのが良い．&lt;/p&gt;
&lt;h2 id=&#34;e---payment&#34;&gt;E - Payment&lt;/h2&gt;
&lt;p&gt;貪欲にやってもできそうな気がするけど，editorial見て正攻法で解答．&lt;br&gt;
いわゆる桁dpの問題(多分)．
今回は，その桁をちょうど払う状態(以降，&lt;strong&gt;just&lt;/strong&gt;)と1多く払う状態(以降，&lt;strong&gt;extra&lt;/strong&gt;)に分けて考える．
言い換えると，extraは繰り下がりを考慮した状態といえる．&lt;br&gt;
上の桁から考えていくと，状態遷移は以下のようになる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;その桁のjust = (前の桁のjust + その桁の数字) か (前の桁のextra + (10 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;li&gt;その桁のextra = (前の桁のjust + その桁の数字 + 1) か (前の桁のextra + (9 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを解いていくと答えになる．&lt;br&gt;
ちなみに，最後の桁は必ずjustとなること，また，最初の桁の前についてもjustとextraを考慮する(99を100で払ったり)ことに注意．&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/T45k/kyopuro/tree/master/AtCoder/ABC/ABC155&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>&lt;p&gt;A~Dまで．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/abc154&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---remaining-balls&#34;&gt;A - Remaining Balls&lt;/h2&gt;
&lt;p&gt;Uで分岐&lt;/p&gt;
&lt;h2 id=&#34;b---i-miss-you&#34;&gt;B - I miss you&amp;hellip;&lt;/h2&gt;
&lt;p&gt;入力の文字列の長さの回数&amp;rsquo;x&amp;rsquo;を出力&lt;/p&gt;
&lt;h2 id=&#34;c---distinct-or-not&#34;&gt;C - Distinct or Not&lt;/h2&gt;
&lt;p&gt;連想配列を使って数字が出現したかを確認&lt;/p&gt;
&lt;h2 id=&#34;d---dice-in-line&#34;&gt;D - Dice in Line&lt;/h2&gt;
&lt;p&gt;毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく．
あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---almost-everywhere-zero&#34;&gt;E - Almost Everywhere Zero&lt;/h2&gt;
&lt;p&gt;桁DP&lt;br&gt;
0でない(= 1 ~ 9)の数字がK回出る回数を数える．
桁を上から決定していき数え上げる．
桁の決定の仕方は，&lt;strong&gt;その桁を決める前の時点でNより小さいことが確定しているかどうか&lt;/strong&gt;で変わる．&lt;br&gt;
確定している場合を&lt;code&gt;dp[|N|][K + 1]&lt;/code&gt;と表現した時に，桁iでの状態遷移は以下のようになる&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;桁i-1での状態&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;桁iでの状態&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;確定している&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k]&lt;/code&gt;&lt;br&gt;0以外を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k - 1] * 9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;確定していない&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;桁iが0の時: Nより小さくすることはできないので何もしない&lt;br&gt;桁iが0でない時: &lt;strong&gt;1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができる&lt;/strong&gt;ので，桁i-1までに0以外の数字が出現した回数をjとすると&lt;code&gt;dp[i][j + 1] += (桁iの数字 - 1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．&lt;br&gt;
最終的な出力は&lt;code&gt;dp[|N| - 1][K] + ((N自身が条件を満たす)? 1 : 0)&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ICSE2020の面白そうな論文をピックアップしてみた</title>
      <link>https://t45k.github.io/blog/icse2020_abst/</link>
      <pubDate>Sat, 01 Feb 2020 18:59:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/icse2020_abst/</guid>
      <description>&lt;p&gt;ICSEはInternational Conference of Software Engineeringの略です．
ソフトウェア工学の国際学会の中で一番ランクが高い会議です．
会議自体は5月に行われるのですが，再録された論文一覧とアブストが公開されているので，
面白そうな論文をピックアップしてみました．&lt;/p&gt;
&lt;h2 id=&#34;is-rust-used-safely-by-software-developers&#34;&gt;Is Rust Used Safely by Software Developers?&lt;/h2&gt;
&lt;p&gt;RustはC，C++に取って代わることを目指した，メモリ安全性や実行速度を売りにしているプログラミング言語です．
その特徴から，ソフトウェア開発界隈からの注目度が高まりつつあります．&lt;br&gt;
この論文では，メモリ安全性を放棄する代わりにパフォーマンスを上げる &lt;strong&gt;Unsafe Rust&lt;/strong&gt; についての調査を行っています．&lt;/p&gt;
&lt;h2 id=&#34;securing-unsafe-rust-programs-with-xrust&#34;&gt;Securing UnSafe Rust Programs with XRust&lt;/h2&gt;
&lt;p&gt;これもRustの論文です．&lt;br&gt;
XRustという，Unsafe Rustを通常のRustに移行する手法を提案しています．&lt;br&gt;
ICSEに(Unsafe)Rustに関する論文が2本採択されていることから，ソフトウェア開発におけるRustの盛り上がり具合が分かります．&lt;/p&gt;
&lt;h2 id=&#34;big-code--big-vocabulary-open-vocabulary-models-for-source-code&#34;&gt;Big Code != Big Vocabulary: Open-Vocabulary Models for Source code&lt;/h2&gt;
&lt;p&gt;キャッチーなタイトルだったのでピックアップしてみました．&lt;br&gt;
変数名などのユーザー定義の識別子があるため，ソースコードは自然言語に比べて，大規模になるとコーパスが巨大になってしまいます．
この論文では，コーパスがスケールするように，新しい言語モデルを提案しています．&lt;/p&gt;
&lt;h2 id=&#34;dlfix-context-based-code-transformation-learning-for-automated-program-repair&#34;&gt;DLFix: Context-based Code Transformation Learning for Automated Program Repair&lt;/h2&gt;
&lt;p&gt;最近のソフトウェア工学の大きなトピックの一つであるAPRの論文．&lt;br&gt;
機械学習ベースのAPRは過去のバグ修正の学習に制限があるのに対して，DLFixでは学習のレイヤを2層に分けることでうまくこの制限を回避したらしいです．&lt;/p&gt;
&lt;h2 id=&#34;a-cost-efficient-approach-to-building-in-continuous-integration&#34;&gt;A Cost-efficient Approach to Building in Continuous Integration&lt;/h2&gt;
&lt;p&gt;CIの論文．&lt;br&gt;
CIのコストはビルドを回している時間だけかかってしまい，かつ，CIの目的はバグを発見することなので，
多くのバグを発見するビルドをなるべく早い段階で回す手法を提案しています．&lt;/p&gt;
&lt;h2 id=&#34;here-we-go-again-why-is-it-difficult-for-developers-to-learn-another-programming-language&#34;&gt;Here We Go Again: Why Is It Difficult for Developers to Learn Another Programming Language?&lt;/h2&gt;
&lt;p&gt;ある言語を習得したプログラマが他の言語を習得する際の難易度に関する調査を行った研究．&lt;/p&gt;
&lt;h3 id=&#34;終わりに&#34;&gt;終わりに&lt;/h3&gt;
&lt;p&gt;以上です．
会議全体としては，機械学習とFuzzing周りの論文が多い印象です．
おそらく今年もICSE勉強会が実施されると思うので，楽しみにしてます．&lt;/p&gt;
&lt;p&gt;論文一覧は&lt;a href=&#34;https://conf.researchr.org/track/icse-2020/icse-2020-papers#event-overview&#34;&gt;ここ&lt;/a&gt;から見れます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>&lt;p&gt;けもフレチックでした．&lt;/p&gt;
&lt;p&gt;A~Eまで&lt;/p&gt;
&lt;h2 id=&#34;a---serval-vs-monster&#34;&gt;A - Serval vs Monster&lt;/h2&gt;
&lt;p&gt;(H + A - 1) / A するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---common-raccoon-vs-monster&#34;&gt;B - Common Raccoon vs Monster&lt;/h2&gt;
&lt;p&gt;必殺技の総和をとって大小比較&lt;/p&gt;
&lt;h2 id=&#34;c---fennec-vs-monster&#34;&gt;C - Fennec vs Monster&lt;/h2&gt;
&lt;p&gt;体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃&lt;/p&gt;
&lt;h2 id=&#34;d---caracal-vs-monster&#34;&gt;D - Caracal vs Monster&lt;/h2&gt;
&lt;p&gt;等比数列の和&lt;/p&gt;
&lt;h2 id=&#34;e---crested-ibis-vs-monster&#34;&gt;E - Crested Ibis vs Monster&lt;/h2&gt;
&lt;p&gt;DP&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>研究室のパソコンがmacbook proになった話</title>
      <link>https://t45k.github.io/blog/mbp/</link>
      <pubDate>Tue, 21 Jan 2020 18:11:41 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/mbp/</guid>
      <description>&lt;p&gt;組織特有の，年末に予算を使い切る目的で，新しいmacbook proを貸してもらえることになった．
モデルはMid2019の13インチモデル．
研究室内で大した業績を上げていない自分にしてはとても良いものを貸してもらえたと思う．&lt;/p&gt;
&lt;p&gt;以下，使ってみた感想&lt;/p&gt;
&lt;h2 id=&#34;良いとこ&#34;&gt;良いとこ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;速い&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今まで2015年モデルのmacbook airを借りていた．
mbpと比べるとマシンパワーが段違いであり，作業にかかる時間が大幅に短縮された．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画面が綺麗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マジで全然違う．
4年でここまで変わるのかって感じ．&lt;/p&gt;
&lt;h2 id=&#34;良くないとこ&#34;&gt;良くないとこ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;日本語入力がもっさりしてる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mbaでは起きていなかった現象．
英語入力から日本語入力に変更した直後が，なぜか入力してから画面に表示されるまで0.5秒くらいかかる．
ググったら結構記事がヒットしたので，何かしらの解決法はあると思う．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キーボードがヤバイ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使う前からバタフライキーボードがやばいことは理解していたが，使ってみるとやっぱりやばかった．
普段RealForceや青軸のゲーミングキーボード等のしっかりと押し込むタイプのキーボードを使っているので違和感が凄い．&lt;/p&gt;
&lt;p&gt;多分ボタンの押し方にコツが必要なのだと感じた．
バタフライキーボードは指先で押すと指先を痛めやすい（インターンでmbpを借りていたときはマジで一日の終わりは指先が痛かった）ので，指の腹で押すのが大事だと思う．
今でも&amp;rsquo;return&amp;rsquo;を押す右小指が痛くなってきた．
普段からmbpを使っている友達曰く，なぞるように押すのが良いらしいので慣れるしかないかなぁって気持ち．&lt;/p&gt;
&lt;p&gt;また，バタフライキーボードは薄さにわりに押す際に力が必要なので，小指などで押す&amp;rsquo;A&amp;rsquo;や&amp;rsquo;P&amp;rsquo;などが押せてないことが頻発した．&lt;/p&gt;
&lt;p&gt;エスケープが使いづらいのも地味に辛い．&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;研究室ではRealForceに接続して使うのでバタフライキーボードはまだマシだと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>&lt;p&gt;A~E問題まで．&lt;/p&gt;
&lt;h2 id=&#34;a---ac-or-wa&#34;&gt;A - AC or WA&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---comparing-strings&#34;&gt;B - Comparing Strings&lt;/h2&gt;
&lt;p&gt;辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される．
2数の大きい方の値の回数だけ，小さい方の値を出力する．&lt;/p&gt;
&lt;h2 id=&#34;c---low-elements&#34;&gt;C - Low Elements&lt;/h2&gt;
&lt;p&gt;数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．&lt;/p&gt;
&lt;h2 id=&#34;d---handstand-2&#34;&gt;D - Handstand 2&lt;/h2&gt;
&lt;p&gt;与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく．
例えば334は34，398は38という感じ．
あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---flatten&#34;&gt;E - Flatten&lt;/h2&gt;
&lt;p&gt;modの逆元を知らないと厳しい問題．&lt;a href=&#34;https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-1-mod-p-%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%89%B2%E3%82%8A%E7%AE%97%E3%81%A8%E3%81%AF&#34;&gt;参考&lt;/a&gt;&lt;br&gt;
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める．
LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自己紹介</title>
      <link>https://t45k.github.io/about/</link>
      <pubDate>Tue, 14 Jan 2020 22:32:06 +0900</pubDate>
      
      <guid>https://t45k.github.io/about/</guid>
      <description>&lt;h1 id=&#34;こんにちは&#34;&gt;こんにちは&lt;/h1&gt;
&lt;p&gt;中川 将（なかがわ たすく）です．
現在大阪大学大学院の修士二回生です．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/about.jpg&#34; height=&#34;50%&#34; width=&#34;50%&#34; &gt;&lt;/p&gt;
&lt;h1 id=&#34;好き&#34;&gt;好き&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Java，Kotlin，IntelliJ&lt;/li&gt;
&lt;li&gt;バイク
&lt;ul&gt;
&lt;li&gt;Kawasaki Ninja250SLに乗ってます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剣道
&lt;ul&gt;
&lt;li&gt;高校，大学と剣道部でした&lt;/li&gt;
&lt;li&gt;三段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;競プロ
&lt;ul&gt;
&lt;li&gt;AtCoder水色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音楽
&lt;ul&gt;
&lt;li&gt;聴く方&lt;/li&gt;
&lt;li&gt;DJ Technorch，aran，岸田教団，etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Party Parrot&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;嫌い&#34;&gt;嫌い&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;javascript&lt;/li&gt;
&lt;li&gt;&lt;del&gt;研究&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;呟き&#34;&gt;呟き&lt;/h1&gt;
&lt;style type=&#34;text/css&#34;&gt;
    .box{
		overflow:auto;
		width:500px; height:1000px;
		padding:1px;
		color:#000000;
		background-color:#000000;
		line-height:1.5em;
    }
&lt;/style&gt;
&lt;div class=&#34;box&#34;&gt;
&lt;a class=&#34;twitter-timeline&#34; href=&#34;https://twitter.com/getupmax?ref_src=twsrc%5Etfw&#34;&gt;&lt;/a&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>APSEC2019に参加した話</title>
      <link>https://t45k.github.io/blog/apsec/</link>
      <pubDate>Thu, 05 Dec 2019 20:19:32 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/apsec/</guid>
      <description>&lt;p&gt;マレーシアで開催された12/3~5に開催されたAPSECに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;apsecとは&#34;&gt;APSECとは&lt;/h2&gt;
&lt;p&gt;Asia-Pacific Software Engineering Conferenceの略です．
要するにソフトウェア工学の国際会議です．
会議ランクについては詳しくは知らないのですがそこまで高くないと思います．
投稿前に先生が，「APSECは塩漬けのネタを投稿するのにちょうど良い」と語っていたのが印象的でした．&lt;/p&gt;
&lt;h2 id=&#34;マレーシアとは&#34;&gt;マレーシアとは&lt;/h2&gt;
&lt;p&gt;こんな国です．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;マレーシア&lt;br&gt;+ 物価が安い&lt;br&gt;+ 時差が1時間&lt;br&gt;+ 英語が通じる&lt;br&gt;&lt;br&gt;+- 暑い&lt;br&gt;&lt;br&gt;- 酒を飲める場所がかなり限られる&lt;br&gt;- 用を足した後に紙を使わない文化&lt;/p&gt;&amp;mdash; task (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1202822137611862017?ref_src=twsrc%5Etfw&#34;&gt;December 6, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;img src=&#34;https://t45k.github.io/img/blog/apsec.jpg&#34; height=&#34;50%&#34; width=&#34;50%&#34;&gt;
&lt;p&gt;投稿前はあまり気乗りしなかったし，正直通るとも思ってませんでしたが，結果的には国際学会で発表できて良かったなと感じました．
質疑対応がかなりグダッてしまったので英語力（特にリスニング）を鍛えるのが重要だと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LINE DEVELOPER DAY2019に参加した話</title>
      <link>https://t45k.github.io/blog/devday/</link>
      <pubDate>Thu, 21 Nov 2019 20:16:05 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/devday/</guid>
      <description>&lt;p&gt;11/20，21に開催されたLINE DEV DAYに参加してきました．&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&#34;https://t45k.github.io/img/blog/devday.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt; 
&lt;/figure&gt;

&lt;h2 id=&#34;dev-dayとは&#34;&gt;DEV DAYとは&lt;/h2&gt;
&lt;p&gt;LINEが開催している社内の技術などを公開するエンジニア向けのイベントです．
今年は二日に分けて開催し，エンジニアだけでなくデザインやプロダクト的な話も盛り込んだそうです．&lt;/p&gt;
&lt;h2 id=&#34;参加したきっかけ&#34;&gt;参加したきっかけ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../line/&#34;&gt;LINEのインターン&lt;/a&gt;に参加した時のメンターさんがLINE SDKのリードテックになられたらしく，DEV DAYでの登壇の際にインターン中に作ったプロダクトを紹介するかもみたいな話を小耳に挟んだのがきっかけです．
また，LINEは学生向けに金銭的援助を行っており，インターン生は（交通費として）無条件で3万円もらえるというのも結構魅力的でした．&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;20日は違う会社の採用面接に参加していたため，21日だけ参加しました．
思ったより規模が大きく，たくさんの人が参加していたのが印象的でした．
感想ですが，実は当日頭痛が酷く，話を聞く余裕がなかったというのが正直なところです．
例のメンターさんの発表で，唐突にライブコーディングが始まったのだけはっきり覚えています．
また，国際学会前というのもあり，慌ただしく帰ることになってしまいました．&lt;/p&gt;
&lt;p&gt;今年はゆっくり聞く時間がなかったので，来年機会があればもう少し余裕を持って参加したいなと感じました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>インターン総括</title>
      <link>https://t45k.github.io/blog/intern/</link>
      <pubDate>Sat, 14 Sep 2019 18:26:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/intern/</guid>
      <description>&lt;p&gt;2019年，M1の夏休みに行ってきたインターンの所感を書きます．&lt;/p&gt;
&lt;h2 id=&#34;参加したインターン&#34;&gt;参加したインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../aws/&#34;&gt;AWS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../line/&#34;&gt;LINE KYOTO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../rakuten/&#34;&gt;楽天&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参加しなかったインターン&#34;&gt;参加しなかったインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../ntt/&#34;&gt;NTT DATA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参加できなかったインターン&#34;&gt;参加できなかったインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../nssol/&#34;&gt;NSSOL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../cookpad/&#34;&gt;cookpad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;インターン全体の所感&#34;&gt;インターン全体の所感&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;意識高い学生が多い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学部の時は普段からゴリゴリ開発してるような友人はあまりいなかったため，意識の高い学生がこんなにもいることに驚きました&lt;/li&gt;
&lt;li&gt;彼らと就活で戦うことを考えるとすでに辛い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結構B3，B4で参加してる人も多い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意識高い&lt;/li&gt;
&lt;li&gt;当時の僕はインターンなんて考えたことなかったので&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;実力も高い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AtCoder青とかがゴロゴロいる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また，自分のスキルアップ（特にweb周りの知識）に繋がったのでよかったです．&lt;/p&gt;
&lt;p&gt;反省点としては，フロントなどの今までの自分が全くやったことがないような分野に挑戦することがなかったことが挙げられます．
自分の知らない分野を一から勉強した上できちんとしたものを作ることを，期限が短いインターン中にやり切るのは難易度が高いと感じました．
こういうことは普段から興味を持って勉強した方が良いのだと考えさせられました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>楽天のインターンに参加した話</title>
      <link>https://t45k.github.io/blog/rakuten/</link>
      <pubDate>Fri, 13 Sep 2019 18:21:32 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/rakuten/</guid>
      <description>&lt;figure&gt;
    &lt;img src=&#34;https://t45k.github.io/img/blog/rakuten_morning.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;9/9~13の間，大阪で開催された楽天様のインターンに参加してきました．
写真はインターン中に頂いた無料朝食です．&lt;/p&gt;
&lt;h2 id=&#34;楽天とは&#34;&gt;楽天とは&lt;/h2&gt;
&lt;p&gt;説明不要だと思います．
日本発のメガベンチャーで，ECの楽天市場などが有名です．
会社としては，外国人を積極的に採用しており，社内公用語が英語であることが特徴です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;選考は面接だけでした．
面接の内容もそこまで突っ込んだ話はしなかったです．
面接官の社員さんと趣味が合い，ずっとバイクの話をしていました．&lt;/p&gt;
&lt;p&gt;面接に通過した後，Springを使うための簡単な事前課題が出されました．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;外国人向けサービスを作ってみようという題目でハッカソンを行いました．
学生4人 + メンターの社員さん2名で開発を行っていくという方式でした．
今までメンターの社員さんは困ったり質問があったら訊きにいく程度の存在だったので，ここまでがっつり開発に参加してくれるのは新鮮でした．
他のインターンでは作るものが指定されていたので，アイデアソンから始めるというのは初めての出来事でした（余談ですが，アイデアが他の班と完全に被っていました）．&lt;/p&gt;
&lt;p&gt;開発を始めたのは2日目の朝からでしたが，班のメンバーにはgitを使ったことなかったり，Javaを書いたりしたことがない人もいたため，午前中はそこら辺の知識の共有から始めました（これのおかげで，その後スムーズに開発することができました）．
仕様などを決める際にも，社員さんと相談しながら決めました．
AWSの時はまったく理解できなくて着いていけなくなった経験から，分からないことは質問して理解してから先に進むようにしました．
開発自体はスムーズに進み，プロダクト自体も個人的には満足いくものが作れました．
技術的な面では，空いている時間でCIやDockerなどのモダンな技術を導入できました．
しかしプレゼンがグダリすぎてしまい，コンペでは最下位という結果でした．
プロダクト自体には満足していたので，結構悔しかったです．
ただ開発は楽しかったし，会社としての楽天も食堂が無料など良い点が多くインターンには非常に満足しました．&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;インターン中のパフォーマンスが評価されて，M1の10月ごろに採用面接をしていただけました．
合計3回の面接を経て，内定を頂けました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LINE KYOTOのインターンに参加した話</title>
      <link>https://t45k.github.io/blog/line/</link>
      <pubDate>Fri, 30 Aug 2019 18:13:39 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/line/</guid>
      <description>&lt;figure&gt;
    &lt;img src=&#34;https://t45k.github.io/img/blog/line.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt; 
&lt;/figure&gt;

&lt;p&gt;8/26~30の間，京都で開催されたLINE KYOTOのインターンに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;line-kyotoとは&#34;&gt;LINE KYOTOとは&lt;/h2&gt;
&lt;p&gt;LINEが何なのかは説明不要だと思うので割愛します．
LINE KYOTOは開発部しか持っていない，純粋な開発拠点であることが特徴の一つです．
また，京都という土地柄，外国人が多く所属しているのも特徴です（社員さんの半分以上が外国籍の方でした）．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;選考は技術試験と面接です．
技術試験はいわゆるプロコンみたいな問題で，普段から勉強しておくと多少有利かもしれません．
面接は，今まで自分がやってきたことを5枚程度のスライドにまとめて，その内容も踏まえて面接を行うというものでした．
僕はこれまで大規模な開発などを経験したことがなかったので，これまでやってきた研究について話しました．
結構倍率は高いようでしたが何とか通りました．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;LINEが開発しているLIFF SDKを用いて，LINE上で動くサービスを開発してみようという内容でハッカソンを行いました．
3人で一つの班を組み，4つのテーマから1つ選択するという形式で，僕たちの班はUNOを選択しました．
僕達が参加した一週間前にも同じインターンがあり，その時UNOを選択した班は結局完成しなかったと散々脅されましたが，結果的に4班中3班がUNOを選択していました．&lt;/p&gt;
&lt;p&gt;僕達の班はフロントの描画担当の子がKotlinで書くということなので，フロントからサーバまですべてKotlinで書くことにしました．
僕は楽天のインターンの事前課題でSpringを触っていたのでサーバを書くことにしました．
また，3人班のもう一人の子が超絶優秀で，最初に仕様とDB設計を行い，サーバとフロントの手伝いをしつつ，サーバとフロントと外部APIを繋げてちゃんと動くようにするという一番難しい部分を担ってくれたおかげで，僕たちの班はちゃんと動くものを作ることができました．
結果的に他の2班は完成させることができず，とても達成感と満足感を得ることができました．&lt;/p&gt;
&lt;p&gt;社員さん達もそれぞれの分野に精通した人が揃っていて，問題が発生してもすぐに解決できることが多かったです．
残業禁止で定時には全員帰られるというのもとても魅力的でした．&lt;/p&gt;
&lt;p&gt;インターン中の様子は以下の以下のLINE公式ブログにも取り上げられています．
&lt;a href=&#34;https://engineering.linecorp.com/ja/blog/kyoto-intern2019/&#34;&gt;https://engineering.linecorp.com/ja/blog/kyoto-intern2019/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;せっかくインターンに参加したので，本選考も受けることにしました．
本選考は技術テストが1回，技術面接が1回，最終面接でした．
最終面接にて無事不採用となりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWSのインターンに参加した話</title>
      <link>https://t45k.github.io/blog/aws/</link>
      <pubDate>Tue, 20 Aug 2019 18:07:41 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/aws/</guid>
      <description>&lt;p&gt;8/19~13の間，東京で開催されたAmazon Web Serviceのインターンに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;awsとは&#34;&gt;AWSとは&lt;/h2&gt;
&lt;p&gt;AWSとは，Amazon Web Serviceの略です．
AWSはAmazonのクラウド事業を担当している会社です．
Amazonのマーケットプレイスを筆頭に，様々な会社がAWSのクラウドを利用しています（クラウド事業ではシェア1位です）．
今，世界で最も勢いのあるIT会社の一つだと言えます．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;HP上には技術試験 + 面接と書いてあったのですが，なぜか面接が行われませんでした．
技術試験では実際にEC2インスタンスが与えられ，そこの上でAPIサーバを立てるという内容でした．
今までサーバ開発をしたことがなかったので，簡単にサーバが書けると噂のPHPを急いで勉強して何とか提出にこぎつけました．
問題的には明らかにDBを使わせようとしていましたが，そこまで手が回らなかったのでjsonファイルを読み書きするという手段をとりました．
結果的に通ったので良かったです．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;実際に存在するサービスを模倣してアーキテクチャを設計するという題目で，5日間グループワークを行いました．
仕事内容的には魅力的だったのですが，いかんせん僕にネットワークの知識がなさすぎて2日目くらいから早くも着いていけなくなりました．
東京まで来て何してるんだろうって結構辛い気持ちになりました．
ただしっかり勉強した上で望めば本当に楽しいのだろうなと感じました．&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;このインターンは採用直結型だったので，インターン後そのまま本選考に応募しました．
技術試験，技術面接，最終面接を経て，12/24に無事不採用となりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cookpadのインターンに参加できなかった話</title>
      <link>https://t45k.github.io/blog/cookpad/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:27 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/cookpad/</guid>
      <description>&lt;p&gt;cookpadのインターンに参加できませんでした．&lt;/p&gt;
&lt;h2 id=&#34;cookpadとは&#34;&gt;cookpadとは&lt;/h2&gt;
&lt;p&gt;料理のレシピを提供するサービスで有名な会社です．
あまり知られていないのですが（僕が知らなかっただけかもしれませんが），ITに力を入れており，技術力があるエンジニアが多く所属しています．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;技術試験 + 面接です．&lt;/p&gt;
&lt;p&gt;技術試験はプロコンのようにテストケースが用意されているわけではなく，仕様のみが与えられてそれに一致するようなコードを書くという問題でした．
仕様を満たすようにコードは書いたつもりでしたが落ちてしまいました．&lt;/p&gt;
&lt;p&gt;原因として考えられるのが，問題中APIを叩く部分があって，通常であれば言語仕様に則ってPOSTなどをすると思うのですが，当時はAPIって何?って状態だったので，直接コマンドからcurlを呼び出すように書きました．
その辺から技術不足が見抜かれたのかなぁって感じです．&lt;/p&gt;
&lt;p&gt;結構悔しかったです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NSSOLのインターンに参加できなかった話</title>
      <link>https://t45k.github.io/blog/nssol/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:21 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/nssol/</guid>
      <description>&lt;p&gt;NSSOL様のインターンに参加できませんでした．&lt;/p&gt;
&lt;p&gt;NSSOLに行った研究室の先輩方は多く，結構興味を持っていました．
東京までの旅費や宿泊費を出してくれる上に，毎日飲み会があると聞いていたので参加できることを楽しみにしていました．&lt;/p&gt;
&lt;h2 id=&#34;nssolとは&#34;&gt;NSSOLとは&lt;/h2&gt;
&lt;p&gt;日本製鐵のシステム部門が独立してできた会社です．
母体が大きな会社であり，NSSOLも国内のSIerの中ではそれなりに大きく有名な会社です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;ES + SPI + 面接でした．&lt;/p&gt;
&lt;p&gt;SPIはテストセンターまで受けに行かなければならず面倒でした．
面接は顔合わせ程度のものだと聞いていたのでここで落とされるとは思っていませんでした．
ただ面接自体は，普段からやっていて癖になっている自虐が多く出てしまい落ちることも納得でした．
こういうジャパニーズトラディショナルカンパニーには面接でありのままの自分を見せるよりも多少は偽った方が良いのかなと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NTT DATAのインターンに参加しなかった話</title>
      <link>https://t45k.github.io/blog/ntt/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ntt/</guid>
      <description>&lt;p&gt;NTT DATAのインターンに参加しませんでした．&lt;/p&gt;
&lt;h2 id=&#34;ntt-dataとは&#34;&gt;NTT DATAとは&lt;/h2&gt;
&lt;p&gt;国内情報系最大手のNTTのSI部門会社です．
やはり最大手らしく，日本全国から有能な人材が集まることで有名です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;ES + SPI + 動画提出でした．&lt;/p&gt;
&lt;p&gt;テストセンターに行かなくても自分のパソコン上でSPIを受けれたのが個人的に楽でした．
動画はインターンに対する意気込みを語れとのことでした．
これで採用か不採用かが決まるのも変な気がしましたが，とりあえずほぼ一発どりで提出したら通ってびっくりました．&lt;/p&gt;
&lt;p&gt;このインターンに参加すると合計4週間インターンに行くことになってしまうので辞退しました．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
