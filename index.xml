<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>T45K</title>
    <link>https://t45k.github.io/</link>
    <description>Recent content on T45K</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 23 Oct 2021 20:31:42 +0900</lastBuildDate>
    
	<atom:link href="https://t45k.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ABC223の解説</title>
      <link>https://t45k.github.io/kyopuro/abc223/</link>
      <pubDate>Sat, 23 Oct 2021 20:31:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc223/</guid>
      <description>&lt;p&gt;ギリギリ 4 完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC223&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---exact-price&#34;&gt;A - Exact Price&lt;/h2&gt;
&lt;p&gt;100 で割った余りが 0 になればよい．&lt;/p&gt;
&lt;p&gt;入力例にあるように X=0 である場合に注意．&lt;/p&gt;
&lt;h2 id=&#34;b---string-shifting&#34;&gt;B - String Shifting&lt;/h2&gt;
&lt;p&gt;シフトした文字列を全通り用意しておき，ソートする．&lt;/p&gt;
&lt;h2 id=&#34;c---doukasen&#34;&gt;C - Doukasen&lt;/h2&gt;
&lt;p&gt;両端からシミュレーションするのは難しそうなので他の方法を考える．&lt;/p&gt;
&lt;p&gt;少し考えると，左端と右端両端から同時に火をつけたそれらがぶつかった時，
どちらも同じ時間燃えていたことになる．
つまり，ぶつかる場所は，左端から火をつけて燃え切るのに必要な時間の半分になる．&lt;/p&gt;
&lt;p&gt;あとは，全て燃える時間を計算して，その半分でどこまで燃えるかを計算すればよい．&lt;/p&gt;
&lt;h2 id=&#34;d---restricted-permutation&#34;&gt;D - Restricted Permutation&lt;/h2&gt;
&lt;p&gt;トポロジカルソートを，優先度付きキューを用いた幅優先探索でやるだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC222の解説</title>
      <link>https://t45k.github.io/kyopuro/abc222/</link>
      <pubDate>Sat, 23 Oct 2021 18:07:27 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc222/</guid>
      <description>&lt;p&gt;四完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC222&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---four-digits&#34;&gt;A - Four Digits&lt;/h2&gt;
&lt;p&gt;10 未満には 3 個，100 未満には 2 個，1000 未満には 3 個 0 を付けた文字列を出力する．&lt;/p&gt;
&lt;h2 id=&#34;b---failing-grade&#34;&gt;B - Failing Grade&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;/p&gt;
&lt;h2 id=&#34;c---swiss-system-tournament&#34;&gt;C - Swiss-System Tournament&lt;/h2&gt;
&lt;p&gt;問題文が長すぎて，飛ばして先に D から解いた問題．
やることは&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前から二人ペアでじゃんけんをする&lt;/li&gt;
&lt;li&gt;勝ったらその人の勝ち数を増やす&lt;/li&gt;
&lt;li&gt;勝ち数でソートする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を繰り返すだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---between-two-arrays&#34;&gt;D - Between Two Arrays&lt;/h2&gt;
&lt;p&gt;DP．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dp[前から何番目を見てるか][c_iの値]=何通りか&lt;/code&gt;という DP を組むと&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i=1&lt;/code&gt;の時，&lt;code&gt;a_1 &amp;lt;= j &amp;lt;= b_1&lt;/code&gt;の範囲で 1，それ以外は 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&amp;gt;1&lt;/code&gt;の時，&lt;code&gt;dp[i-1][a_i]~dp[i-1][j]&lt;/code&gt;までの総和&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;になる．&lt;/p&gt;
&lt;p&gt;総和の計算には累積和を使う．&lt;/p&gt;
&lt;h2 id=&#34;e---red-and-blue-tree&#34;&gt;E - Red and Blue Tree&lt;/h2&gt;
&lt;p&gt;場合分けが漏れていて解き損ねた問題．&lt;/p&gt;
&lt;p&gt;基本的なやり方としては，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全ての辺に対して，全ての移動を行った後に何回通ったかを記録しておく&lt;/li&gt;
&lt;li&gt;それぞれの辺を赤，青とした場合の R-B の値を DP を使って計算する．&lt;/li&gt;
&lt;li&gt;R-B=K となる組み合わせの数を求める．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ここで注意しないといけないのは以下の 2 点．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;まったく通らない辺がある場合がある．その場合，その辺の色は何色でも良いので，2 の辺の数乗をかける必要がある．&lt;/li&gt;
&lt;li&gt;まったく移動しないパターンがある．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ドキドキ文芸部をプレイした話</title>
      <link>https://t45k.github.io/blog/ddlc/</link>
      <pubDate>Mon, 18 Oct 2021 19:54:12 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ddlc/</guid>
      <description>&lt;p&gt;ドキドキ文芸部をプレイしました．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以降，ネタバレ含みます．&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;プレイ中の感想としては，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;もうやめてくれよ&lt;/li&gt;
&lt;li&gt;これ以上いけない&lt;/li&gt;
&lt;li&gt;あかん&lt;/li&gt;
&lt;li&gt;救いはないのですか？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をひたすら繰り返した感じでした．&lt;/p&gt;
&lt;p&gt;特に驚いたのが名前を呼ばれた場面で，PC のユーザ名を本名にしていたのでどこから入手したのか最初は不審に思いました．&lt;/p&gt;
&lt;p&gt;全体的には有名なだけあるなって感じで，久々に（短い間ですが）のめり込んでゲームできました．&lt;/p&gt;
&lt;p&gt;その他思ったこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ゲーム内に PC のターミナルがあって，そこからファイルをいじれたりゲームを再起動できるのは面白い仕掛けだと感じた&lt;/li&gt;
&lt;li&gt;ナツキとユリが言い争った挙句モニカがアップになるシーンに毎回びっくりする&lt;/li&gt;
&lt;li&gt;ナツキ √ がほしい&lt;/li&gt;
&lt;li&gt;今回買ったのはプラスだが，無印版だとさらに色々できるらしい&lt;/li&gt;
&lt;li&gt;トロコンまでやるかは不明&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ABC220の解説</title>
      <link>https://t45k.github.io/kyopuro/abc220/</link>
      <pubDate>Wed, 06 Oct 2021 22:54:53 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc220/</guid>
      <description>&lt;p&gt;5 完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC220/&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---find-multiple&#34;&gt;A - Find Multiple&lt;/h2&gt;
&lt;p&gt;ゴリゴリに計算して答えを出しても良いが，この手の問題は全探索しても間に合う．&lt;/p&gt;
&lt;h2 id=&#34;b---base-k&#34;&gt;B - Base K&lt;/h2&gt;
&lt;p&gt;10 進法に直してから計算する&lt;/p&gt;
&lt;h2 id=&#34;c---long-sequence&#34;&gt;C - Long Sequence&lt;/h2&gt;
&lt;p&gt;A1 ～ AN までの 1 ループでの和を事前に計算しておき，X とその和の商と余りから k を求める．&lt;/p&gt;
&lt;h2 id=&#34;d---fg-operation&#34;&gt;D - FG operation&lt;/h2&gt;
&lt;p&gt;DP&lt;/p&gt;
&lt;h2 id=&#34;e---distance-on-large-perfect-binary-tree&#34;&gt;E - Distance on Large Perfect Binary Tree&lt;/h2&gt;
&lt;p&gt;ある頂点について，ペアの作るための頂点の選び方は以下の 3 通りになる&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自分の子孫から対となる頂点を選ぶ&lt;/li&gt;
&lt;li&gt;自分の先祖から対となる頂点を選ぶ&lt;/li&gt;
&lt;li&gt;自分の先祖を経由して，その先祖の自分側以外の子孫から対となる頂点を選ぶ&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;また，それぞれに関して，自分の深さを X とすると，以下の条件が設けられる&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自分の深さから N までが D 以上，つまり &lt;code&gt;N-X &amp;gt;= D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1 から自分の深さまでが D 以上，つまり &lt;code&gt;X-1 &amp;gt;= D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ある先祖の深さが Y の時，Y を経由しても D に収まる，つまり &lt;code&gt;(X-Y)+(N-Y) &amp;gt;= D&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;あとはそれぞれに関して計算すればよい．&lt;/p&gt;
&lt;h2 id=&#34;f---distance-sums-2&#34;&gt;F - Distance Sums 2&lt;/h2&gt;
&lt;p&gt;まず初めに頂点 1 を根として，頂点 1 からの距離の総和 S を求める．
次に，頂点 1 に繋がっている頂点について考えると，
その頂点に移動したとき，その頂点の子に 1 ずつだけ近付き，それ以外の 1 の子に 1 ずつだけ遠ざかるので，
その頂点からの距離の総和は
&lt;code&gt;S - (その頂点の子の数) + (その頂点以外の 1 の子の数)&lt;/code&gt;
となる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC219の解説</title>
      <link>https://t45k.github.io/kyopuro/abc219/</link>
      <pubDate>Wed, 06 Oct 2021 22:26:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc219/</guid>
      <description>&lt;p&gt;5 完 600 位で青パフォ．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC219/&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---atcoder-quiz-2&#34;&gt;A - AtCoder Quiz 2&lt;/h2&gt;
&lt;p&gt;やるだけ．誤読して WA を出した&lt;/p&gt;
&lt;h2 id=&#34;b---maritozzo&#34;&gt;B - Maritozzo&lt;/h2&gt;
&lt;p&gt;これもやるだけ．
S1~S3 を配列に入れて，T の各数字を int 型に変換してからそれぞれの S に map して一つの文字列に結合すると気持ち良く書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s1 = scanner.next();
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s2 = scanner.next();
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s3 = scanner.next();
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] s = {s1, s2, s3};
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String t = scanner.next();
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String answer = IntStream.range(0, t.length())
    .map(i -&amp;gt; t.charAt(i) - &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;)
    .mapToObj(i -&amp;gt; s[i])
    .collect(Collectors.joining());
System.out.println(answer);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---neo-lexicographic-ordering&#34;&gt;C - Neo-lexicographic Ordering&lt;/h2&gt;
&lt;p&gt;初めにバブルソートをやろうとして TLE を食らった問題&lt;/p&gt;
&lt;p&gt;自作の Comparator を用意しても解けるが，以下のようにやるとやりやすい&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与えられた文字列を，与えられた辞書順である文字列に変換する&lt;/li&gt;
&lt;li&gt;普通にソートする&lt;/li&gt;
&lt;li&gt;逆変換を書ける&lt;/li&gt;
&lt;li&gt;出力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;d---strange-lunchbox&#34;&gt;D - Strange Lunchbox&lt;/h2&gt;
&lt;p&gt;二次元 DP をやる．つまり
&lt;code&gt;dp[i][たこ焼きの個数][たい焼きの個数]=弁当の個数の最小値&lt;/code&gt;となるような DP をやる．&lt;/p&gt;
&lt;h2 id=&#34;e---moat&#34;&gt;E - Moat&lt;/h2&gt;
&lt;p&gt;判定条件が面倒臭いだけで，発想自体は素直にやれば良い問題．&lt;/p&gt;
&lt;p&gt;簡単のために，4*4 のマス目に村があり，選択したマスの周りを堀で囲むとする．
まず，4*4 なので bit 全探索をやっても間に合う．
そうすると，問題文中の 5 つの条件は以下のように言い換えられる．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自己交差がない&lt;br&gt;
-&amp;gt; 全てのマスが上下左右のいずれかで接続されている&lt;/li&gt;
&lt;li&gt;内部に全ての村を含む&lt;br&gt;
-&amp;gt; 選んだマスに全ての村が含まれる&lt;/li&gt;
&lt;li&gt;すべての頂点は～&lt;/li&gt;
&lt;li&gt;すべての辺は～&lt;/li&gt;
&lt;li&gt;それぞれの内角の～&lt;br&gt;
-&amp;gt; マスで考えると必ず条件を満たす&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;また，問題文から以下の条件を追加で考える必要がある．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全ての選択したマスは連結である必要がある&lt;/li&gt;
&lt;li&gt;選択したマスの内部に選択されていないマスを含んではいけない&lt;br&gt;
-&amp;gt; 全ての選択されていないマスは，外側を一周するマス（&lt;code&gt;(0,0)~(0,3),(1,0),(1,3),(2,0),(2,3),(3,0)~(3,3)&lt;/code&gt;）と連結．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ABC218の解説</title>
      <link>https://t45k.github.io/kyopuro/abc218/</link>
      <pubDate>Mon, 13 Sep 2021 16:37:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc218/</guid>
      <description>&lt;p&gt;初の 6 完で久々に盛れた．
&lt;a href=&#34;https://github.com/T45K/Kyopuro/tree/master/AtCoder/ABC/ABC218&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---weather-forecast&#34;&gt;A - Weather Forecast&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;String#charAt&lt;/code&gt;使う．&lt;/p&gt;
&lt;h2 id=&#34;b---qwerty&#34;&gt;B - qwerty&lt;/h2&gt;
&lt;p&gt;問題文内では辞書順という言葉を使っているが，単純に&lt;code&gt;(char)(&#39;a&#39; + P_i - 1)&lt;/code&gt;を出力するだけ．&lt;/p&gt;
&lt;h2 id=&#34;c---shapes&#34;&gt;c - Shapes&lt;/h2&gt;
&lt;p&gt;アルゴリズムは簡単だが実装が割としんどい問題．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;が存在する座標のリストを取得し，それらを左上詰めしたうえで比較する．
例えば，入力例 1 の S&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;.....
..#..
.###.
.....
.....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;は 0-indexed で&lt;code&gt;(1,2), (2,1), (2,2), (2,3)&lt;/code&gt;と表せられる．
このとき，行の最小値は 1，列の最小値は 1 なので，
左上詰めするとそれぞれの座標の行，列から 1 ずつ引いて
&lt;code&gt;(0,1), (1,0), (1,1), (1,2)&lt;/code&gt;と表せられる．&lt;/p&gt;
&lt;p&gt;これを S に対して 90° ずつ回転させたリストと T を比較する．&lt;/p&gt;
&lt;h2 id=&#34;d---rectangles&#34;&gt;D - Rectangles&lt;/h2&gt;
&lt;p&gt;条件から，求めたいのは，
&lt;code&gt;あるx_iをx座標に持つ点の集合と，あるx_jをx座標に持つ点の集合の間で，y座標が一致する点の集合から2つ選ぶ時の組み合わせの数&lt;/code&gt;になる．
これを実現するため，与えられた点を x 座標をキー，y 座標のリストを値に持つ Map に格納する．
この時，リストは事前にソートしておく．
あとは x 座標の各組合せに対して，一致する y 座標の数を数えておく．
ソートしているので尺取法的に数え上げると，この操作はリストの長さに線形で可能なので十分に間に合う．&lt;/p&gt;
&lt;h2 id=&#34;e---destruction&#34;&gt;E - Destruction&lt;/h2&gt;
&lt;p&gt;最小全域木をやるだけ．
C_i が負の辺は問答無用で加えてよい．&lt;/p&gt;
&lt;h2 id=&#34;f---blocked-roads&#34;&gt;F - Blocked Roads&lt;/h2&gt;
&lt;p&gt;初めに普通に最短経路を求める（幅優先探索で&lt;code&gt;O(N+M)&lt;/code&gt;で可能）．
ここで，この最短経路の値を X とすると，最短経路に含まれない辺を通れないとしても，X で頂点 1 から頂点 N に移動できる．
後は，最短経路に含まれる辺それぞれに対して，通れない場合の最短経路をシミュレーションすれば良い．
最短経路に含まれる経路数は高々&lt;code&gt;N-1&lt;/code&gt;なので十分に間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC217の解説</title>
      <link>https://t45k.github.io/kyopuro/abc217/</link>
      <pubDate>Wed, 08 Sep 2021 18:47:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc217/</guid>
      <description>&lt;p&gt;ぎりぎり5完．
難しく考えてセグ木で殴りにいくことが多かった．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC217/&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---lexicographic-order&#34;&gt;A - Lexicographic Order&lt;/h2&gt;
&lt;p&gt;Javaは&lt;code&gt;S.compareTo(T)&lt;/code&gt;するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---atcoder-quiz&#34;&gt;B - AtCoder Quiz&lt;/h2&gt;
&lt;p&gt;初めに4つのコンテストをSet等で持っておいて，出てきたものを消す．&lt;/p&gt;
&lt;h2 id=&#34;inverse-of-permutation&#34;&gt;Inverse of Permutation&lt;/h2&gt;
&lt;p&gt;問題文の解読にちょっと時間がかかった．
転置する．&lt;/p&gt;
&lt;h2 id=&#34;d---cutting-woods&#34;&gt;D - Cutting Woods&lt;/h2&gt;
&lt;p&gt;セグ木で殴った問題その1．
Javaだと&lt;code&gt;TreeSet&lt;/code&gt;でOK（&lt;code&gt;lower&lt;/code&gt;と&lt;code&gt;ceiling&lt;/code&gt;が使えることを知らなかった）．
別解を紹介する．&lt;/p&gt;
&lt;p&gt;まずminを返すセグ木とmaxを返すセグ木を用意する．
木材を切る度に，2つのセグ木のxiの位置をxiで更新する．
こうすると，線xiを含む木材の長さは，&lt;code&gt;(出てきた数値のうち，xi以上の最小値)-(xi以下の最大値)&lt;/code&gt;と表すことができ，
セグ木を使うことで&lt;code&gt;O(log N)&lt;/code&gt;で処理できる．
木材の長さは&lt;code&gt;10^9&lt;/code&gt;を取りうるので，木材を切る位置で座標圧縮する．
つまり，ci=1のクエリを先に全て集めて起き，それらのxiの値でリストを作り，
それをもとにセグ木を構築する．&lt;/p&gt;
&lt;h2 id=&#34;e---sorting-queries&#34;&gt;E - Sorting Queries&lt;/h2&gt;
&lt;p&gt;セグ木で殴った問題その2．&lt;/p&gt;
&lt;p&gt;これも初めに出てくるxを全て集めておきリストに入れる．
このリストをセグ木に入れる．
次にクエリを順番にみていき，以下の操作を行う．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作1の時，Aの長さを表す変数&lt;code&gt;length&lt;/code&gt;を更新する．&lt;/li&gt;
&lt;li&gt;操作3の時，Aのどの部分までがソート済みかを表す変数&lt;code&gt;sortedPoint&lt;/code&gt;に&lt;code&gt;length&lt;/code&gt;を代入する．&lt;/li&gt;
&lt;li&gt;操作2の時，次に出力する数字が何個目か（&lt;code&gt;count&lt;/code&gt;）によって，操作を変える
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sortedPoint&lt;/code&gt;以下なら，ソート済みの部分を出力するため，&lt;code&gt;count&lt;/code&gt;から&lt;code&gt;sortedPoint&lt;/code&gt;の範囲で最小値を出力する
（出力した数字は，次以降の操作で引っかからないように最大値で更新しておく）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sortedPoint&lt;/code&gt;を超過していれば，リストの&lt;code&gt;count&lt;/code&gt;番目の数字をそのまま出力する．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ABC216の解説</title>
      <link>https://t45k.github.io/kyopuro/abc216/</link>
      <pubDate>Sat, 04 Sep 2021 20:29:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc216/</guid>
      <description>&lt;p&gt;カス4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC216/&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---signed-difficulty&#34;&gt;A - Signed Difficulty&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;/p&gt;
&lt;p&gt;doubleやfloatでなく文字列型で入力を受け取ってピリオドで分割したほうが良い．&lt;/p&gt;
&lt;h2 id=&#34;b---same-name&#34;&gt;B - Same Name&lt;/h2&gt;
&lt;p&gt;姓と名を結合した文字列（間に空白を挟む）をSet等で管理し，最終的にSetの要素数とNを比較すれば良い
（要素数がNと同じなら同姓同名は存在しない）．&lt;/p&gt;
&lt;h2 id=&#34;c---many-balls&#34;&gt;C - Many Balls&lt;/h2&gt;
&lt;p&gt;元のNに対して&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nが奇数なら1引いてから2で割る&lt;/li&gt;
&lt;li&gt;Nが偶数なら2で割る&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という操作を行っていき，最後に行った操作を逆順に出力する&lt;/p&gt;
&lt;h2 id=&#34;d---pair-of-balls&#34;&gt;D - Pair of Balls&lt;/h2&gt;
&lt;p&gt;考え方としては，筒の先頭を順番に見ていき，重複するボールがあればそれを取り除き，改めてその筒を見る，という操作の繰り返しである．&lt;/p&gt;
&lt;p&gt;「操作を行う対象の筒リスト」を用意し，1~Nを初めに挿入する．
次に，リストの先頭から取り出した番号の筒に対して，以下の操作を行っていく&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;筒の先頭の数字が「すでに出現した数字」の集合に含まれている場合，筒の先頭と集合中のその数字を取り除き，「操作を行う対象の筒リスト」に今見ている筒の番号を入れる．&lt;/li&gt;
&lt;li&gt;筒の先頭の数字が「すでに出現した数字」の集合に含まれていない場合，その数字を集合に入れる．&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;e---amusement-park&#34;&gt;E - Amusement Park&lt;/h2&gt;
&lt;p&gt;ある楽しさXに対して，&lt;code&gt;Σ(max(Ai-X,0)) = K&lt;/code&gt;となるようなXが存在するときに，各アトラクションを楽しさがXになるまで乗るのが最適．
なので，そのXを二分探索を用いて探す．&lt;/p&gt;
&lt;h2 id=&#34;f--max-sum-counting&#34;&gt;F- Max Sum Counting&lt;/h2&gt;
&lt;p&gt;Aを昇順に並べたとき，Aiを含む(1,&amp;hellip;,i)の空でない部分集合は必ず最大値がAiになる．
このことから，ソートした後の各iに対して，(1,&amp;hellip;,i)の空でない部分集合に対してBiの和を求めて，Ai以下のものの個数を足し合わせていけば良い．
部分集合の和はナップザック問題に帰着し，Aiの最大値は5,000なので，それ以下の範囲で計算すれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「カーニバル 人類最後の事件」読了</title>
      <link>https://t45k.github.io/blog/carnival/</link>
      <pubDate>Wed, 01 Sep 2021 22:47:07 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/carnival/</guid>
      <description>&lt;p&gt;重い腰を上げて，清涼院流水の「カーニバル」を読みました．&lt;/p&gt;
&lt;p&gt;本作では，JDC爆破事件を皮切りに，1週ずつ繰り広げられる大規模犯罪のお話が展開されます．
また，各事件は作者が定めた順番に並べられており，「ページ通り読む（読者式）」と「時系列順に読む（作者式）」の2通りの方法で楽しむことができます．
今回は読者式で読んだのですが，事前に死んでしまう登場人物が分かっている状態で，その前日にその人物がどういう振る舞いをしているか，という楽しみ方ができるのは珍しいと思いました．&lt;/p&gt;
&lt;p&gt;今作ではこれまでJDCシリーズに出てきた多くの探偵が事件に巻き込まれ死にます．
また，トリックすら分からない完全不可能犯罪が多く出てきます．
この大風呂敷が次作の「カーニバル・デイ」でどう回収されるのかが楽しみです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC215の解説</title>
      <link>https://t45k.github.io/kyopuro/abc215/</link>
      <pubDate>Mon, 23 Aug 2021 20:59:23 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc215/</guid>
      <description>&lt;p&gt;Dで沼って緑パフォ4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC215&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---your-first-judge&#34;&gt;A - Your First Judge&lt;/h2&gt;
&lt;p&gt;文字列判定&lt;/p&gt;
&lt;h2 id=&#34;b---log2n&#34;&gt;B - log2(N)&lt;/h2&gt;
&lt;p&gt;logを使うと誤差で通らなかったりする．
&lt;code&gt;N&amp;lt;=10^18&lt;/code&gt;からkは高々60程度なので愚直に計算してよい&lt;/p&gt;
&lt;h2 id=&#34;c---one-more-aab-aba-baa&#34;&gt;C - One More aab aba baa&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;|S|&amp;lt;=8&lt;/code&gt;から全てのパターンを列挙しても4*19^5程度なので，全て列挙してからソートすればよい．
C++だとpermutationを使えば良いが，Javaだと自分で実装する必要がある．
再帰を使うと楽．&lt;/p&gt;
&lt;h2 id=&#34;d---coprime-2&#34;&gt;D - Coprime 2&lt;/h2&gt;
&lt;p&gt;全然解法が思いつかなかった．
想定解とは別解を紹介する．&lt;/p&gt;
&lt;p&gt;問題の条件から，求めたい数は，各Aiが約数として持たない素数と，それらの合成数であることが分かる．
そこであらかじめ2以上M以下の約数を全て列挙した上で，それらの倍数とAiが一致しないかを確認していく．
素数の倍数を列挙するのはエラトステネスの篩と同じ計算量で行え，それらがAiと一致するかはAをSetで持つことで&lt;code&gt;O(1)&lt;/code&gt;でできる．&lt;/p&gt;
&lt;p&gt;また，合成数を作る処理だが，合成数の数は高々M個なので計算量は&lt;code&gt;O(M)&lt;/code&gt;以下となる．&lt;/p&gt;
&lt;h2 id=&#34;e---chain-contestant&#34;&gt;E - Chain Contestant&lt;/h2&gt;
&lt;p&gt;解法は思いついたが時間内に実装できなかった問題．&lt;/p&gt;
&lt;p&gt;SがAからJまでの10種類しかないことに着目すると，2^10をやっても何となくいけそうな気になってくる．
以下のようなdpを組む．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;dp[文字列のどこを見ているか][今までどの文字を通ってきたか][今どこの文字にいるか]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ここで，&lt;code&gt;今までどの文字を通ってきたか&lt;/code&gt;はbitで表現できる．
このようなdp[i][j][k]を組むと，更新式は以下の和となる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;dp[i-1][j][k]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jがi番目の文字を含んでおり，かつk==i．
これは，i-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに最後に参加したことを表している．
このとき，そのままi番目の文字のコンテストを受けることができる．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jがi番目の文字を含んでおらず，かつk!=i．
これはi-1番目までのいずれかのコンテストに参加した時に，現在i番目の文字と同じコンテストに参加したことがなく，
初めてi番目の文字のコンテストに参加することを表している．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;+1．これは，i-1番目までのコンテストのいずれにも参加しておらず，i番目のコンテストに初めて参加することを表す．&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ABC214の解説</title>
      <link>https://t45k.github.io/kyopuro/abc214/</link>
      <pubDate>Sun, 15 Aug 2021 13:45:18 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc214/</guid>
      <description>&lt;p&gt;ABCDの四完．久々にD問題解けた．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC214&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---new-generation-abc&#34;&gt;A - New Generation ABC&lt;/h2&gt;
&lt;p&gt;if文で分岐する&lt;/p&gt;
&lt;h2 id=&#34;b---how-many&#34;&gt;B - How many?&lt;/h2&gt;
&lt;p&gt;for文で全探索&lt;/p&gt;
&lt;h2 id=&#34;c---distribution&#34;&gt;C - Distribution&lt;/h2&gt;
&lt;p&gt;意外と難しかったと感じた割には灰diffらしい．&lt;/p&gt;
&lt;p&gt;まずは簡単のために，時計回りに並んでいない場合を考える．
i番目のすぬけ君が初めて宝石をもらう時間を&lt;code&gt;time[i]&lt;/code&gt;とすると，
i(&amp;gt;=2)番目のすぬけ君が初めて宝石をもらうのは
&lt;code&gt;min(T_i, time[i-1]+S[i-1])&lt;/code&gt;となるので，
前から順番に計算していけば良い．&lt;/p&gt;
&lt;p&gt;実際には時計回りに並んでいるため，
1番目のすぬけ君がN番目のすぬけ君から宝石をもらうのが最速である場合がある．
これは&lt;code&gt;min(T_0, time[N]+S[N])&lt;/code&gt;となるので，先ほどの式と併せて
&lt;code&gt;min(T_i%N, time[(i-1)%N + S[(i-1)%N]])&lt;/code&gt;と一般化できる．
あとはこの式を2周ループすれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-maximum-weights&#34;&gt;D - Sum of Maximum Weights&lt;/h2&gt;
&lt;p&gt;D問題にしては難しかった問題．&lt;/p&gt;
&lt;p&gt;まず，以下のことが言える．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;連結でない頂点u,vに対して辺(u,v)を考える時，
その辺を最短パスに含む頂点の組の個数は
(uの連結成分の個数)*(vの連結成分の個数)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上から，u，v連結でなく，辺(u,v)が「uの連結成分中の辺」「vの連結成分中の辺」の重みよりも大きい（つまり，辺(u,v)が重みの最大値）場合，
辺(u,v)を繋ぐことで重みの最大値の合計値は
&lt;code&gt;(辺(u,v)の重み)*(uの連結成分の個数)*(vの連結成分の個数)&lt;/code&gt;だけ増える．&lt;/p&gt;
&lt;p&gt;よって，重みの小さい辺から順番に連結していくことで，答えを求めることができる．
連結成分の個数はUnion Findなどで管理できる．&lt;/p&gt;
&lt;h2 id=&#34;e---packing-under-range-regulations&#34;&gt;E - Packing Under Range Regulations&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;/p&gt;
&lt;h2 id=&#34;f---substrings&#34;&gt;F - Substrings&lt;/h2&gt;
&lt;p&gt;解説AC．解説が分かりやすい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「世界は密室でできている」読了</title>
      <link>https://t45k.github.io/blog/the_world_is_made_out_of_closed_rooms/</link>
      <pubDate>Thu, 05 Aug 2021 17:05:34 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/the_world_is_made_out_of_closed_rooms/</guid>
      <description>&lt;p&gt;近所の図書館の図書カードをようやく作ったので，
舞城王太郎の「世界は密室でできている」を借りて読みました．&lt;/p&gt;
&lt;p&gt;思ったこと&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一冊のページ数が少ない上に，それぞれの話も短いので，作者の文体もあいまってサクサク読める&lt;/li&gt;
&lt;li&gt;「ルンババ12」や谷口氏の名前が出てきて，舞城作品だなってのを実感する&lt;/li&gt;
&lt;li&gt;珍しく分かりやすい気がする&lt;/li&gt;
&lt;li&gt;ちゃんとしたミステリ&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ABC211の解説</title>
      <link>https://t45k.github.io/kyopuro/abc211/</link>
      <pubDate>Mon, 26 Jul 2021 22:41:46 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc211/</guid>
      <description>&lt;p&gt;4完速解き失敗でレートが微減．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC211&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---blood-pressure&#34;&gt;A - Blood Pressure&lt;/h2&gt;
&lt;p&gt;けつあつそくてい．&lt;code&gt;double&lt;/code&gt;で計算する．&lt;/p&gt;
&lt;h2 id=&#34;b---cycle-hit&#34;&gt;B - Cycle Hit&lt;/h2&gt;
&lt;p&gt;セットを使うなり事前にソートするなりする．&lt;/p&gt;
&lt;h2 id=&#34;c---chokudai&#34;&gt;C - chokudai&lt;/h2&gt;
&lt;p&gt;一部で炎上していた問題．簡単なDP&lt;/p&gt;
&lt;h2 id=&#34;d---number-of-shortest-paths&#34;&gt;D - Number of Shortest paths&lt;/h2&gt;
&lt;p&gt;基本的にはダイクストラ．&lt;br&gt;
距離とは別に経路数の情報を持っておき，ある節点に到達したとき，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;その節点での距離の最小値を更新した場合，経路数をその経路の値に置き換える&lt;/li&gt;
&lt;li&gt;その節点での距離の最小値と同じ距離だった場合，経路数を足し合わせる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;という操作を行う&lt;/p&gt;
&lt;h2 id=&#34;e---red-polyomino&#34;&gt;E - Red Polyomino&lt;/h2&gt;
&lt;p&gt;解説AC．解きたかった．
赤に塗った盤面を全て記録しておいても十分メモリに余裕がある．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC210の解説</title>
      <link>https://t45k.github.io/kyopuro/abc210/</link>
      <pubDate>Sun, 18 Jul 2021 14:18:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc210/</guid>
      <description>&lt;p&gt;四完青パフォ。
今回は D 速解きがそこそこ上手くいった一方で、E に歯が立たなかったので精進したい。
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC210&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---cabbages&#34;&gt;A - Cabbages&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;A &amp;gt; N&lt;/code&gt;になりうるのがポイント&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A が N よりも小さい場合、A 個を X 円で買って、(N-A)個を Y 円で買う&lt;/li&gt;
&lt;li&gt;A が N 以上の場合、N 個を X 円で買う&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;と場合分けする。&lt;/p&gt;
&lt;h2 id=&#34;b---bouzu-mekuri&#34;&gt;B - Bouzu Mekuri&lt;/h2&gt;
&lt;p&gt;愚直にシミュレーションする。
文字列を先頭から見ていき、初めに坊主を引いた方が負け。&lt;br&gt;
&lt;code&gt;Stream#findFirst&lt;/code&gt;を使うとすっきり書ける。&lt;/p&gt;
&lt;h2 id=&#34;c---colorful-candies&#34;&gt;C - Colorful Candies&lt;/h2&gt;
&lt;p&gt;範囲内の飴ちゃんの種類を最大にする問題&lt;br&gt;
範囲をスライドさせていく。
具体的には、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;まずは先頭 K 個の飴の色と出現回数を辞書等を使って数えておく。この時の種類数を&lt;code&gt;X&lt;/code&gt;とする。&lt;/li&gt;
&lt;li&gt;K+1 個目の飴の出現回数を 1 増やし、1 個目の飴を出現回数を 1 減らす。
この時、K+1 個目の飴が初登場なら&lt;code&gt;X&lt;/code&gt;を 1 増やし、1 個目の飴の出現回数が 0 になったら&lt;code&gt;X&lt;/code&gt;を 1 減らす。&lt;/li&gt;
&lt;li&gt;上の操作を、範囲をずらしながら繰り返す&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt;の最大値が答え&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;d---national-railway&#34;&gt;D - National Railway&lt;/h2&gt;
&lt;p&gt;意外と難しかったらしい。&lt;br&gt;
まずは簡単のために 1 行しかない場合を考える。&lt;/p&gt;
&lt;p&gt;dp[i]の値は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左隣から直接線路を作る&lt;/li&gt;
&lt;li&gt;左隣で最小の費用を考慮して線路を作る&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;の最小値になる。
後者に関しては、左隣での費用は&amp;quot;どこかから左隣まで&amp;quot;線路を作った時の値になっているので、
左隣の地価を引いて今見ている土地の地価と C を足せば良い。
つまり&lt;code&gt;左隣での値 - A[i-1] + A[i+1] + C&lt;/code&gt;になる。&lt;/p&gt;
&lt;p&gt;これを&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左上から右下に行く場合&lt;/li&gt;
&lt;li&gt;右上から左下に行く場合&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;の 2 通りについてシミュレーションすれば良い。&lt;/p&gt;
&lt;h2 id=&#34;e---ring-mst&#34;&gt;E - Ring MST&lt;/h2&gt;
&lt;p&gt;解説 AC。ユーザ解説が分かりやすいのでおすすめ。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.hamayanhamayan.com/entry/2021/07/17/233253&#34;&gt;https://blog.hamayanhamayan.com/entry/2021/07/17/233253&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC209の解説</title>
      <link>https://t45k.github.io/kyopuro/abc209/</link>
      <pubDate>Sat, 10 Jul 2021 23:14:52 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc209/</guid>
      <description>&lt;p&gt;四完速解きで青パフォ．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC209&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---counting&#34;&gt;A - Counting&lt;/h2&gt;
&lt;p&gt;基本的には&lt;code&gt;B-A-1&lt;/code&gt;だが，&lt;code&gt;A&amp;gt;B&lt;/code&gt;の時に限り0となる.
&lt;code&gt;max(B-A-1, 0)&lt;/code&gt;とすれば多少は楽．&lt;/p&gt;
&lt;h2 id=&#34;b---can-you-buy-them-all&#34;&gt;B - Can you buy them all?&lt;/h2&gt;
&lt;p&gt;偶数番目の商品だけ-1して総和を計算するだけ．&lt;/p&gt;
&lt;h2 id=&#34;c---not-equal&#34;&gt;C - Not Equal&lt;/h2&gt;
&lt;p&gt;まず，整数列を昇順にソートしても求めたい値は変わらない．&lt;br&gt;
1番目の値は全ての値から選ぶことができる．
2番目の値は1番目に選んだ値以外の値を選ぶので，&lt;code&gt;C2 - 1&lt;/code&gt;通りから選べる．
このとき，昇順にソートしているので選ぶ値の上限を考える必要がない．
このように考えると，i番目の値は&lt;code&gt;Ci - (i-1)&lt;/code&gt;から選ぶことができる．
このとき，&lt;code&gt;(i-1) &amp;gt;= Ci&lt;/code&gt;となると値を選べなくなるので答えは0になる．&lt;br&gt;
そうでない場合，答えは全ての選べる値を掛け合わせた値になる．&lt;/p&gt;
&lt;h2 id=&#34;d---collision&#34;&gt;D - Collision&lt;/h2&gt;
&lt;p&gt;問題文から，与えられたグラフが木構造であることが分かる．&lt;br&gt;
木構造の場合，ある節点(a,b)の距離の偶奇は，頂点を一つ定めたときの&lt;code&gt;(頂点からaまでの距離)-(頂点からbまでの距離)&lt;/code&gt;となる．&lt;br&gt;
これは，例えば(a,b)の最小共通祖先をc，頂点（適当な節点）をd，二つの節点の距離を&lt;code&gt;dis(x,y)&lt;/code&gt;と表す時，&lt;code&gt;(頂点からaまでの距離)-(頂点からbまでの距離)&lt;/code&gt;の偶奇は&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;(dis(d,a) - dis(d,b)) % 2 
= (dis(d,c) + dis(c,a) + dis(d,c) + dis(c,b)) % 2
= (dis(d,c) * 2 + dis(c,a) + dis(c,b)) % 2
= (dis(c,a) + dis(c,b)) % 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;でa，b間の距離の偶奇と一致するからである．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC208の解説</title>
      <link>https://t45k.github.io/kyopuro/abc208/</link>
      <pubDate>Sun, 04 Jul 2021 23:45:41 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc208/</guid>
      <description>&lt;p&gt;5完．初の黄パフォ．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC208&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---rolling-dice&#34;&gt;A - Rolling Dice&lt;/h2&gt;
&lt;p&gt;Bの平均値について考えればよい．
平均が1以上6以下なら達成可能．&lt;/p&gt;
&lt;h2 id=&#34;b---factorial-yen-coin&#34;&gt;B - Factorial Yen Coin&lt;/h2&gt;
&lt;p&gt;大きい硬貨から貪欲に計算していく&lt;/p&gt;
&lt;h2 id=&#34;c---fair-candy-distribution&#34;&gt;C - Fair Candy Distribution&lt;/h2&gt;
&lt;p&gt;初めに国民番号で国民をソートしておく．
国民番号の上位&lt;code&gt;K%N&lt;/code&gt;人は余計に1個多くもらえる．&lt;/p&gt;
&lt;h2 id=&#34;d---shortest-path-queries-2&#34;&gt;D - Shortest Path Queries 2&lt;/h2&gt;
&lt;p&gt;ワーシャルフロイドを応用する．ワーシャルフロイドについては&lt;a href=&#34;../warshallfloyd/&#34;&gt;こちら&lt;/a&gt;を参照．
ワーシャルフロイドの中継点を&lt;code&gt;k&lt;/code&gt;とすると，&lt;code&gt;Math.min(graph[i][j], graph[i][k] + graph[k][j])&lt;/code&gt;はiスタートjゴールでk以下の箇所を経由した際の最短距離となるので，問題に適当．&lt;/p&gt;
&lt;h2 id=&#34;e---digit-products&#34;&gt;E - Digit Products&lt;/h2&gt;
&lt;p&gt;たまたま解けた問題．桁DP．&lt;br&gt;
桁DPとは，ある値&lt;code&gt;N&lt;/code&gt;が与えられたときに各桁に対する遷移を以下のように行うDPを指す．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一つ前で見ている桁の時点で，数字が&lt;code&gt;N&lt;/code&gt;以下であることが確定している場合，&lt;code&gt;0~9&lt;/code&gt;に遷移する&lt;/li&gt;
&lt;li&gt;数字が&lt;code&gt;N&lt;/code&gt;以下であることが確定していない場合，&lt;code&gt;0~(今見ている桁の数-1)&lt;/code&gt;への遷移（つまり，状態1に遷移する）と今見てる桁への遷移（状態2）への遷移を行う&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今回は，各桁の積が&lt;code&gt;K&lt;/code&gt;以下になれば良いのだが，このとき積は十分に疎になるので連想配列などで持てば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Keychron K3を購入した話</title>
      <link>https://t45k.github.io/blog/keychron/</link>
      <pubDate>Fri, 11 Jun 2021 22:35:53 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/keychron/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.keychron.com/products/keychron-k3-wireless-mechanical-keyboard&#34;&gt;Keychron K3&lt;/a&gt;を購入しました．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/keychron_box.JPG&#34; alt=&#34;keychron_box&#34;&gt;
&lt;img src=&#34;https://t45k.github.io/img/blog/keychron.JPG&#34; alt=&#34;keychron_box&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;経緯&#34;&gt;経緯&lt;/h2&gt;
&lt;p&gt;研究室ではRealforceを使っていたのですが，会社からはキーボードが支給されないと聞いたので，仕事用のキーボードを購入する必要が発生しました．
家では青軸のメカニカルキーボードを使っているので，その経験を踏まえて以下の要件を満たすキーボードを探しました．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会社はフリーアドレスなので持ち運びに困らない．具体的には以下の通り．
&lt;ul&gt;
&lt;li&gt;軽い&lt;/li&gt;
&lt;li&gt;薄い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;十分にコンパクト．個人的にはmagic keyboardと同じ配列がベスト&lt;/li&gt;
&lt;li&gt;もちろんUS配列&lt;/li&gt;
&lt;li&gt;Fn必須&lt;/li&gt;
&lt;li&gt;赤か茶軸のメカニカル，あるいは静電容量無接点&lt;/li&gt;
&lt;li&gt;できればmac対応&lt;/li&gt;
&lt;li&gt;新卒のお給料でも買える．1万円前後&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fnが必要なことからHHKB，携帯性からRealforceは簡単に除外できました．
Nizも割と魅力的だったのですが，右下の配置が独特なことと高いことから除外しました．
メカニカルキーボードで上記の要件を満たすキーボードはいくつか見つかったのですが，
最終的に多機能かつ安価で評判も良い&lt;code&gt;Keychron K3&lt;/code&gt;にしました．&lt;/p&gt;
&lt;h2 id=&#34;注文から到着まで&#34;&gt;注文から到着まで&lt;/h2&gt;
&lt;p&gt;注文は公式サイトからできます．
英語での住所&amp;amp;電話番号入力が必要なので事前に調べておくと良いと思います．&lt;/p&gt;
&lt;p&gt;値段は本体74\$ + 配送料20\$の計94\$でした．
paypalで支払いしたところ2021年6月現在で10,802円でした．&lt;/p&gt;
&lt;p&gt;6月5日（土）の23時過ぎに注文して到着したのが10日（木）の夜でした．
日曜を挟んでいたのを考えると割と早く届きました．&lt;/p&gt;
&lt;h2 id=&#34;使用感&#34;&gt;使用感&lt;/h2&gt;
&lt;p&gt;ファーストインプレッション&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;感想&lt;br&gt;- サイズ感: 最高&lt;br&gt;- 打鍵感: 茶軸やけどロープロのせいで反発が弱め。同時押しになったり2回押しがうまくいかんかったりする&lt;br&gt;- キートップ: 柔らかめ、爪が食い込む感覚&lt;br&gt;- 傾斜: 低め、違和感ある&lt;br&gt;- レスポンス: 若干もっさりしてる&lt;br&gt;&lt;br&gt;総評: サイズ感は最高やけどそれ以外は慣れが必要かなぁ&lt;/p&gt;&amp;mdash; task@FSE (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1402946711660621826?ref_src=twsrc%5Etfw&#34;&gt;June 10, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;一日使ってみましたが，本当に慣れだと思います．
仕事が終わった後に家のキーボードを触ると，逆に重くてびっくりしました．
使っていくうちに好きになっていくと思います．
個人的にはdeleteを推すときのペチペチ音が好きです．&lt;/p&gt;
&lt;h2 id=&#34;総評&#34;&gt;総評&lt;/h2&gt;
&lt;p&gt;良い買い物をしたと思います．
現在は在宅なのですが，会社で使うのを楽しみにしています．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC200の解説</title>
      <link>https://t45k.github.io/kyopuro/abc200/</link>
      <pubDate>Sun, 16 May 2021 11:57:55 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc200/</guid>
      <description>&lt;p&gt;祝200回．
4完．&lt;/p&gt;
&lt;h2 id=&#34;a---century&#34;&gt;A - Century&lt;/h2&gt;
&lt;p&gt;やるだけ．
X00年はX世紀であることに注意．&lt;/p&gt;
&lt;h2 id=&#34;b---200th-abc-200&#34;&gt;B - 200th ABC-200&lt;/h2&gt;
&lt;p&gt;やるだけ．十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;c---ringos-favorite-numbers-2&#34;&gt;C - Ringo&amp;rsquo;s Favorite Numbers 2&lt;/h2&gt;
&lt;p&gt;Ai-Aj=200ということはAi≡Aj(mod 200)であることなので，
各Aを，200で割ったあまりでグルーピングして組み合わせを計算すればよい．&lt;/p&gt;
&lt;h2 id=&#34;d---happy-birthday-2&#34;&gt;D - Happy Birthday! 2&lt;/h2&gt;
&lt;p&gt;解説が賢い．&lt;/p&gt;
&lt;p&gt;先頭8個のAを見ると，2^8-1&amp;gt;200から鳩の巣原理から必ずmod200が被る和の組み合わせが存在する．
bit全探索するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---patisserie-abc-2&#34;&gt;E - Patisserie ABC 2&lt;/h2&gt;
&lt;p&gt;きれいさ，おいしさ，人気度をそれぞれa,b,cとする．&lt;/p&gt;
&lt;p&gt;a+b+cの小さい順に何通りあるかを確認していく(&lt;code&gt;3 &amp;lt;= sum &amp;lt;= 3*N&lt;/code&gt;)．
b,cが1以上N以下でないといけないことから，aの範囲は &lt;code&gt;max(1,sum-2n) &amp;lt;= a &amp;lt;= min(n,sum-2)&lt;/code&gt;．
このとき，bの範囲は &lt;code&gt;max(1,sum-a-n) &amp;lt;= b &amp;lt;= min(n,sum-a-1)&lt;/code&gt;．
a,bが決まればcは一意に定まる．
このことから，a+b+cの和がsumの時，
&lt;code&gt;Σ(a=max(1,sum-2n)~min(n,sum-2))(min(n,sum-a-1)-max(1,sum-a-n)+1)&lt;/code&gt; 通りの選び方がある．
これをO(1)で求める．&lt;/p&gt;
&lt;p&gt;まず，bの値をaで場合分けする（min，maxを固定する）と&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a &amp;gt;= sum-n-1&lt;/code&gt; の時，&lt;code&gt;b = sum-a-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a &amp;lt;= sum-n-1&lt;/code&gt; の時，&lt;code&gt;b = 2n+a-s+1&lt;/code&gt; となる
そこで，aの最小値と最大値から累積和の公式を用いてsumの時の選び方を求められる&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ZONeエナジー プログラミングコンテスト “HELLO SPACE” の解説</title>
      <link>https://t45k.github.io/kyopuro/zone2021/</link>
      <pubDate>Sat, 15 May 2021 20:51:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/zone2021/</guid>
      <description>&lt;p&gt;奇跡的に5完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/zone2021&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---ufo襲来&#34;&gt;A - UFO襲来&lt;/h2&gt;
&lt;p&gt;やるだけ&lt;/p&gt;
&lt;h2 id=&#34;b---友好の印&#34;&gt;B - 友好の印&lt;/h2&gt;
&lt;p&gt;UFOとタワーの頂上を通る直線のy切片を求める．&lt;/p&gt;
&lt;h2 id=&#34;c---mad-team&#34;&gt;C - MAD TEAM&lt;/h2&gt;
&lt;p&gt;通したけど嘘解法っぽい．
想定解法は二分探索．&lt;/p&gt;
&lt;p&gt;3人選ばないといけないのに対してN=3,000から二重ループまでしか回せない．
各要素が大きい人を選ぶほど良い結果を期待できる．
つまり，各要素でソートして，上三つだけ残しておく．
そして，ある二人を選んだ後に各要素のトップを加えてみて総合力を計算すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---宇宙人からのメッセージ&#34;&gt;D - 宇宙人からのメッセージ&lt;/h2&gt;
&lt;p&gt;両端キューなどに対して文字を突っ込んでいく．
このときに重複を排除する．&lt;/p&gt;
&lt;h2 id=&#34;e---潜入&#34;&gt;E - 潜入&lt;/h2&gt;
&lt;p&gt;ダイクストラをする．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>第二回日本最強プログラマー学生選手権の解説</title>
      <link>https://t45k.github.io/kyopuro/jsc2021/</link>
      <pubDate>Sun, 02 May 2021 17:02:14 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/jsc2021/</guid>
      <description>&lt;p&gt;5完393位でパフォーマンス爆盛りした回。
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/jsc2021&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---competition&#34;&gt;A - Competition&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;X,Y,Z&amp;lt;=10^3&lt;/code&gt;から、整数iに対して&lt;code&gt;Y/X &amp;gt; i/Z&lt;/code&gt;を満たす最大の値を探す。
&lt;code&gt;X=1,Y=1000,Z=1000&lt;/code&gt;の時&lt;code&gt;i=999999&lt;/code&gt;で最大になるので、そこから降順に探す。&lt;/p&gt;
&lt;h2 id=&#34;b---xor-of-sequences&#34;&gt;B - Xor of Sequences&lt;/h2&gt;
&lt;p&gt;やるだけ。
Set等で管理する。&lt;/p&gt;
&lt;h2 id=&#34;c---max-gcd-2&#34;&gt;C - Max GCD 2&lt;/h2&gt;
&lt;p&gt;2からBの間で、AからBの間に2つの倍数を持つ最大の整数を求めれば良い。
ある整数をiとすると、A以上の最小のiの倍数は&lt;code&gt;(A + i - 1) / i * i&lt;/code&gt;、
B以下の最大のiの倍数は&lt;code&gt;B/i*i&lt;/code&gt;で求まるので、この二つの値が異なる最大のiを求める。&lt;/p&gt;
&lt;h2 id=&#34;d---nowhere-p&#34;&gt;D - Nowhere P&lt;/h2&gt;
&lt;p&gt;まず&lt;code&gt;A_1&lt;/code&gt;は1からP-1の&lt;code&gt;P-1&lt;/code&gt;通り選べる。
次に&lt;code&gt;A_2&lt;/code&gt;については1からP-1で、&lt;code&gt;P-A_1&lt;/code&gt;でない&lt;code&gt;P-2&lt;/code&gt;通りが選べる。
&lt;code&gt;A_3&lt;/code&gt;以降についても、&lt;code&gt;P-sum%P&lt;/code&gt;以外の&lt;code&gt;P-2&lt;/code&gt;通りが選べるので、答えは&lt;code&gt;(P-1)*(P-2)^(N-1)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;e---level-k-palindrome&#34;&gt;E - Level K Palindrome&lt;/h2&gt;
&lt;p&gt;基本的には、回文で対応する文字に対して、一番出現する文字に書き換えていく。&lt;/p&gt;
&lt;p&gt;まずはレベルを満たす最小の文字列に分解していく。
基本的には文字列を半分にするのを繰り返していく。
この時、各折り返し点が異なっている場合は書き換える。&lt;/p&gt;
&lt;p&gt;次に、それぞれの文字列を同一にしていく。
これは、各文字列の同じ位置に存在する文字のうち、マジョリティに書き換える。&lt;/p&gt;
&lt;p&gt;最後に各文字列が回文だった場合、そうならない様に書き換える。
これは、一つ前のマジョリティに書き換える処理を行う際に2番目に多い文字を記録しておき、
（中間点以外の）どこか一箇所をそれに書き換えれば良い。&lt;/p&gt;
&lt;h2 id=&#34;f---max-matrix&#34;&gt;F - Max Matrix&lt;/h2&gt;
&lt;p&gt;解説AC&lt;/p&gt;
&lt;p&gt;出現した値をインデックス、出現回数をバリューとしたセグ木を構築するとうまくいく。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaでN個の入力を良い感じにリストにする方法</title>
      <link>https://t45k.github.io/kyopuro/stream/</link>
      <pubDate>Sun, 18 Apr 2021 18:05:46 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/stream/</guid>
      <description>&lt;p&gt;これが多分ベスト&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Stream.generate(scanner::nextInt)
  .limit(N)
  .collect(Collectors.toList());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配列にしたいときは&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Stream.generate(scanner::nextInt)
  .limit(N)
  .mapToInt(Integer::intValue)
  .toArray();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>ABC198の解説</title>
      <link>https://t45k.github.io/kyopuro/abc198/</link>
      <pubDate>Sun, 18 Apr 2021 17:47:27 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc198/</guid>
      <description>&lt;p&gt;ABCEの4完。
その後Dを通した。
惜しかった。
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC198&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---div&#34;&gt;A - Div&lt;/h2&gt;
&lt;p&gt;A君1個B君N-1個~A君N-1個B君1個までのN-1通り&lt;/p&gt;
&lt;h2 id=&#34;b---palindrome-with-leading-zeros&#34;&gt;B - Palindrome with leading zeros&lt;/h2&gt;
&lt;p&gt;意外と面倒臭い&lt;br&gt;
後ろの0を全て削ってから回文確認をする&lt;/p&gt;
&lt;h2 id=&#34;c---compass-walking&#34;&gt;C - Compass Walking&lt;/h2&gt;
&lt;p&gt;点(X,Y)までの距離がRの倍数だったらそのまま割る。
そうでなければ、直前まで直線に向かい、そこから2歩使って到着するのが最善。&lt;br&gt;
点(X,Y)がR未満の時答えが2になることに注意。&lt;/p&gt;
&lt;h2 id=&#34;d---send-more-money&#34;&gt;D - Send More Money&lt;/h2&gt;
&lt;p&gt;覆面算の条件から、使えるアルファベットは10種類以内になる（逆に、アルファベットが11種類以上の時、鳩の巣原理から数字が被ってしまう）。
あとは0~9までの順列をアルファベットに対応させて検証すれば良い。&lt;/p&gt;
&lt;h2 id=&#34;e---unique-color&#34;&gt;E - Unique Color&lt;/h2&gt;
&lt;p&gt;木を深さ優先探索する。
今までに出現した色を記録する配列を&lt;code&gt;boolean[10^5+1]&lt;/code&gt;とすると、以下のようなdfsで答えが求まる。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;頂点&lt;code&gt;x&lt;/code&gt;に到達した時、&lt;code&gt;x&lt;/code&gt;の色に対応する配列の値が&lt;code&gt;false&lt;/code&gt;だった場合、
&lt;code&gt;x&lt;/code&gt;と頂点1からのパスに&lt;code&gt;x&lt;/code&gt;の色が存在しないので、&lt;code&gt;x&lt;/code&gt;はよい頂点になる。&lt;/li&gt;
&lt;li&gt;逆に配列が&lt;code&gt;true&lt;/code&gt;だった場合、よい頂点ではない。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;の色に対応する配列の値を&lt;code&gt;true&lt;/code&gt;にする。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;の子に対して再帰的に上の手順を当てる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;から登っていく（再帰関数を抜ける）時、&lt;code&gt;x&lt;/code&gt;がよい頂点だったら、配列の値を&lt;code&gt;false&lt;/code&gt;にしておく。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>作ったもの</title>
      <link>https://t45k.github.io/product/</link>
      <pubDate>Thu, 25 Mar 2021 11:07:17 +0900</pubDate>
      
      <guid>https://t45k.github.io/product/</guid>
      <description>&lt;h2 id=&#34;githubcontributionbothttpsgithubcomt45kghcbotforlambda&#34;&gt;&lt;a href=&#34;https://github.com/T45K/GHCBotForLambda&#34;&gt;GitHubContributionBot&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;GitHubのコントリビューション（草の生え具合）についてTwitterで報告してくれるボット．
0時になると&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;その日のコントリビューション数&lt;/li&gt;
&lt;li&gt;その日までの連続コントリビューション日数（Streak）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を呟いてくれる．&lt;/p&gt;
&lt;p&gt;技術的には定時にGitHubのトップページをスクレイピングしてるだけ．&lt;/p&gt;
&lt;h2 id=&#34;clionehttpsgithubcomt45kclione&#34;&gt;&lt;a href=&#34;https://github.com/T45K/CLIONE&#34;&gt;CLIONE&lt;/a&gt;&lt;/h2&gt;
&lt;img src=&#34;https://t45k.github.io/img/logo.png&#34; width=&#34;20%&#34;&gt;
&lt;p&gt;類似コードの修正漏れを教えてくれるボット．
GitHub Appsを用いて設計されていて，PRの作成ごとに勝手に通知を飛ばしてくれる．&lt;/p&gt;
&lt;p&gt;論文は&lt;a href=&#34;https://sdl.ist.osaka-u.ac.jp/pman/pman3.cgi?D=675&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;nilhttpsgithubcomkusumotolabnil&#34;&gt;&lt;a href=&#34;https://github.com/kusumotolab/NIL&#34;&gt;NIL&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;類似コード検出ツール．&lt;/p&gt;
&lt;p&gt;既存のツールでは検出が難しかった「コピペされた後に大量の変更が行われた類似コード」を検出できるように設計されている．
また，N-gramと転置索引を組み合わせることで高速な検出が可能となっている．&lt;/p&gt;
&lt;p&gt;論文は&lt;a href=&#34;https://sdl.ist.osaka-u.ac.jp/pman/pman3.cgi?D=669&#34;&gt;こちら&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>大阪大学大学院情報科学研究科修士課程を修了した話</title>
      <link>https://t45k.github.io/blog/graduation/</link>
      <pubDate>Wed, 24 Mar 2021 21:17:20 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/graduation/</guid>
      <description>&lt;p&gt;2021年3月24日をもって修士課程を修了しました．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-partner=&#34;tweetdeck&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;3年間の戦績は&lt;br&gt;&lt;br&gt;論文誌採録*1&lt;br&gt;論文誌条件付き採録*1&lt;br&gt;国際会議採録*2&lt;br&gt;国際会議査読中*1&lt;br&gt;研究会原稿*3&lt;br&gt;で現状不採録0です&lt;br&gt;&lt;br&gt;対ありでした&lt;/p&gt;&amp;mdash; task@減塩 (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1374691521174282242?ref_src=twsrc%5Etfw&#34;&gt;March 24, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;研究室に所属して3年間色んなことがあった気がするので書き留めておきます．&lt;/p&gt;
&lt;h2 id=&#34;所属前&#34;&gt;所属前&lt;/h2&gt;
&lt;p&gt;大学に入学してからプログラミングを始めたが結構楽しめていたので，「ソースコードを書くこと」について研究できれば良いなぁと漠然と考えていた．
阪大基礎工学部情報科学科では3回生の時に各研究室の先生に着いてゼミが行われるので，前期後期ともにソフトウェア工学の研究室のゼミに参加した．
前半は「リファクタリング」について，後半は「ソースコードメトリクス」についてのゼミで，前半にゼミを担当していた先生が何となく面白そうだったので，その研究室の配属を目標にした．&lt;/p&gt;
&lt;h2 id=&#34;b4&#34;&gt;B4&lt;/h2&gt;
&lt;h3 id=&#34;4月&#34;&gt;4月&lt;/h3&gt;
&lt;p&gt;無事目標の研究室に配属．
配属後リファクタリング的なネタをやりたいと伝える．
論文を渡されてネタを探すように言われる．
当然研究室に入ったばかりで自分ですんなりネタを決めれるわけもなく，
指導教員の先生とミーティングをするも会話が噛み合わないことが多く，
険悪な雰囲気になることが多かった気がする
（主観的だが，口調が若干きつかったと感じることが多かった）．
この頃から何となく「この先生とは一生分かり合えないんだろうなぁ」って思うようになり，苦手になる．&lt;/p&gt;
&lt;h3 id=&#34;6月&#34;&gt;6月&lt;/h3&gt;
&lt;p&gt;ネタが決まる（先生が決めてくれた）のでとりあえずやっていく．
相変わらずミーティングでは嚙み合わないことが多かった．
まあB4のはじめの頃はみんなこんなもんだろうと思い込んで過ごす．
「研究室 辛い」などで検索するようになる．
自分の打たれ弱さを実感する．&lt;/p&gt;
&lt;h3 id=&#34;7月&#34;&gt;7月&lt;/h3&gt;
&lt;p&gt;院試休み．
研究室行かずに済んでラッキーくらいの気持ちでいた．
院試で研究室変えるのも手だったが負けた気分になるのでそのまま出した．
院試後はそのまま夏休みだったのでしばらく研究のことを忘れる．&lt;/p&gt;
&lt;h3 id=&#34;10月&#34;&gt;10月&lt;/h3&gt;
&lt;p&gt;研究が再開する．
少しずつ進めていくが，コミュニケーションも含めて上手くいかないことが圧倒的に多くなり，常に辛い状態になる．
この頃から常に死にたいと思うようになる．
バイク運転中に信号無視した車が突っ込んできたらなぁみたいなことをずっと考えていた．
しばらくそんな感じ．&lt;/p&gt;
&lt;p&gt;同時期に，たまたまTwitter上でPaizaの広告を見かける．
プログラミング能力を客観的に評価してもらえることがそれまでほとんどなかったことと，
研究が辛くなった時のために就職も考えないとということでとりあえずやってみる．
Paizaは解答解説がないので，プログラミング力を付けるのには不向きだと思い，
AtCoderをやり始める．&lt;/p&gt;
&lt;h3 id=&#34;1月&#34;&gt;1月&lt;/h3&gt;
&lt;p&gt;論文を書き始める．
先生と添削のやり取りをするのだが，常に詰められてるように感じて辛くなる．
悪いことは続くもので，比較実験を行う必要があるのだが
既存研究が使ってたツールが上手く動かなくて全然実験が進まなくなる．
時間がないのでとりあえず不完全なまま卒論と研究会論文を書き上げる．&lt;/p&gt;
&lt;p&gt;あと自分の実装を見てもらう機会があったのだが，
あまりにもひどかったため研究が一段落着いたらツール作り直したほうが良いかもねって話になる．
今思えば草．&lt;/p&gt;
&lt;h3 id=&#34;3月&#34;&gt;3月&lt;/h3&gt;
&lt;p&gt;研究会発表をする．&lt;/p&gt;
&lt;p&gt;ツール作り直しをする．
作り直しに際して，研究室の実装が得意な先輩に付きっ切りで見てもらいながらプログラミングを一から叩き込んでもらう．
この指導，本当にありがたく，プログラミングの基礎的ながらも重要な要素をいくつも教えてもらった．
これがなかったら実装力が重視されるウェブエンジニアを職業にするという選択肢は取れなかったと思う．&lt;/p&gt;
&lt;h2 id=&#34;m1&#34;&gt;M1&lt;/h2&gt;
&lt;h3 id=&#34;4月-1&#34;&gt;4月&lt;/h3&gt;
&lt;p&gt;同期が増える．
またこれまで必要な日にしか研究室に来てなかった同期と，授業の関係でほぼ毎日顔を合わせてコミュニケーションを取るようになった．
他人とコミュニケーションを取るのは本当に大切で，研究の辛さが和らいでいく感じがした．&lt;/p&gt;
&lt;p&gt;研究の方は，自分のツールの作り直しはしたが既存ツールを動かすのがまだできてなかったので，
それをずっとやっていた．&lt;/p&gt;
&lt;h3 id=&#34;6月-1&#34;&gt;6月&lt;/h3&gt;
&lt;p&gt;まだ既存ツールが動かない．
先生がしびれを切らして，7月末の国際会議に投稿することを求められる．
個人的にはここまで来てできなかったんだからこのネタは諦めて違うことをした方が有益な気はしていた
（自分のネタに自信がなく，続けるのが辛かったいうのもあった）．&lt;/p&gt;
&lt;h3 id=&#34;7月-1&#34;&gt;7月&lt;/h3&gt;
&lt;p&gt;未だに既存ツールが動かなかったので，比較対象を変えることでとりあえず原稿を書き上げて投稿．&lt;/p&gt;
&lt;h3 id=&#34;8月&#34;&gt;8月&lt;/h3&gt;
&lt;p&gt;インターンとかに行く．
3月の先輩の指導+競プロでLINEとかの有名会社のインターンに行けたのは結構大きかった．&lt;/p&gt;
&lt;h3 id=&#34;9月&#34;&gt;9月&lt;/h3&gt;
&lt;p&gt;何か国際会議に通る．
かなり嬉しかったし，報われた気分になった．
先生との関係がマシになる．&lt;/p&gt;
&lt;h3 id=&#34;10月-1&#34;&gt;10月&lt;/h3&gt;
&lt;p&gt;国際会議に通ったのでこのネタは終わりにしたかったが，ボスに論文誌にするように求められる．
また既存ツールを動かす地獄の日々が始まる．
同時並行で新ネタをやり始める．&lt;/p&gt;
&lt;h3 id=&#34;12月&#34;&gt;12月&lt;/h3&gt;
&lt;p&gt;国際会議発表．
既存ツールがまだ動かなかったので友達に相談する．
3日で解決してくれる．
新ネタは結果が出なくてやる意義を見失いかけてたので打ち切る．&lt;/p&gt;
&lt;h3 id=&#34;1月-1&#34;&gt;1月&lt;/h3&gt;
&lt;p&gt;比較実験をし，論文誌原稿を書き上げる．
新ネタは全然決まらず，&lt;br&gt;
論文読む -&amp;gt; 先生と相談する -&amp;gt; 簡単に実装して実験してみる （-&amp;gt; 上手くいかない）&lt;br&gt;
みたいな流れを延々とやり続ける．
何となくクローン以外のことをしたいと考えてた．&lt;/p&gt;
&lt;h3 id=&#34;3月-1&#34;&gt;3月&lt;/h3&gt;
&lt;p&gt;日本でもコロナが流行り始める．
研究室は4月から行けなくなるらしかったので，家の環境を整える．
家だと作業できない人間だったのでかなり不安だった．
論文を紙で読めなくなるのが割と痛かった．&lt;/p&gt;
&lt;h3 id=&#34;4月-2&#34;&gt;4月&lt;/h3&gt;
&lt;p&gt;家研究スタート．
新ネタを決めることから始める．
論文読んでる，何となく「CI × ソースコード解析」が流行ってそうだったので，
「CI × クローン管理」を思いつく．
結局クローンに帰って来る．&lt;/p&gt;
&lt;p&gt;サーバサイドの実装になったので，割と楽しんでやれた．
家だったので効率は微妙だったが，すっと実験まで持って行けた気がする．&lt;/p&gt;
&lt;h3 id=&#34;5月&#34;&gt;5月&lt;/h3&gt;
&lt;p&gt;緊急事態宣言が明けたが，6月まで研究室に来てはいけないみたいなことを言われる．
ガン無視して週1か2くらいのペースで研究室に行く．
この頃から先生との関係が良好になり始める．&lt;/p&gt;
&lt;h3 id=&#34;7月-2&#34;&gt;7月&lt;/h3&gt;
&lt;p&gt;とりあえず国際会議に投げるように言われたので投げる．
結構余裕があった気がする．&lt;/p&gt;
&lt;h3 id=&#34;8月-1&#34;&gt;8月&lt;/h3&gt;
&lt;p&gt;国際会議に落ちると，このままだと一年間論文なしというカッコ悪い結果になるのでとりあえず研究会に投げることを決める．&lt;/p&gt;
&lt;h3 id=&#34;9月-1&#34;&gt;9月&lt;/h3&gt;
&lt;p&gt;追加の実験をする．
有名OSSにプルリクがマージされたりする．
このペースだと11月中には全てのデータが出揃って修論まで暇になる予感がした．
そしてそのままだと11月から修論まで新しいネタをやれって言われる予感がした．
なので，先手を打って新ネタを始めることにした．
論文漁ってると結果は良い感じだけどアルゴリズムに改善の余地がありそうなクローン検出に関する研究が見つかったのでそれの改善をやってみることにする．
やっといて結果が出なかったらカッコ悪いので，先生に秘密で実装と実験をやる．&lt;/p&gt;
&lt;p&gt;国際会議には通ってた．&lt;/p&gt;
&lt;h3 id=&#34;10月-2&#34;&gt;10月&lt;/h3&gt;
&lt;p&gt;旧ネタのデータが出揃ったので論文誌を書くことになる．
と同時に新ネタが良い結果が出始めたので先生と共有する．&lt;/p&gt;
&lt;h3 id=&#34;11月&#34;&gt;11月&lt;/h3&gt;
&lt;p&gt;1月に投げた論文誌が条件付き採録で帰って来る．
割とびっくりした．
なのでこの時期は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卒論ネタの論文誌の回答書&lt;/li&gt;
&lt;li&gt;旧ネタの論文誌&lt;/li&gt;
&lt;li&gt;旧ネタの国際会議の発表準備&lt;/li&gt;
&lt;li&gt;新ネタの実験&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;を平行で回していくことになった．
とりあえず旧ネタの論文誌を投げる．&lt;/p&gt;
&lt;h3 id=&#34;12月-1&#34;&gt;12月&lt;/h3&gt;
&lt;p&gt;国際会議発表．
オンラインなので準備にあまり時間を割かずに済んだ．&lt;/p&gt;
&lt;p&gt;回答書も書いた．&lt;/p&gt;
&lt;p&gt;修論を考える時期になる．
卒論ネタを含めると3つのネタがあったので，修論に全部ぶち込むことにした．&lt;/p&gt;
&lt;p&gt;新ネタも実験結果が着々と出始めたので，国際会議に投稿することにする．&lt;/p&gt;
&lt;h3 id=&#34;1月-2&#34;&gt;1月&lt;/h3&gt;
&lt;p&gt;新ネタの結果が思いのほか良かったので投稿先のランクを上げる．
修論は100ページ書けそうな予感がしたのでそこを目標にする．&lt;/p&gt;
&lt;p&gt;旧ネタの論文誌が条件付き採録になって帰って来る．
締め切りが3月末までだったのと，再実験が必要でまとまった時間がいるので簡単なとこだけ先にやって放置する．
春休みも実験が確定する．&lt;/p&gt;
&lt;p&gt;新ネタを研究会に出すことにしたので，論文が4並列になる．&lt;/p&gt;
&lt;h3 id=&#34;2月&#34;&gt;2月&lt;/h3&gt;
&lt;p&gt;修論発表．
修論発表が終わった後も色々あった．
企業mtgとか新ネタ論文投稿とか．&lt;/p&gt;
&lt;h3 id=&#34;3月-2&#34;&gt;3月&lt;/h3&gt;
&lt;p&gt;研究会発表．
旧ネタ再実験．
学位授与式の日に論文を再投稿する．&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;振り返ってみると，B4の時は辛かった一方でM2は一年間楽しんで研究できたなって印象です．
が，アカデミアはもう十分かなって気持ちになりました．
旧ネタの論文誌が採録されると一応博士の要件を満たすらしいので，仕事がクビになると帰って来るかも知れません．&lt;/p&gt;
&lt;p&gt;あとはやっぱりB4の3月のプログラミング指導は本当にありがたかったです．
今のところ人生のターニングポイントと言っても過言じゃないです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC196の解説</title>
      <link>https://t45k.github.io/kyopuro/abc196/</link>
      <pubDate>Sat, 20 Mar 2021 23:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc196/</guid>
      <description>&lt;p&gt;惜しくも4完．
E問題で一ヵ所凡ミスがあって1WAだった．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC196&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---difference-max&#34;&gt;A - Difference Max&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;x-y&lt;/code&gt;が最大になるのは&lt;code&gt;x&lt;/code&gt;が最大かつ&lt;code&gt;y&lt;/code&gt;が最小の時．
&lt;code&gt;x&lt;/code&gt;の最大値は&lt;code&gt;b&lt;/code&gt;であり，&lt;code&gt;y&lt;/code&gt;の最小値は&lt;code&gt;c&lt;/code&gt;なので，答えは&lt;code&gt;b-c&lt;/code&gt;．&lt;/p&gt;
&lt;h2 id=&#34;b---round-down&#34;&gt;B - Round Down&lt;/h2&gt;
&lt;p&gt;100桁の小数が与えられるので，Xを数値として読み込むのは厳しい．
一旦文字列として読み込み，それの整数部を計算する．
文字列中に&lt;code&gt;.&lt;/code&gt;が存在しないならその文字列をそのまま，
存在するなら&lt;code&gt;.&lt;/code&gt;で分割し，前半の文字列を出力すれ良い．&lt;/p&gt;
&lt;h2 id=&#34;c---doubled&#34;&gt;C - Doubled&lt;/h2&gt;
&lt;p&gt;一見難しそうに見えるが，全探索すれば良い．
12桁の整数全ては調べられないが，条件は&lt;code&gt;前半と後半が等しい&lt;/code&gt;なので，
下6桁まで(&lt;code&gt;1~999,999&lt;/code&gt;)だけを確認すれば良い．
&lt;code&gt;1~999,999&lt;/code&gt;までの数値を2回繰り返した整数がNよりも小さいかを判定する．&lt;/p&gt;
&lt;h2 id=&#34;d---hanjo&#34;&gt;D - Hanjo&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HW &amp;lt;= 16&lt;/code&gt;という条件から，全探索をしてみる．
1畳の畳の置き方の問題なので，半畳の方は考えなくて良い（余った箇所に詰めれる）．
部屋を1メートル毎に分割し&lt;code&gt;(i,j)&lt;/code&gt;と表現するとすると，
各&lt;code&gt;(i,j)&lt;/code&gt;に対して，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（置けるけど）畳を置かない&lt;/li&gt;
&lt;li&gt;畳を縦に置く&lt;/li&gt;
&lt;li&gt;畳を横に置く&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;の3通りの選び方があるので，再帰関数等を使って，
深さ優先探索で全てを試せば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---filters&#34;&gt;E - Filters&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;N&amp;lt;=2*10^5&lt;/code&gt;，&lt;code&gt;Q&amp;lt;=2*10^5&lt;/code&gt;から全ての&lt;code&gt;xi&lt;/code&gt;に対して各関数を当てると間に合わないので，
1つの関数を全&lt;code&gt;X&lt;/code&gt;に&lt;code&gt;log(Q)&lt;/code&gt;に当てることを考える．
そうすると，先に&lt;code&gt;X&lt;/code&gt;をソートしておいて，
関数を当てる箇所を二分探索で探せば良いことが何となく分かる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ti=1&lt;/code&gt;のとき，&lt;code&gt;ai&lt;/code&gt;の値は最後に加算しても問題ない．
&lt;code&gt;sum&lt;/code&gt;などの変数に加算しておき，最後に計算する．&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ti=2(max)&lt;/code&gt;のとき，&amp;ldquo;ソート済み&lt;code&gt;X&lt;/code&gt;の&lt;code&gt;ai&lt;/code&gt;以下の値が全て&lt;code&gt;ai&lt;/code&gt;になる&amp;quot;と考える．
二分探索で&lt;code&gt;ai&lt;/code&gt;以下の値の場所を求めて，その場所から左側の値は全て&lt;code&gt;ai&lt;/code&gt;になることを記録しておく．&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ti=3(min)&lt;/code&gt;のときも同様．&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ARC113の解説</title>
      <link>https://t45k.github.io/kyopuro/arc113/</link>
      <pubDate>Mon, 22 Feb 2021 15:03:58 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/arc113/</guid>
      <description>&lt;p&gt;ABCの3完で緑パフォ．&lt;a href=&#34;https://github.com/T45k/kyopuro/tree/master/AtCoder/ARC/ARC113&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---abc&#34;&gt;A - A&lt;em&gt;B&lt;/em&gt;C&lt;/h2&gt;
&lt;p&gt;実は一番時間がかかった問題．
Aを固定した時に，BとCの組み合わせは&lt;code&gt;O(K)&lt;/code&gt;で求まる
（BがNの時，Cは&lt;code&gt;1~K/N&lt;/code&gt;の値を取りうるので，組み合わせの個数は&lt;code&gt;K/N&lt;/code&gt;になる）．
よって，Aを1からKまで動かしつつ，&lt;code&gt;B*C&amp;lt;=K/A&lt;/code&gt;を満たすB*Cの組み合わせを求めることになる．
Aを動かしてもK/Aが変わらないときは，B，Cの組み合わせの個数も変わらない．
なので，B，Cの組み合わせの個数をメモしておく．&lt;/p&gt;
&lt;p&gt;個人的には計算量の見積もりが厳しい．
入力を考えるのは簡単なので，とりあえず実装してみて一番時間がかかりそうな入力（2*10^5）を突っ込んで時間計ってみるのが良さそう．&lt;/p&gt;
&lt;h2 id=&#34;b---abc&#34;&gt;B - A^B^C&lt;/h2&gt;
&lt;p&gt;A^B^Cの1の位は10で割った余りなので，(A%10)^B^Cと答えは同じ．
次にA%10の累乗の1の位がループする回数を求める．
例えば，2の場合，2の累乗の1の位は&lt;code&gt;2 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt;  2&lt;/code&gt;と4回毎にループすることが分かる．
これから，ループする回数をNとすると，B^CをNで割った余りを求めれば良い．
繰り返し二乗法を使えば&lt;code&gt;O(log(C))&lt;/code&gt;で&lt;code&gt;B^C % N&lt;/code&gt;を求められるので十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;c---string-invasion&#34;&gt;C - String Invasion&lt;/h2&gt;
&lt;p&gt;あるアルファベット&lt;code&gt;α&lt;/code&gt;が二回連続で並んでいるときに，その後ろにあるアルファベットを全て&lt;code&gt;α&lt;/code&gt;に置換できると考えると楽．
このとき，αの後ろにある全てのアルファベットの内，αではないアルファベットの個数回操作を行える．
この操作はなるべく後ろからしていくのが最適なので，以下の手順で解けばよい．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;後ろからアルファベットを見ていく．この時，アルファベットの種類毎の個数を記録する．&lt;/li&gt;
&lt;li&gt;二回連続しているアルファベット&lt;code&gt;α&lt;/code&gt;があれば，これまで記録してきた&lt;code&gt;α&lt;/code&gt;ではないアルファベットの個数回操作を行える．&lt;/li&gt;
&lt;li&gt;操作を行うと，今見ている以降の全てのアルファベットが&lt;code&gt;α&lt;/code&gt;になるので，そのように個数を記録し直す．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>鶏白湯ラーメンの作り方</title>
      <link>https://t45k.github.io/blog/toripaitan/</link>
      <pubDate>Mon, 22 Feb 2021 14:28:05 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/toripaitan/</guid>
      <description>&lt;p&gt;ラーメンが好きなので，鶏ガラを使って鶏白湯ラーメンを作りました．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/ramen.JPG&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;材料1人前&#34;&gt;材料（1人前）&lt;/h2&gt;
&lt;h3 id=&#34;スープ&#34;&gt;スープ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;鶏ガラ2羽分&lt;/li&gt;
&lt;li&gt;玉ねぎ半個&lt;/li&gt;
&lt;li&gt;ニンニクひとかけ&lt;/li&gt;
&lt;li&gt;ショウガ適量&lt;/li&gt;
&lt;li&gt;（お好みで手羽元とかネギの青い部分とか）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;タレ&#34;&gt;タレ&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;醤油100cc&lt;/li&gt;
&lt;li&gt;みりん100cc&lt;/li&gt;
&lt;li&gt;（半分ずつでも良さそう）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;具材&#34;&gt;具材&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;鶏モモ1枚（鶏チャーシュー用）&lt;/li&gt;
&lt;li&gt;玉ねぎ半個（薬味用）&lt;/li&gt;
&lt;li&gt;卵一個（味玉）&lt;/li&gt;
&lt;li&gt;（お好みでメンマ等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;麺は既製品を使いました&lt;/p&gt;
&lt;h2 id=&#34;作り方&#34;&gt;作り方&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;タレの材料を混ぜ合わせて煮切る．
できたものを室温程度に冷ます．&lt;/li&gt;
&lt;li&gt;鶏ガラは解凍しておく．
鍋に水を張り鶏ガラを茹でる．
アクが出てきたら水を替える．
鍋にスープの材料と新しい水を入れ，8時間くらい炊く
（水が減ってきたら適宜足していく）．&lt;/li&gt;
&lt;li&gt;具材の鶏モモはスープと一緒に30分程度茹でる．
茹であがったものを冷ましておいたタレに漬けておく．
卵は半熟に茹で，これもタレに漬けておく．
玉ねぎはみじん切りにし，分量外の酢に漬けておく．&lt;/li&gt;
&lt;li&gt;スープを8時間程度炊いたら，中の具材を取り除いたうえで，
一人分のスープの量になるくらいまで煮詰める．&lt;/li&gt;
&lt;li&gt;器にスープ，タレ（全部使うと濃いので適量で），麺，具を入れて完成．&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;スープ: 100点．メチャウマ．その辺のラーメン屋より旨い気がする&lt;br&gt;麺: 縮れてないほうが好き．まぁ既製品なので&lt;br&gt;チャーシュー: パサい．鶏肉をしっとり仕上げるのはむずそう&lt;br&gt;煮卵: 硬い．茹ですぎた&lt;br&gt;玉ねぎ酢漬け: 適量やと口がさっぱりしてええ感じ．若干主張が強い&lt;/p&gt;&amp;mdash; 教授のおごりで寿司@SIGSE (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1363069728407777282?ref_src=twsrc%5Etfw&#34;&gt;February 20, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>ABC192の解説</title>
      <link>https://t45k.github.io/kyopuro/abc192/</link>
      <pubDate>Sun, 21 Feb 2021 17:56:33 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc192/</guid>
      <description>&lt;p&gt;研究も一段落付いたので競プロに復帰します．&lt;/p&gt;
&lt;p&gt;今回はABCDの4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC192&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---star&#34;&gt;A - Star&lt;/h2&gt;
&lt;p&gt;Xは高々10^5なのでごり押しでもできますが，
100からXを100で割った余りを引くと&lt;code&gt;O(1)&lt;/code&gt;で求まります．&lt;/p&gt;
&lt;h2 id=&#34;b---unreadable-string&#34;&gt;B - uNrEaDaBlE sTrInG&lt;/h2&gt;
&lt;p&gt;for文で回すだけ．
大文字，小文字判定はJavaだと&lt;code&gt;Character#isUpper(Lower)Case&lt;/code&gt;を使うと一発．&lt;/p&gt;
&lt;h2 id=&#34;c---kaprekar-number&#34;&gt;C - Kaprekar Number&lt;/h2&gt;
&lt;p&gt;一見難しそうに見えますが，&lt;code&gt;N&amp;lt;=10^9&lt;/code&gt;からNをソート対象の要素は高々9個なので，
K=10^5から毎回&lt;code&gt;f(x)&lt;/code&gt;を計算しても十分間に合います．
ということで&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;xをchar型配列に変換する&lt;/li&gt;
&lt;li&gt;g1がxを降順にソートして得られる値，g2が昇順ソートで得られる値になる&lt;/li&gt;
&lt;li&gt;x = f(x)
をK回繰り返せばOK&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;d---base-n&#34;&gt;D - Base n&lt;/h2&gt;
&lt;p&gt;E問題より解いた人が少なかったD問題．&lt;/p&gt;
&lt;p&gt;まずXが一文字の時，何進数であってもXのn進数表記の値は変わらないため，
&lt;code&gt;X &amp;lt;= M&lt;/code&gt;なら1，そうでなければ0を出力する．&lt;/p&gt;
&lt;p&gt;次にXが二文字以上の時は，伝家の宝刀二分探索をする．
dから10^18+1の範囲から初め，
XをN進数表記にしたときにMを超過しない最大のNを求める．
ちなみにXのN進数表記を計算するときは&lt;code&gt;BigInteger&lt;/code&gt;を使うことをオススメします
（オーバーフローを考慮したうえでlongを使うと1WAになった）．&lt;/p&gt;
&lt;h2 id=&#34;e---train&#34;&gt;E - Train&lt;/h2&gt;
&lt;p&gt;出発できる時刻を考慮したうえでDijkstraをするだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>情報処理学会論文誌に論文が採録された話</title>
      <link>https://t45k.github.io/blog/ipsj_journal/</link>
      <pubDate>Sun, 17 Jan 2021 17:38:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ipsj_journal/</guid>
      <description>&lt;p&gt;情報処理学会論文誌に卒論でやっていた研究が採録されました．情報は&lt;a href=&#34;https://sdl.ist.osaka-u.ac.jp/pman/pman3.cgi?D=677&#34;&gt;こちら&lt;/a&gt;．&lt;/p&gt;
&lt;h2 id=&#34;論文誌とは&#34;&gt;論文誌とは&lt;/h2&gt;
&lt;p&gt;研究をしている以上，その成果を論文としてまとめる必要があります．
論文は大きく分けて以下の4種類に大別されます（僕が知る限り）．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;論文誌論文
&lt;ul&gt;
&lt;li&gt;別名: ジャーナル（journal）&lt;/li&gt;
&lt;li&gt;研究の最終成果を投稿する場&lt;/li&gt;
&lt;li&gt;採録されると雑誌として掲載される&lt;/li&gt;
&lt;li&gt;学術的貢献が求められる&lt;/li&gt;
&lt;li&gt;査読が行われる（査読とは，投稿された論文が学術的な有用性，信頼性に足るものかを他の研究者が判断するプロセスを指す）&lt;/li&gt;
&lt;li&gt;一般的に採録率は低いらしい．&lt;a href=&#34;https://search.ieice.org/statistics.html&#34;&gt;電子情報通信学会&lt;/a&gt;だと5割弱．&lt;/li&gt;
&lt;li&gt;投稿時に惜しくも採録に至らないと判定されても，条件付き採録として論文の修正を求められることが多い．&lt;/li&gt;
&lt;li&gt;国内だと情報処理学会や電子情報通信学会の論文誌に投稿することが多い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;会議論文
&lt;ul&gt;
&lt;li&gt;別名: 予稿集（inproceedings）&lt;/li&gt;
&lt;li&gt;レベルがピンキリ．採録率もピンキリ&lt;/li&gt;
&lt;li&gt;投稿目的もピンキリ．研究の最終成果発表から，アイデアの議論まで&lt;/li&gt;
&lt;li&gt;基本的に査読がある&lt;/li&gt;
&lt;li&gt;トップの会議だと条件付き採録もあったりするらしい．普通は一発採録&lt;/li&gt;
&lt;li&gt;採録されると開催場所での発表が求められる．海外旅行に行ける&lt;/li&gt;
&lt;li&gt;学術的貢献だけじゃなくてアイデアの面白さ，発表映えするかとかも重要&lt;/li&gt;
&lt;li&gt;発表がある都合上，投稿締め切りが設けられる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;研究会論文
&lt;ul&gt;
&lt;li&gt;別名: 技術報告（report）&lt;/li&gt;
&lt;li&gt;基本的に研究途中での成果の報告，アイデアの議論が目的&lt;/li&gt;
&lt;li&gt;査読がない&lt;/li&gt;
&lt;li&gt;発表がメイン．国内旅行に行ける&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学位論文
&lt;ul&gt;
&lt;li&gt;別名: thesis&lt;/li&gt;
&lt;li&gt;学位を取得するための論文&lt;/li&gt;
&lt;li&gt;卒論，修論は査読がない&lt;/li&gt;
&lt;li&gt;ので，書けば大丈夫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今回は論文誌論文として採録されました．&lt;/p&gt;
&lt;h2 id=&#34;道のり&#34;&gt;道のり&lt;/h2&gt;
&lt;p&gt;2019年に書いた卒論の内容が2021年に採録されたことから察せられるように，
採録までの道のりが非常に長かったです．
そもそも卒論を書いてから国際学会投稿，論文誌投稿とステップを踏むことが多いのですが，
僕の場合は作ったツールのクオリティが低すぎたため，ツールを作り直して実験をし直すとこから始まりました．
この時プログラミングを指導してくれた一つ上の先輩には本当にお世話になりました．
このプログラミング指導のおかげで修士では特にツール作りに苦労することがなく研究を進められました．&lt;/p&gt;
&lt;p&gt;一方，既存のツールが動かないという問題のせいで実験は全然進みませんでした．
本当にM1のほとんどはツールを動かすのに苦心していたと思います．
結局技術的に強い友人に相談したところ，3日で動いたのでもったいない時間の使い方をしたなぁって気分になりました．&lt;/p&gt;
&lt;p&gt;結局論文を投稿できたのが2020年の2月初めで，条件付き採録通知が来たのが11月，
修正と再投稿を行い，採録されたのが2021年の1月となりました．&lt;/p&gt;
&lt;p&gt;感想としては，嬉しいのが半分，ようやく終わったと安心したのが半分です．
自分としてはこの研究テーマに自身がなかったので，早く終わらしたかったという気持ちもありました．
本当に時間がかかったので，採録されたのは達成感があります．&lt;/p&gt;
&lt;p&gt;最後に，論文投稿のきっかけをくれた教授，
何度も論文を添削してくれた指導教員，
そしてプログラミングを教えてくれた先輩に心から感謝します．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>APSEC2020に参加した話</title>
      <link>https://t45k.github.io/blog/apsec_2020/</link>
      <pubDate>Sat, 05 Dec 2020 00:12:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/apsec_2020/</guid>
      <description>&lt;p&gt;12/2~4にオンラインで開催されたAPSECに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;apsecとは&#34;&gt;APSECとは&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../apsec_2019&#34;&gt;APSEC2019に参加した話&lt;/a&gt;参照．&lt;/p&gt;
&lt;p&gt;M2の4月終わりから研究し始めた，重複コードの修正支援ボットの論文をERA（Early Research Achievement）に投げました（&lt;a href=&#34;https://sdl.ist.osaka-u.ac.jp/pman/pman3.cgi?DOWNLOAD=536&#34;&gt;論文&lt;/a&gt;）．&lt;br&gt;
Acceptance rateはTechnical Researchが36.9%（45/122），ERAが46.2%（12/26）らしかったです．&lt;br&gt;
ERAのacc. rateが高いのでレベルは推して知るべしという感じです．&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;コロナの影響で，APSECに限らず国際会議は軒並みオンラインになってしまいました．&lt;br&gt;
国際会議は，成果発表の他に観光という側面もあるので，そういった意味ではモチベーションはあまり高くなかったです．&lt;br&gt;
一方，オンラインのおかげ喋る内容を覚えずに済むという利点もありました．&lt;br&gt;
発表ですが，チェアの方すら質問しないという謎の現象が発生したおかげで，良くも悪くも英語での質疑応答がなかったです．&lt;/p&gt;
&lt;p&gt;オンライン会議の悪い側面として，聴衆が参加しにくいというのが挙げられるかなと感じました．&lt;br&gt;
現地開催の場合，現地にいるのであまり興味がないトラックに参加したり，その結果質疑が盛り上がったりすることがあると思います．&lt;br&gt;
一方，オンラインの場合は自分と関係ない発表を聞く必要がないので，あまり盛り上がらないと感じました（僕も自分のトラック以外一切参加しませんでした）．&lt;/p&gt;
&lt;p&gt;コロナが一刻も早く収束して，元のように会議ができればと思います．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「九十九十九」読了</title>
      <link>https://t45k.github.io/blog/999/</link>
      <pubDate>Thu, 26 Nov 2020 16:19:02 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/999/</guid>
      <description>&lt;p&gt;&lt;strong&gt;苦しさを感じるなら、僕なんて愛さなくていいんだ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「九十九十九」を読みました．
この本はJDCトリビュートの一冊となっており，
清涼院流水のJDCシリーズに登場する登場人物九十九十九と同じ名前を持つ人物が主役となっています．&lt;/p&gt;
&lt;p&gt;内容としては，
やっぱり舞城王太郎特有のスピード感と超メタ表現のせいで難解になっていました．
とりあえず二周しましたが，全然分からなかったです．
作中作と再帰的な構成が本当によく分からなくなります．&lt;/p&gt;
&lt;p&gt;ただ，これがディスコ探偵水曜日の前に書かれた本だと言われると納得します（書き方や登場人物を含めていろんな共通点がある）．
ディスコ探偵水曜日が楽しめる人なら楽しく読めるのではないでしょうか．
繰り返し読むと理解が深まりそうではあるので，
購入を検討してむ良いかなと思いました．&lt;/p&gt;
&lt;p&gt;次は清涼院流水の「カーニバル・イブ」を読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西日本近似的一周旅行五日目</title>
      <link>https://t45k.github.io/blog/tour_day5/</link>
      <pubDate>Sat, 05 Sep 2020 18:49:05 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/tour_day5/</guid>
      <description>&lt;p&gt;五日目は帰宅の日でした．
走行距離は500kmほどです．&lt;/p&gt;
&lt;p&gt;まずはUFOラインを通って高知まで行きました．
UFOラインは愛媛と高知を結ぶ山道です．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/ufo_line.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

UFOラインは天空の道とも呼ばれるほど，道の標高が高いです（1,700mくらい）．
なので，周りの山々を一望でき，とても景色を楽しめました．
道自体は非常に狭いので，車で行く際には注意してください．&lt;/p&gt;
&lt;p&gt;高知では，ひろめ市場でカツオのたたきをいただきました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/katsuo.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

カツオのハランボ（お腹の部分．マグロで言うトロ）が脂が乗っておりとても美味しかったです．&lt;/p&gt;
&lt;p&gt;お昼ご飯を食べ終わってから，大阪に帰りました．
途中大雨に振られたので，PAで休み休みしながら帰りました．&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../tour_day1/&#34;&gt;一日目&lt;/a&gt;
&lt;a href=&#34;../tour_day2/&#34;&gt;二日目&lt;/a&gt;
&lt;a href=&#34;../tour_day3/&#34;&gt;三日目&lt;/a&gt;
&lt;a href=&#34;../tour_day4/&#34;&gt;四日目&lt;/a&gt;
五日目&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西日本近似的一周旅行四日目</title>
      <link>https://t45k.github.io/blog/tour_day4/</link>
      <pubDate>Fri, 04 Sep 2020 18:48:58 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/tour_day4/</guid>
      <description>&lt;p&gt;四日目は指宿からフェリーを使って道後まで行きました．
走行距離は500kmくらいでした．&lt;/p&gt;
&lt;p&gt;まずはじめに宮崎県にある青島神社に行きました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/aoshima_shrine1.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/aoshima_shrine2.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

青島神社は島全体が神社になっています．
また，島の周りの独特な形状をした岩は，自然にできたものだそうです．
フェリーの時間を考えてお昼ご飯は食べませんでした（が，実はこの後高速で道を間違えたので，結局ギリギリになりました）．&lt;/p&gt;
&lt;p&gt;大分の佐賀関からフェリーに乗り，愛媛へ向かいました．
バイクでフェリーに乗るのは初めてだったので，ワクワクしました．&lt;/p&gt;
&lt;p&gt;愛媛に着いてからは道後温泉を目指しました．
途中で海に近い駅として有名な下灘駅があったので立ち寄ってきました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/shimonada_station.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

綺麗な夕焼けをバックにエモい写真を取りたかったのですが，曇っていたためうまく映えませんでした．
また，この駅は海のすぐ隣にあると思っていたのですが，実は道路を一本挟んでいます．&lt;/p&gt;
&lt;p&gt;夜は道後温泉の近くに止まりました．
お風呂は道後温泉本館に行きました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/dougo.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

道後温泉本館はおそらく現存する最古の大衆浴場で，お風呂や扉の作りから古くからあるのが見て取れました．
全国的に有名ですが，現在も伝統を守っており，不必要な拡張などは行われていませんでした
（逆に言うと，思ったよりしょぼかったです．
中はシャワーと大きな湯船が一つだけでした）．&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../tour_day1/&#34;&gt;一日目&lt;/a&gt;
&lt;a href=&#34;../tour_day2/&#34;&gt;二日目&lt;/a&gt;
&lt;a href=&#34;../tour_day3/&#34;&gt;三日目&lt;/a&gt;
四日目
&lt;a href=&#34;../tour_day5/&#34;&gt;五日目&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西日本近似的一周旅行三日目</title>
      <link>https://t45k.github.io/blog/tour_day3/</link>
      <pubDate>Thu, 03 Sep 2020 16:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/tour_day3/</guid>
      <description>&lt;p&gt;三日目は熊本を経由して鹿児島の指宿に行きました．
走行距離は400kmくらいです．&lt;/p&gt;
&lt;p&gt;大分から熊本へは，やまなみハイウェイを使いました．
やまなみハイウェイは景観が良いことで有名なのですが，
あいにく天気が崩れてしまい，霧がかって何も見えませんでした．
バイクで雨の中を移動したため，体がとても冷えた上に
バイクを傾けたら滑りそうになったこともあって死ぬかと思いました．&lt;/p&gt;
&lt;p&gt;熊本県では研究室の先生おすすめの天外天さんのラーメンを食べました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/tengaiten.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

かかっているニンニクパウダーの香りが良く，美味しかったです．&lt;/p&gt;
&lt;p&gt;その後ひたすら南下し指宿温泉まで行きました．
また，指宿温泉の近所の龍宮神社に行きました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/ryugu_shrine.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

龍宮神社はその名の通り，浦島太郎の物語の発祥となった神社です．&lt;/p&gt;
&lt;p&gt;晩御飯は近所のイオンで買った鶏のたたきと芋焼酎にしました．
イオンで普通に生食用の鶏肉が売ってたり，焼酎の品揃えが異様に良かったりしたところに鹿児島を感じました．
イオンから桜島が見えました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/sakurajima.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../tour_day1/&#34;&gt;一日目&lt;/a&gt;
&lt;a href=&#34;../tour_day2/&#34;&gt;二日目&lt;/a&gt;
三日目
&lt;a href=&#34;../tour_day4/&#34;&gt;四日目&lt;/a&gt;
&lt;a href=&#34;../tour_day5/&#34;&gt;五日目&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西日本近似的一周旅行二日目</title>
      <link>https://t45k.github.io/blog/tour_day2/</link>
      <pubDate>Wed, 02 Sep 2020 19:28:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/tour_day2/</guid>
      <description>&lt;p&gt;2日目は広島県を経由して大分まで行きました．
1日で500km以上移動したので結構疲れました．&lt;/p&gt;
&lt;p&gt;厳島神社（修理中の姿）
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/itsukushima_shrine.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

大鳥居が見れなくて残念でした．&lt;/p&gt;
&lt;p&gt;お昼ご飯の「あなごめし うえの」さんの穴子めし
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/anagomeshi.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

今まで，穴子は鰻の下位互換と考えていましたが，ここの穴子めしは本当に美味しくて，
その考えが覆されました．
穴子が肉厚で弾力があり，それが炭火で焼かれていて香ばしかったです．&lt;/p&gt;
&lt;p&gt;次に，山口にある錦帯橋に行きました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/kintai_bridge.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

本来予定にはなかったのですが，どうやら広島，山口ツーリングではそこに行くのが鉄板らしかったので．&lt;/p&gt;
&lt;p&gt;その後，福岡を素通りして大分にある別府温泉に行きました．
本州と九州を繋ぐ橋で風が強すぎて半車線くらい流された時は死ぬかと思いました．
高速道路で道を間違えて次のICでUターンする経験もしました．
晩御飯は近くの居酒屋で取りました．
大分名物のとり天や豊後アジ，豊後サバを楽しみました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/toriten.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/saba.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;../tour_day1/&#34;&gt;一日目&lt;/a&gt;
二日目
&lt;a href=&#34;../tour_day3/&#34;&gt;三日目&lt;/a&gt;
&lt;a href=&#34;../tour_day4/&#34;&gt;四日目&lt;/a&gt;
&lt;a href=&#34;../tour_day5/&#34;&gt;五日目&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西日本近似的一周旅行一日目</title>
      <link>https://t45k.github.io/blog/tour_day1/</link>
      <pubDate>Tue, 01 Sep 2020 19:28:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/tour_day1/</guid>
      <description>&lt;p&gt;1日目は島根県に行きました．
1日で400km近くバイクで移動しましたが，高速がメインだったのでそこまで疲れませんでした．
高速を降りてからヘルメットを確認してみると，移動中にぶつかったであろう小さい虫の死骸がたくさんへばりついていました&amp;hellip;&lt;/p&gt;
&lt;p&gt;出雲大社
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/izumo_taisha.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;お昼ご飯の出雲そば．
出雲そばはそばを3つの器に分けて提供するのが特徴的です．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/izumo_soba.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;チェックインまで時間があったので松江城にも行きました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/matsue_castle.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;宿に着いた途端に立ちゴケしてブレーキレバーを壊しました．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/brake_broken.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;夕飯は，松江のイオンで買った地酒とお寿司でした．
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/shimane_zizake.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;一日目
&lt;a href=&#34;../tour_day2/&#34;&gt;二日目&lt;/a&gt;
&lt;a href=&#34;../tour_day3/&#34;&gt;三日目&lt;/a&gt;
&lt;a href=&#34;../tour_day4/&#34;&gt;四日目&lt;/a&gt;
&lt;a href=&#34;../tour_day5/&#34;&gt;五日目&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC177の解説</title>
      <link>https://t45k.github.io/kyopuro/abc177/</link>
      <pubDate>Sun, 30 Aug 2020 16:35:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc177/</guid>
      <description>&lt;p&gt;5完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC177&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---dont-be-late&#34;&gt;A - Don&amp;rsquo;t be late&lt;/h2&gt;
&lt;p&gt;規定の時間歩き切った際の距離が待ち合わせ場所までの距離以上であれば良い．&lt;/p&gt;
&lt;h2 id=&#34;b---substring&#34;&gt;B - Substring&lt;/h2&gt;
&lt;p&gt;制約が緩いのでSの0以上&lt;code&gt;|S|-|T|&lt;/code&gt;以下文字を先頭とした部分文字列とTを比較すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;c---sum-of-product-of-pairs&#34;&gt;C - Sum of product of pairs&lt;/h2&gt;
&lt;p&gt;愚直にやると時間に間に合わない．&lt;br&gt;
答えは&lt;code&gt;A1 * (A2 + A3 + ... An) + A2 * (A3 + ... + An) + ... + Ai * (Ai+1 + ... + An) + ...&lt;/code&gt;なので，
A2からAnまでの累積和を取ってから掛け算を行えば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---friends&#34;&gt;D - Friends&lt;/h2&gt;
&lt;p&gt;Union-Findで殴る．&lt;br&gt;
問題文から，Union-Findを使うと友達グループは簡単に求まる．
&lt;strong&gt;全ての人について「同じグループの中に友達がいない」という状況&lt;/strong&gt;を達成するためには，
一番大きい友達グループと同じサイズのグループに分割すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---coprime&#34;&gt;E - Coprime&lt;/h2&gt;
&lt;p&gt;まず全てのAiに対してGCDをとって，与えられた数字列が&lt;strong&gt;not coprime&lt;/strong&gt;か否かを判定する．
not coprime出ない場合，次に&lt;strong&gt;pairwise coprime&lt;/strong&gt;かどうかを判定する．
ここで，&lt;strong&gt;「全ての組が互いに素である」とは，与えられた数字列の数字を素因数分解した際に，素数が約数となるのは高々1回まで&lt;/strong&gt;と同意である．
Ai&amp;lt;=10^6から，素数の最大値は1000以下，あるいは1000以下の素数で割り切った後に残る数字（1以外）となる．
なので，先に1000以下の素数をエラトステネスの篩などで用意しておき，
各Aiに対して各素数で割れるかどうかを判定する．
割れる場合，その素数を記録する．
すでに記録した素数で割り切れた場合，互いに素でない数字の組が存在することになる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC176の解説</title>
      <link>https://t45k.github.io/kyopuro/abc176/</link>
      <pubDate>Mon, 24 Aug 2020 17:05:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc176/</guid>
      <description>&lt;p&gt;気持ち良く5完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC176&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---takoyaki&#34;&gt;A - Takoyaki&lt;/h2&gt;
&lt;p&gt;日本語をきちんと噛み砕かないと解けない問題．
答え自体は&lt;code&gt;(X + N - 1) / N * T&lt;/code&gt;するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---multiple-of-9&#34;&gt;B - Multiple of 9&lt;/h2&gt;
&lt;p&gt;各桁の合計を9で割るだけ&lt;/p&gt;
&lt;h2 id=&#34;c---step&#34;&gt;C - Step&lt;/h2&gt;
&lt;p&gt;前から順番に見ていき，今見ている人の身長が前の人以上になるように踏み台を使うのが最適．&lt;br&gt;
なので，人iが見てきた中で最大の身長より小さければ，その差を足し合わせ，
それより大きければ身長の最大値を更新すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---wizard-in-maze&#34;&gt;D - Wizard in Maze&lt;/h2&gt;
&lt;p&gt;意外と解ける人が少なかった問題&lt;br&gt;．
移動をコスト0，ワープをコスト1としてダイクストラすれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---bomber&#34;&gt;E - Bomber&lt;/h2&gt;
&lt;p&gt;これが緑diffなの意外．&lt;br&gt;
最初に各列，行ごとの爆破対象の個数を数えていく．
次に，列，行ごとで爆破対象が最大のもののみをフィルターする．
最後に残った列，行を組み合わせた際に爆破対象が最大となるものを選ぶ．
この時，選んだ列，行の交差点に爆破対象がない場合合計個数は&lt;code&gt;列の値 + 行の値&lt;/code&gt;，
そうでない場合は&lt;code&gt;列の値 + 行の値 - 1&lt;/code&gt;になる．
なので，交差点に爆破対象がないように選びたい．
爆破対象の数は高々M個なので，交差点がMを超過するとき，必ず爆破対象が存在しない交差点がする．
逆にM以下の場合は，全ての交差点を確認しても制限時間に間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC175の解説</title>
      <link>https://t45k.github.io/kyopuro/abc175/</link>
      <pubDate>Sun, 16 Aug 2020 19:58:10 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc175/</guid>
      <description>&lt;p&gt;オンタイム参加せず．
バチャやると3完だったので参加しなくてよかった&amp;hellip;&lt;br&gt;
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC175&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---rainy-season&#34;&gt;A - Rainy Season&lt;/h2&gt;
&lt;p&gt;高々3文字なので全ての場合を列挙した方が良さそう．&lt;/p&gt;
&lt;h2 id=&#34;b---making-triangle&#34;&gt;B - Making Triangle&lt;/h2&gt;
&lt;p&gt;高々&lt;code&gt;N &amp;lt;= 100&lt;/code&gt;なので3重ループでOK．&lt;/p&gt;
&lt;h2 id=&#34;c---walking-takahashi&#34;&gt;C - Walking Takahashi&lt;/h2&gt;
&lt;p&gt;個人的に結構難しかった問題．&lt;br&gt;
Xは最初から絶対値として扱って良い．
&lt;code&gt;X &amp;gt;= K * D&lt;/code&gt;の場合は&lt;code&gt;X - K * D&lt;/code&gt;が最適となる．&lt;br&gt;
そうでない場合．まず　&lt;code&gt;K2 = X / D&lt;/code&gt;とすると&lt;code&gt;0 &amp;lt; X - K2 * D &amp;lt; D&lt;/code&gt;を満たすK2が得られる．
ここからK2の偶奇がKと一致する場合そのKを，一致しない場合はK2+1が答えとなる．&lt;br&gt;
&lt;code&gt;K * D&lt;/code&gt;が64bitに収まらないに注意．&lt;/p&gt;
&lt;h2 id=&#34;d---moving-piece&#34;&gt;D - Moving Piece&lt;/h2&gt;
&lt;p&gt;場合分けが面倒くさくて実装量が多くなる問題&lt;br&gt;．
まず初めにマスのグループ分けを行う．
というのも始める場所によっては行けないマスが存在することもあるからである（例えば&lt;code&gt;2 1 4 3&lt;/code&gt;だと1からスタートすると1 -&amp;gt; 2 -&amp;gt; 1を繰り返す）．
グループ分けは愚直にシミュレーションしても良いし，UnionFindTreeを用いてもできる．&lt;br&gt;
分けたグループそれぞれに対して，スコアを計算する．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kがグループのサイズ以下の場合&lt;br&gt;
グループに含まれる各値をスタート地点にして，シミュレーションする．
シミュレーションの途中のスコアも全て記録しておき，最大値を取得する&lt;/li&gt;
&lt;li&gt;Kがグループのサイズを超過する場合
&lt;ul&gt;
&lt;li&gt;グループの各数値iに対するCiの総和が
0より大きい場合&lt;br&gt;
なるべく多くループした方が良い．
&lt;code&gt;div = K / グループサイズ&lt;/code&gt;，&lt;code&gt;mod = K % グループサイズ&lt;/code&gt;とする．
&lt;ul&gt;
&lt;li&gt;modが0でない時&lt;br&gt;
余り回移動するシミュレーションを行い，その最大値を&lt;code&gt;総和 * div&lt;/code&gt;に足す．&lt;/li&gt;
&lt;li&gt;modが0の時&lt;br&gt;
ループを1回少なく行い，そこから最適な移動を行う場合を考える（Cに負の数が含まれる場合，総和 &amp;lt; 最適なシミュレーションになる）ので，グループサイズ回移動するシミュレーションを行い，その最大値を&lt;code&gt;総和 * (div - 1)&lt;/code&gt;に足す．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;0より小さい場合
ループしない方が良いので，グループサイズ回移動するシミュレーションを行う．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最終的に各グループに対して上の計算で出た値の最大値が答え．&lt;/p&gt;
&lt;h2 id=&#34;e---picking-goods&#34;&gt;E - Picking Goods&lt;/h2&gt;
&lt;p&gt;Dより簡単．DP．&lt;br&gt;
同じ行でいくつ宝箱を取得してかを表す要素を追加する．
&lt;code&gt;dp[R][C][3]&lt;/code&gt;．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC174の解説</title>
      <link>https://t45k.github.io/kyopuro/abc174/</link>
      <pubDate>Tue, 04 Aug 2020 13:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc174/</guid>
      <description>&lt;p&gt;5完．
Fが水diffだったのに解けなくて厳しい．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC174&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---air-conditioner&#34;&gt;A - Air Conditioner&lt;/h2&gt;
&lt;p&gt;条件分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---distance&#34;&gt;B - Distance&lt;/h2&gt;
&lt;p&gt;与えられたN個の座標の原点からの距離を計算していくだけ．&lt;br&gt;
また，こういう時，小数点の計算などは誤差が発生しやすいので，平方根をとる計算はせず，
全て二乗で計算した方が良い．
int型だとオーバーフローするので注意．&lt;/p&gt;
&lt;h2 id=&#34;c---repsept&#34;&gt;C - Repsept&lt;/h2&gt;
&lt;p&gt;証明が難しい問題．&lt;br&gt;
C問題なので，時間いっぱい（10^7くらい）計算して答えが見つかれば答えを，見つかれなければ-1を出力する方針で解いた．
計算じたいは，最初に&lt;code&gt;X = 7, i = 1&lt;/code&gt;として，XがKで割れればiを出力し，
割れなければ&lt;code&gt;X &amp;lt;- (X * 10 + 7) % K, i &amp;lt;- i + 1&lt;/code&gt;と更新すれば良い．&lt;/p&gt;
&lt;h2 id=&#34;d---alter-altar&#34;&gt;D - Alter Altar&lt;/h2&gt;
&lt;p&gt;なんとなく解けた問題．&lt;br&gt;
答えは次のいずれかの小さい方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玉を赤か白に統一する&lt;/li&gt;
&lt;li&gt;swapして左側に赤，右側に白を揃える&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下の方法だと，最左の白玉と最右の赤玉の間にある玉の赤と白の少ない方の個数が答えになる．&lt;/p&gt;
&lt;h2 id=&#34;e---logs&#34;&gt;E - Logs&lt;/h2&gt;
&lt;p&gt;なんとなく解けた問題．想定解はにぶたん．&lt;br&gt;
まず&lt;code&gt;K &amp;lt;= 10^9&lt;/code&gt;という条件を無視すると，丸太iとその切断回数jに対して，
i/jの天井関数の降順に並べるようにした
優先度付きキューに丸太を入れて，K回先頭の割る回数を増やすという操作で解ける(以降，操作O)．
なので，&lt;code&gt;K&lt;/code&gt;を10^5くらいにできれば，この操作で大丈夫である．
&lt;code&gt;K&lt;/code&gt;を減らす方法として，はじめに丸太iの長さに応じて適切な切断回数を決めておき，
その切断回数の総和を&lt;code&gt;K&lt;/code&gt;から引いた上で，操作Oに入ればよい．
初期切断回数として，丸太の長さの総和に対する割合を利用できる．
つまり，丸太の長さの総和Sに対して，丸太iの長さがLiの時，
&lt;code&gt;K * (Li / S)&lt;/code&gt;を初期切断回数とすれば良い．&lt;/p&gt;
&lt;h2 id=&#34;f---range-set-query&#34;&gt;F - Range Set Query&lt;/h2&gt;
&lt;p&gt;解説AC．クエリをソートするという発想．&lt;br&gt;
クエリの右端を昇順に並べる．
クエリの右端までの玉の各種類について，最右なものの位置を記録していく．
最後に，クエリの左端より右側に位置している玉の数を数える（区間和なのでセグ木とかBIT）．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「きまぐれロボット」読了</title>
      <link>https://t45k.github.io/blog/kimagure_robot/</link>
      <pubDate>Sat, 25 Jul 2020 20:46:40 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/kimagure_robot/</guid>
      <description>&lt;p&gt;星新一のきまぐれロボットを読みました．&lt;/p&gt;
&lt;p&gt;この本を読んだ経緯ですが，楽天で買い物をしたときにもらった
電子書籍の割引券の使い道に困っていたところ，
友人に星新一を進められたのがきっかけです．&lt;/p&gt;
&lt;p&gt;ついこの間までしばらく本をあまり読んでいなかったうえに，
ここ最近は長めのミステリばかり読んでいたので，
ショートショートは本当に久しぶり（もしかしたら初めて）でした．
伏線を積み重ねまくって最後にひっくり返すミステリに対して，
ショートショートは長くても3ページ程度でオチがつくので，
スッと読み進められました．
また，すぐ話が切り替わるので，飽きることなく最後まで読めました．&lt;/p&gt;
&lt;p&gt;思ったよりショートショートが面白かったので，
また電子書籍のクーポンをもらえたら星新一の本をもう一冊買っても良いかなと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「ジョーカー 旧約探偵神話」読了</title>
      <link>https://t45k.github.io/blog/joker/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:49 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/joker/</guid>
      <description>&lt;p&gt;清涼院流水の「ジョーカー 旧約探偵神話」を読みました．&lt;/p&gt;
&lt;p&gt;全編を通して「メタミステリ」「過去のミステリに対する挑発」がひしひしと伝わってくる内容でした．
特にミステリ四大奇書である「ドグラマグラ」「匣の中の失楽」「虚無への供物」「黒死館殺人事件」は文中で何度も言及されており，
リスペクトが感じられました．
本文中でミステリの30の原則を挙げ，それを達成しようとする姿勢から，ミステリの総決算だと評されるのもうなずけました．&lt;/p&gt;
&lt;p&gt;内容自体は前作コズミックと被っている部分もありましたが（作中作など），どんでん返しからのどんでん返しなど目を見張るような場面もいくつもありました．
ラスト（真犯人）自体は読了直後はあまり納得いきませんでしたが，この直後にコズミックの内容がくることを考えるとなんとなく理解できました．&lt;/p&gt;
&lt;p&gt;少し残念なところは，今作は時系列的に前作の前の話であり，前作中で今作の事件内容が言及されることもあったため，
誰が殺されないかなどが薄々わかってしまったことです．&lt;/p&gt;
&lt;p&gt;次回は，同じく清涼院流水のカーニバル・イブを読む予定です．
そろそろ目的だった舞城王太郎の九十九十九を読んでも良いかもです．
また，いつかミステリ四大奇書も読める日が来ればなぁとは感じています．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>エイシングプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/aising2020/</link>
      <pubDate>Mon, 13 Jul 2020 18:19:23 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/aising2020/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/other/aising2020&#34;&gt;コード&lt;/a&gt;
実装が重かった印象．&lt;/p&gt;
&lt;h2 id=&#34;a---number-of-multiples&#34;&gt;A - Number of Multiples&lt;/h2&gt;
&lt;p&gt;for文で回すだけ&lt;/p&gt;
&lt;h2 id=&#34;b---an-odd-problem&#34;&gt;B - An Odd Problem&lt;/h2&gt;
&lt;p&gt;for文で回すだけ&lt;/p&gt;
&lt;h2 id=&#34;c---xyz-triplets&#34;&gt;C - XYZ Triplets&lt;/h2&gt;
&lt;p&gt;ゴリ押し全探索&lt;br&gt;
N&amp;lt;=10^4から，x,y,zそれぞれの最大値は10^2になることが分かる．
なので，x，yを1から10^2まで全探索しても計算量は全体で10^8に抑えられる．&lt;br&gt;
計算方法だが，xとyが決まればあとはzの二次方程式となるため，解の公式を使えば条件を満たすzが存在するかがO(1)で分かる．&lt;/p&gt;
&lt;h2 id=&#34;d---anything-goes-to-zero&#34;&gt;D - Anything Goes to Zero&lt;/h2&gt;
&lt;p&gt;意外と難しかったらしい問題&lt;br&gt;
条件から，各Xiを最初に割るのは，popcount(X)±1となる．
また桁iが0の時，&lt;code&gt;Xi = X + 2^i&lt;/code&gt;，1の時，&lt;code&gt;Xi = X - 2^1&lt;/code&gt;となることから，
Xの値と各2^iの値を最初に求めておけば，最初の余を求めるところ以降は愚直にやっても間に合う．
Xの値と各2^iの値は非常に大きくなる可能性があるので，何らかの値で割った余りを利用したい．
ここで，&lt;code&gt;条件から，各Xiを最初に割るのは，popcount(X)±1となる&lt;/code&gt;ので，popcount(X)±1で割った余りを記録して，
桁iの値で使い分ければ良い.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC173の解説</title>
      <link>https://t45k.github.io/kyopuro/abc173/</link>
      <pubDate>Mon, 13 Jul 2020 17:52:00 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc173/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC173&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---payment&#34;&gt;A - Payment&lt;/h2&gt;
&lt;p&gt;愚直にforループを回しても良いが，Nが最大10,000なのを踏まえて，
&lt;code&gt;10,000 - N&lt;/code&gt;をしてお釣りを1000で割った余りを求めると早い．&lt;/p&gt;
&lt;h2 id=&#34;b---judge-status-summary&#34;&gt;B - Judge Status Summary&lt;/h2&gt;
&lt;p&gt;switch文で数え上げるだけ．&lt;/p&gt;
&lt;h2 id=&#34;c---h-and-v&#34;&gt;C - H and V&lt;/h2&gt;
&lt;p&gt;典型的なbit全探索の問題．
縦，横でbit全探索して，該当行を赤く塗った後に盤上の黒いマスの個数を数える．&lt;/p&gt;
&lt;h2 id=&#34;d---chat-in-a-circle&#34;&gt;D - Chat in a Circle&lt;/h2&gt;
&lt;p&gt;なぜ解けたかよくわからなかった．
直感的には，Aiをソートした後に&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A1 A2を列に加える&lt;/li&gt;
&lt;li&gt;A3，A4を交互に列に加える．A1 A3 A2 A4となる&lt;/li&gt;
&lt;li&gt;A5，A6，A7，A8を交互に列に加える．A1 A5 A3 A6 A2 A7 A4 A8となる&lt;/li&gt;
&lt;li&gt;これを繰り返す．&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;みたいな．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「コズミック 世紀末探偵神話」読了</title>
      <link>https://t45k.github.io/blog/cosmic/</link>
      <pubDate>Wed, 01 Jul 2020 11:05:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/cosmic/</guid>
      <description>&lt;p&gt;清涼院流水の「コズミック 世紀末探偵神話」を読みました．&lt;/p&gt;
&lt;p&gt;清涼院流水は，僕が敬愛する作家である西尾維新や舞城王太郎が影響を受けたと公言している作家なので，どんな本を書いているのか昔から非常に興味がありました．&lt;/p&gt;
&lt;p&gt;読んだ感想ですが，久しぶりにページを捲る手が止まらない本を読んだ気がします．
最初は分厚い上に延々と殺人事件が続くので若干退屈でしたが，探偵の推理パートに入ると一気に面白くなりました．
特に，最後の九十九十九が推理をする直前，読者への挑戦状あたりはずっと興奮していました．&lt;/p&gt;
&lt;p&gt;犯人は実は作者みたいなメタ的な展開を予想していたのですが，きれいに納得のいく形で完結していたのも良いと思いました．
前半の作中作が大きなヒントになっていたとは思わなかったです．&lt;/p&gt;
&lt;p&gt;この流れで，次も清涼院流水のジョーカーを読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC172の解説</title>
      <link>https://t45k.github.io/kyopuro/abc172/</link>
      <pubDate>Wed, 01 Jul 2020 10:38:47 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc172/</guid>
      <description>&lt;p&gt;C，D問題に緑diffが出て結構阿鼻叫喚な人が多かった回．
4完．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC172&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---calc&#34;&gt;A - Calc&lt;/h2&gt;
&lt;p&gt;計算するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---minor-change&#34;&gt;B - Minor Change&lt;/h2&gt;
&lt;p&gt;問題文から，SとTの同じ位置で文字が異なる回数を数え上げれば良いことが分かる．&lt;/p&gt;
&lt;h2 id=&#34;c---tsundoku&#34;&gt;C - Tsundoku&lt;/h2&gt;
&lt;p&gt;貪欲だと解けない問題．&lt;br&gt;
A，Bどちらの本も上限が10^5なので，全ての組み合わせを見ると時間が足りなくなる．
ここで，&lt;strong&gt;本は上から見ていく&lt;/strong&gt;というルールから，累積和をとっても問題ないことに気付ける．
累積和が取れるので，Aは前から見ていき，Bは二分探索できることに気付けるので，あとは実装するだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-divisors&#34;&gt;D - Sum of Divisors&lt;/h2&gt;
&lt;p&gt;最近流行のエラトステネス的問題．&lt;br&gt;
全ての数字の約数の個数をそれぞれ求めていたら遅いので，前から素数を見て，その素数を約数として持つ値に約数として加えていく方針でやる．&lt;br&gt;
実装としては，以下のようにする．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;長さNの配列を2つ用意する．
配列Aは1で，配列Bはその添字で初期化する．
配列Aは約数の個数を，配列Bは素数かどうかを判定するのに使う．&lt;/li&gt;
&lt;li&gt;2 &amp;lt;= i &amp;lt;= √Nとして，配列を順番に見ていく．
&lt;ul&gt;
&lt;li&gt;Biが2以上の時，iは素数となる．なので，iの倍数jに対して，jがiでk回割れる(= log(i,j))とすると&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;Ak *= k + 1
Bk /= i ^ k
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;と更新する&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Biが1の時，iは素数なので何もしない&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配列Aに約数の個数が記録できたので，√N以上の素数に注意しながら欲しい値を計算する．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ABC171の解説</title>
      <link>https://t45k.github.io/kyopuro/abc171/</link>
      <pubDate>Tue, 30 Jun 2020 22:33:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc171/</guid>
      <description>&lt;p&gt;難易度が暴落した回．&lt;br&gt;
5完．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC171&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---αlphabet&#34;&gt;A - αlphabet&lt;/h2&gt;
&lt;p&gt;やるだけ．
Javaなら&lt;code&gt;Character#isUpperCase&lt;/code&gt;とかが使える．&lt;/p&gt;
&lt;h2 id=&#34;b---mix-juice&#34;&gt;B - Mix Juice&lt;/h2&gt;
&lt;p&gt;ソートして前からK個選ぶ．&lt;/p&gt;
&lt;h2 id=&#34;c---one-quadrillion-and-one-dalmatians&#34;&gt;C - One Quadrillion and One Dalmatians&lt;/h2&gt;
&lt;p&gt;与えられた数字を26進数に変換する問題．&lt;br&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Nをデクリメントし&lt;/li&gt;
&lt;li&gt;Nを26で割ったあまりを求め(これを使う)&lt;/li&gt;
&lt;li&gt;N /= 26 をする&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を繰り返す．&lt;/p&gt;
&lt;h2 id=&#34;d---replacing&#34;&gt;D - Replacing&lt;/h2&gt;
&lt;p&gt;C問題よりわかりやすい．&lt;br&gt;
最初に全ての和Sと，それぞれの数字が何回出てくるかを記録しておく．
各クエリ毎に以下の操作をすれば良い．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与えられたCに対して，SからC*(Cの出現回数)を引く&lt;/li&gt;
&lt;li&gt;与えられたDに対して，SにD*(Cの出現回数)を加える&lt;/li&gt;
&lt;li&gt;Dの出現回数にCの出現回数を加える&lt;/li&gt;
&lt;li&gt;Cの出現回数を0にする&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;e---red-scarf&#34;&gt;E - Red Scarf&lt;/h2&gt;
&lt;p&gt;まさかの茶diff．Nが偶数という制約があるのを知らんかった&amp;hellip;&lt;br&gt;
すぬけ君iのスカーフに書かれた整数をbiとすると&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 =      b2 ^ b3 ^ ... ^ bn
a2 = b1 ^      b3 ^ ... ^ bn
a3 = b1 ^ b2 ^      ... ^ bn
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;であることが分かる．
また，排他的論理和の性質から&lt;code&gt;x ^ x = 0&lt;/code&gt;なので，以下が成り立つ．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 ^ a2 ^ a3 ^ ... ^ an
= (b1 ^ b1 ^ ... ^ b1(= n-1回の排他的論理和)) ^ (b2 ^ b2 ^ ...) ^ ...
= b1 ^ b2 ^ ... ^bn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;つまり&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;a1 ^ (a1 ^ a2 ^ ... ^ an)
= b1 ^ (b2 ^ b2) ^ (b3 ^ b3) ^ ...
= b1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;が成り立つ．&lt;br&gt;
つまり，biを求めるためには，全てのaの排他的論理和とaiの排他的論理和を求めれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC170の解説</title>
      <link>https://t45k.github.io/kyopuro/abc170/</link>
      <pubDate>Sat, 20 Jun 2020 11:52:18 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc170/</guid>
      <description>&lt;p&gt;無念の3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC170&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---five-variables&#34;&gt;A - 	Five Variables&lt;/h2&gt;
&lt;p&gt;やるだけ．
Listを作って&lt;code&gt;List#indexOf&lt;/code&gt;で探すと楽．&lt;/p&gt;
&lt;h2 id=&#34;b---crane-and-turtle&#34;&gt;B - Crane and Turtle&lt;/h2&gt;
&lt;p&gt;ツルカメ算．
ループを回す．&lt;/p&gt;
&lt;h2 id=&#34;c---forbidden-list&#34;&gt;C - Forbidden List&lt;/h2&gt;
&lt;p&gt;解答が燃えた問題．&lt;br&gt;
Xが100以下なので，答えは101以下になる．
したがって，0から101までの，数列に含まれていない数字に対してXとの差を計算するだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---not-divisible&#34;&gt;D - Not Divisible&lt;/h2&gt;
&lt;p&gt;解けなかった．&lt;br&gt;
エラトステネスの篩のイメージ．
数列A中の最大値をAmaxとすると，数列Aを昇順に見て&lt;code&gt;sqrt(Amax)&lt;/code&gt;までの数字の倍数を全て消す作業をする．
最後に残った数字の中でダブりがないものが答え．&lt;/p&gt;
&lt;h2 id=&#34;e---smart-infants&#34;&gt;E - Smart Infants&lt;/h2&gt;
&lt;p&gt;データ構造で殴る問題．
Javaの標準ライブラリにMultiSetはないので少し考える必要がある．
今回は各幼稚園の園児のレートをTreeSetで，全ての幼稚園の最小値をセグ木で持つと，転園は以下の操作で行われる．
また，各園児が現在所属している幼稚園の情報を持つとする．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cjの園児が所属している幼稚園(TreeSet)からCjを消す．&lt;/li&gt;
&lt;li&gt;その幼稚園に関してセグ木の値を更新する．もし幼稚園に園児がいないなら&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;とする．&lt;/li&gt;
&lt;li&gt;幼稚園DjにCjを加える．&lt;/li&gt;
&lt;li&gt;幼稚園Djに関してセグ木の値を更新する．&lt;/li&gt;
&lt;li&gt;セグ木の全ての範囲に対してクエリを投げる．これが平等さになる．&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>東京海上日動プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/tokiomarine2020/</link>
      <pubDate>Sun, 14 Jun 2020 18:55:26 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/tokiomarine2020/</guid>
      <description>&lt;p&gt;3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/other/tokiomarine2020&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---nickname&#34;&gt;A - Nickname&lt;/h2&gt;
&lt;p&gt;与えられた文字列の先頭3文字を抜き出すだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---tag&#34;&gt;B - Tag&lt;/h2&gt;
&lt;p&gt;非鬼が鬼より右側にいる場合，BはAに捕まらいためには右側に逃げるのが最適となる．
鬼と非鬼がT秒移動した時にいる箇所は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鬼: &lt;code&gt;A + V*T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非鬼: &lt;code&gt;B + W*T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;となる．
鬼の座標が非鬼の座標以上に右側にいる(=より座標が大きい)と捕まるので，それを判定するだけ&lt;/p&gt;
&lt;h2 id=&#34;c---lamps&#34;&gt;C - Lamps&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imoz.jp/algorithms/imos_method.html&#34;&gt;いもす法&lt;/a&gt;をすると1回の操作はO(N)で達成できるので，K回やるとO(NK)となる(いもす法のやり方: Aiの値がdの時，座標&lt;code&gt;i-d&lt;/code&gt;に+1，座標&lt;code&gt;i+d+1&lt;/code&gt;に-1を加え，最後に累積和する)．
O(NK)なので，最大で4*10^10程度の計算量となってしまいそうだが，ここで問題文から以下のことが言える．&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全ての電球の明るさが&lt;code&gt;N&lt;/code&gt;となった場合，それ以降の操作で明るさは増えないため，そこで操作を打ち切って良い&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作回数が最大になるのはN=10^5，K=10^5，全ての電球の明るさの初期値が0の時なので，これを試してみると時間に十分間に合う．&lt;/p&gt;
&lt;p&gt;あとはやるだけ．&lt;/p&gt;
&lt;p&gt;解答を見ると，操作回数はO(log N)で抑えられるらしい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC169の解説</title>
      <link>https://t45k.github.io/kyopuro/abc169/</link>
      <pubDate>Mon, 01 Jun 2020 13:25:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc169/</guid>
      <description>&lt;p&gt;久々のABC水パフォ．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC169&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---multiplication-1&#34;&gt;A - Multiplication 1&lt;/h2&gt;
&lt;p&gt;読み込んで掛け算して出力するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---multiplication-2&#34;&gt;B - Multiplication 2&lt;/h2&gt;
&lt;p&gt;与えられた数字の中に0があれば確定で0．
それ以外の場合，それぞれ掛けて10^18を越えるかを確認すれば良い．
Javaだと&lt;code&gt;BigInteger&lt;/code&gt;が使える．
比較は&lt;code&gt;BigInteger#compareTo&lt;/code&gt;で，0より大きければ1が返るっぽい．&lt;/p&gt;
&lt;h2 id=&#34;c---multiplication-3&#34;&gt;C - Multiplication 3&lt;/h2&gt;
&lt;p&gt;罠．&lt;br&gt;
Javaだと&lt;code&gt;BigDecimal&lt;/code&gt;が使える．
解説通りにやるとするなら，一旦文字列で読み込んで，小数点を消した上で整数に変換すると良さそう．&lt;/p&gt;
&lt;h2 id=&#34;d---div-game&#34;&gt;D - Div Game&lt;/h2&gt;
&lt;p&gt;まずは素因数分解する．
問題の条件から素数pに対して，p^1，p^2，p^3，&amp;hellip;，p^kと割っていくのが最適となる．
したがって，各素数の出現回数からkを求めれば良い．
p^kまで作るには，出現回数は&lt;code&gt;1+2+3+...k=k(k+1)/2&lt;/code&gt;個必要となる．
これは，kを1から全部列挙して探せば良い．
出現回数の最大値は，N&amp;lt;=10^12≒2^40から高々40回程度なので，全列挙しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;e---count-median&#34;&gt;E - Count Median&lt;/h2&gt;
&lt;p&gt;たまたま解けた．&lt;br&gt;
とても単純化してみる．&lt;/p&gt;
&lt;h3 id=&#34;nが奇数の時&#34;&gt;Nが奇数の時&lt;/h3&gt;
&lt;p&gt;N=3で，以下のような時を考える．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;|---|  |---|  |---|
a   b  c   d  e   f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この時，明らかに中央値はc~dの整数値になる．&lt;br&gt;
このことから，何となく中央値は(0-indexedで)前からN/2番目の開始位置と後ろからN/2番目の終了位置の間の整数値であると考えられる．&lt;/p&gt;
&lt;h3 id=&#34;nが偶数の時&#34;&gt;Nが偶数の時&lt;/h3&gt;
&lt;p&gt;N=4で，以下のような時を考える．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;|---|  |---|  |---|  |---|
a   b  c   d  e   f  g   h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;この時，中央値は((c~dの値)+(e~fの値))/2となる．
また，片方を1動かせば，中央値は1/2変化するので，中央値は1/2刻みとなる．
中央値候補の最小値は(c+e)/2，最大値は(d+f)/2となるので，その間の1/2刻みの値が中央値になると考えられる．&lt;/p&gt;
&lt;p&gt;一般性は，あります！&lt;/p&gt;
&lt;h2 id=&#34;f---knapsack-for-all-subsets&#34;&gt;F - Knapsack for All Subsets&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;br&gt;
最初に，dp[N][S]を用意する．
各1&amp;lt;=i&amp;lt;=Nに対して，iを加えるか加えないかの2通りがあるので，iの遷移の度に，dp[i][j]はi-1の各jの値*2となる
そしてAiを加えるかの判定をする．ここは普通のDP&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NOMURA プログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/nomura2020/</link>
      <pubDate>Sun, 31 May 2020 15:57:56 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/nomura2020/</guid>
      <description>&lt;p&gt;何とか3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/nomura2020&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---study-scheduling&#34;&gt;A - Study Scheduling&lt;/h2&gt;
&lt;p&gt;時間を分に直して引き算するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---postdocs&#34;&gt;B - Postdocs&lt;/h2&gt;
&lt;p&gt;例えば，&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;P&lt;/code&gt;にした場合，その右側に&lt;code&gt;D&lt;/code&gt;がある時だけ指数が1増えるのに対して，&lt;code&gt;D&lt;/code&gt;にすると確実に指数が1増えることから，全ての&lt;code&gt;?&lt;/code&gt;を&lt;code&gt;D&lt;/code&gt;に変換するのが最適になる．&lt;/p&gt;
&lt;h2 id=&#34;c---folia&#34;&gt;C - Folia&lt;/h2&gt;
&lt;p&gt;解けてる人多くてびっくりした．
厳密な証明はeditorial参照．&lt;br&gt;
初めに木を上から下の方へ見ていって，それぞれの深さでの葉でない頂点(以降，節)の最大値数を求めていく．
深さiの葉の数がAiの時，深さi-1での節の数がAi/2未満の時，Ai個の葉を生成できないので条件を満たす木は存在しない．&lt;br&gt;
次に，木を下から上へ見ていき，各深さでの節の数を最適化していく．
木の頂点数を最大にするためには，各深さiに対して節の数を最大化したい．
節の数は，深さi+1の頂点数より大きくできない（全ての節は1つ以上の子を持つ），また，初めの操作により，深さiの節の個数から(深さi+1の頂点)個の子を産めることが分かっている．
したがって，深さiでの節の数の最大値は&lt;code&gt;min(深さiでの節の数，深さi+1での頂点の数)&lt;/code&gt;となる．
あとはこれを再帰的に計算して足し合わせるだけ．&lt;br&gt;
この解き方だと，n=0がコーナーケースになることに注意(&lt;code&gt;n=0&lt;/code&gt;, &lt;code&gt;A0=1&lt;/code&gt;の時のみ答えが&lt;code&gt;1&lt;/code&gt;で，それ以外は&lt;code&gt;-1&lt;/code&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「阿修羅ガール」読了</title>
      <link>https://t45k.github.io/blog/ashura-girl/</link>
      <pubDate>Thu, 28 May 2020 00:23:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ashura-girl/</guid>
      <description>&lt;p&gt;舞城王太郎の阿修羅ガールを読みました．&lt;/p&gt;
&lt;p&gt;一人称視点で進んでいくのですが，主人公の心の声の喋り方がとても真に迫った感じだったのが印象的でした．
特に，第二部の後半の進め方がすごく理解しやすく，場面をイメージしやすかったです．
他に，ディスコ探偵水曜日でも登場した桜月淡雪が出てきたのはニヤリとしました．
舞城王太郎の作品で西暁が出てこないのは珍しいのではないでしょうか．&lt;/p&gt;
&lt;p&gt;今回，人生で初めて電子書籍を試してみました．
読んだページの量で達成感を感じる人なので，どのくらいのページ読んだのかが直感的にわからない電子書籍は読書の達成感は薄かったです．&lt;/p&gt;
&lt;p&gt;次は，舞城王太郎と西尾維新が崇拝している（であろう）清涼院流水の「コズミック」を読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AGC044の解説</title>
      <link>https://t45k.github.io/kyopuro/agc044/</link>
      <pubDate>Wed, 27 May 2020 23:41:26 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc044/</guid>
      <description>&lt;p&gt;太陽でしたがNoSubなのでレートは変わらなかったです(NoSubというシステムをよく理解していなかったので，入力するのではないかとドキドキしてました)．
A，Bの解説．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/AGC/AGC044&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---pay-to-win&#34;&gt;A - Pay to Win&lt;/h2&gt;
&lt;p&gt;400点問題だと高を括って望んだら痛い目にあった．&lt;br&gt;
簡単に説明するとNから2，3，5で割っていくだけ．
メモ化(b|d)fs．
メモは値をキー，コストをバリューとしたMapで持つ．
bfsで解く場合は，キューから取り出した値Kに対して&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(a,d*K/2)&lt;/code&gt;（2で割るか，同じ値だけ1を引くかのコストが小さい方）がメモ[K/2]を更新できなければ何もしない．更新できれば，K/2をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K+1とK-1は2で割れるので，割れる場合と同じ処理をする．&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3で割れるか試す
&lt;ul&gt;
&lt;li&gt;割れる場合: &lt;code&gt;現在のコスト+min(b,d*2*K/3)&lt;/code&gt;がメモ[K/3]を更新できなければ何もしない．更新できれば，K/3をキューに追加する．&lt;/li&gt;
&lt;li&gt;破れない場合: K-K%3とK+3-K%3はKで割り切れるので，割れる場合と同じ処理をする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5で割れるか試す．略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;をやるだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---joker&#34;&gt;B - Joker&lt;/h2&gt;
&lt;p&gt;計算量の見積もりが難しい問題．&lt;br&gt;
N&amp;lt;=500に対して，与えられる座標の数はN^2なので，座標が与えられる度に(d|b)fsすると間に合わないように見える．
しかし，実は間に合う．
1回の(b|d)fsでいくつかの座標の端からの距離が減る
では全ての走査で行われる操作は合計でO(n^3)で収まる
例えばN=6の時，最初の各座標の端からの距離は以下のようになる&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 2 2 1 0&lt;br&gt;
0 1 1 1 1 0&lt;br&gt;
0 0 0 0 0 0&lt;br&gt;
全てを走査しきる（= 各座標の端からの距離が0になる）のは 4*4 + 2*2(四角形を狭めていくイメージ)回の操作が必要となる．
合計するとだいたい (N^3)/6 らしいので条件下で間に合う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC168の解説</title>
      <link>https://t45k.github.io/kyopuro/abc168/</link>
      <pubDate>Tue, 19 May 2020 19:54:50 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc168/</guid>
      <description>&lt;p&gt;速解き回だったけど速解き失敗．
4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC168&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a----therefore&#34;&gt;A - ∴ (Therefore)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;文を使う問題．
コードが長くなりがち．
Kotlinだと気持ちよく書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;fun main() {
    Scanner(System.`in`)
        .run {
            when (this.nextInt() % 10) {
                3 -&amp;gt; &amp;#34;bon&amp;#34;
                0, 1, 6, 8 -&amp;gt; &amp;#34;pon&amp;#34;
                else -&amp;gt; &amp;#34;hon&amp;#34;
            }.apply(::println)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;b----triple-dots&#34;&gt;B - &amp;hellip; (Triple Dots)&lt;/h2&gt;
&lt;p&gt;やるだけ．
Sの長さがKを上回っているとき，&lt;code&gt;S.substring(0, K.length)&lt;/code&gt;．&lt;/p&gt;
&lt;h2 id=&#34;c----colon&#34;&gt;C - : (Colon)&lt;/h2&gt;
&lt;p&gt;数学．&lt;br&gt;
極座標か余弦定理を使うと簡単に解ける．
意外と二つの針の間の角度を求めるのが曲者．&lt;/p&gt;
&lt;h2 id=&#34;d----double-dots&#34;&gt;D - .. (Double Dots)&lt;/h2&gt;
&lt;p&gt;嫌な気持ちになります．&lt;br&gt;
問題の条件から何となく根付き木のような構造が思い浮かぶので，幅探するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e----bullet&#34;&gt;E - ∙ (Bullet)&lt;/h2&gt;
&lt;p&gt;解説AC&lt;br&gt;
解く手順としては&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪いイワシを組み合わせないようにする方法&lt;/li&gt;
&lt;li&gt;最終的な組み合わせを数え上げる方法
の2つを考える．&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-仲の悪いイワシを組み合わせないようにする方法&#34;&gt;1. 仲の悪いイワシを組み合わせないようにする方法&lt;/h3&gt;
&lt;p&gt;Ai * Aj + Bi * Bj = 0という条件から，美味しさと香り高さがどちらも0のイワシは全てのイワシと仲が悪い．
それ以外のイワシについて考えると，仲が悪くなるにはAi = a, Bi =bの時，Aj = k&lt;em&gt;b, Bj = -k&lt;/em&gt;aとなる必要がある(kは0以外の整数)．
なのでイワシを2種類のグループに分ける．&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致する&lt;/li&gt;
&lt;li&gt;美味しさ，香り高さの符号が一致しない&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;そうすると，それぞれのグループを美味しさと香り高さを互いに素にした値のペアをキー，出現回数をバリューとしたマップにすると，それぞれのキーに対して仲の悪いイワシの数が分かる．
例えば，グループ1のキーを(美味しさの絶対値をGCDで割った値，香り高さの絶対値をGCDで割った値)，グループ2のキーを(香り高さの絶対値をGCDで割った値，美味しさの絶対値をGCDで割った値)にしておくと，グループ1とグループ2の共通するキーが仲の悪い組み合わせになる．&lt;/p&gt;
&lt;h3 id=&#34;2-最終的な組み合わせを数え上げる方法&#34;&gt;2. 最終的な組み合わせを数え上げる方法&lt;/h3&gt;
&lt;p&gt;まず，全てのイワシが仲が悪くないとき，組み合わせの総数は，どのイワシも選ばない組み合わせを除いて2^N-1になる．
これを踏まえると，先ほどのグループ1，2の各キーに対して，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;仲の悪い組み合わがある場合，それぞれのバリューp,qに対して 2^p + 2^q - 1&lt;br&gt;
これはグループ1，2両方のイワシを同時に加えることはできないので別々に計算する．グループ1だけから選ぶ場合は2^p通り，グループ2からだけ選ぶ場合は2^q通りになる．最後に，グループ1，2両方とも選ばない場合が重複しているので1引く．&lt;/li&gt;
&lt;li&gt;仲の悪い組み合わせがない場合，そのバリューpに対して 2^p&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;を掛けていき，最終的に1引いた値（どのイワシも選ばない組み合わせ）が答えになる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC167の解説</title>
      <link>https://t45k.github.io/kyopuro/abc167/</link>
      <pubDate>Mon, 11 May 2020 11:43:31 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc167/</guid>
      <description>&lt;p&gt;4完．
&lt;a href=&#34;https://github.com/t45k/tree/master/AtCoder/ABC/ABC167&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---registration&#34;&gt;A - Registration&lt;/h2&gt;
&lt;p&gt;文字列Sと文字列Tの最後の文字を消した文字列が同等か確認する．
javaだと &lt;code&gt;S.equals(T.substring(0, S.length))&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;b---easy-linear-programming&#34;&gt;B - Easy Linear Programming&lt;/h2&gt;
&lt;p&gt;A,B,Cの順番になるべく多くカードを取ると最大値になるので&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;KがA以下なら1のカードをK枚取って和はK&lt;/li&gt;
&lt;li&gt;Kが(A+B)以下なら，1のカードをA枚，0のカードを取れるだけ取って和はA&lt;/li&gt;
&lt;li&gt;それ以外なら1をA枚，0をB枚，-1を(K-(A+B))枚取って和は2A+B+K&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c---skill-up&#34;&gt;C - Skill Up&lt;/h2&gt;
&lt;p&gt;bit全探索するだけ問題．&lt;br&gt;
N&amp;lt;=12なので，全て試しても2^12≒4000通りなので十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---teleporter&#34;&gt;D - Teleporter&lt;/h2&gt;
&lt;p&gt;ABC030_Dとほぼ同じ問題．&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;knのとき&#34;&gt;K&amp;lt;=Nのとき&lt;/h3&gt;
&lt;p&gt;K回のテレポートを愚直に計算しても間に合う．&lt;/p&gt;
&lt;h3 id=&#34;knの時&#34;&gt;K&amp;gt;Nの時&lt;/h3&gt;
&lt;p&gt;鳩の巣原理的に考えると，必ずどこかでループが発生することになる．
なので，1ループで訪れる町の数でmodを取る．&lt;/p&gt;
&lt;h2 id=&#34;e---colorful-blocks&#34;&gt;E - Colorful Blocks&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．&lt;br&gt;
全て隣り合わない組み合わせは m*(m-1)^(n-1)になる．
1組隣り合う場合，その隣り同士は同じ色なので ↑/(m-1)
↑に組み合わせをかける．一つ右とペアになると考えれば n-1C1 通り
2組以降も同じように考える．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「クビシメロマンチスト 人間失格・零崎人識」読了</title>
      <link>https://t45k.github.io/blog/easy_love_easy_no/</link>
      <pubDate>Wed, 06 May 2020 20:45:52 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/easy_love_easy_no/</guid>
      <description>&lt;p&gt;西尾維新の戯言シリーズ2作目であるクビシメロマンチストを読みました．
&lt;a href=&#34;https://www.amazon.co.jp/%E3%82%AF%E3%83%93%E3%82%B7%E3%83%A1%E3%83%AD%E3%83%9E%E3%83%B3%E3%83%81%E3%82%B9%E3%83%88-%E4%BA%BA%E9%96%93%E5%A4%B1%E6%A0%BC%E3%83%BB%E9%9B%B6%E5%B4%8E%E4%BA%BA%E8%AD%98-%E8%AC%9B%E8%AB%87%E7%A4%BE%E6%96%87%E5%BA%AB-%E8%A5%BF%E5%B0%BE%E7%B6%AD%E6%96%B0-ebook/dp/B01EV0NMIG/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2WNUAO24W551I&amp;amp;dchild=1&amp;amp;keywords=%E3%82%AF%E3%83%93%E3%82%B7%E3%83%A1%E3%83%AD%E3%83%9E%E3%83%B3%E3%83%81%E3%82%B9%E3%83%88&amp;amp;qid=1588765443&amp;amp;sprefix=%E3%81%8F%E3%81%B3%E3%81%97%E3%82%81%2Caps%2C293&amp;amp;sr=8-1&#34;&gt;amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高校生くらいの時に一度読んだのですが，面白かったのを覚えていたため古本で購入しました．
2度目でしたがやっぱり面白くかったです．
中二臭い言い回し，叙述トリック，そして完璧なラストと個人的にツボにはまる部分が多く，24年間生きてきて面白かった本暫定一位です．
西尾維新といえば物語シリーズが有名ですが，このシリーズも負けず劣らず面白いのでぜひ皆さんに読んで欲しいとは思います．
区分的にはライトノベルになるので，10年後，20年後にはまた違った感想を抱くかもしれません．&lt;/p&gt;
&lt;p&gt;アニメ化期待してます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>競プロ</title>
      <link>https://t45k.github.io/kyopuro_index/</link>
      <pubDate>Wed, 06 May 2020 18:26:46 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro_index/</guid>
      <description>&lt;p&gt;競プロの解説とか．
Java でやっているのでコード例は Java になります．&lt;br&gt;
リポジトリは&lt;a href=&#34;https://github.com/t45k/kyopuro&#34;&gt;こちら&lt;/a&gt;．&lt;br&gt;
自作ライブラリのドキュメントは&lt;a href=&#34;../kyopuro/doc/library/package-summary.html&#34;&gt;こちら&lt;/a&gt;．&lt;/p&gt;
&lt;script src=&#34;https://code.jquery.com/jquery-2.1.3.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function(){
      $(&#34;#cover&#34;).load(&#34;../kyopuro/index.html #for_outer&#34;);
    });
&lt;/script&gt;
&lt;div id=&#34;cover&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ブログ</title>
      <link>https://t45k.github.io/blog_index/</link>
      <pubDate>Wed, 06 May 2020 18:26:39 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog_index/</guid>
      <description>&lt;p&gt;近況や今まで読んできた本の感想などを書いていきます．&lt;/p&gt;
&lt;script src=&#34;https://code.jquery.com/jquery-2.1.3.min.js&#34;&gt;&lt;/script&gt;
&lt;script&gt;
    $(function(){
      $(&#34;#cover&#34;).load(&#34;../blog/index.html #for_outer&#34;);
    });
&lt;/script&gt;
&lt;div id=&#34;cover&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>ABC166の解説</title>
      <link>https://t45k.github.io/kyopuro/abc166/</link>
      <pubDate>Mon, 04 May 2020 22:58:09 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc166/</guid>
      <description>&lt;p&gt;二日連続ABCの二日目．
ABCEの4完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC166&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---ac&#34;&gt;A - A?C&lt;/h2&gt;
&lt;p&gt;分岐するだけ．&lt;/p&gt;
&lt;h2 id=&#34;b---trick-or-treat&#34;&gt;B - Trick or Treat&lt;/h2&gt;
&lt;p&gt;数え上げるだけ&lt;/p&gt;
&lt;h2 id=&#34;c---peaks&#34;&gt;C - Peaks&lt;/h2&gt;
&lt;p&gt;結構誤読してた人が多かった問題&lt;br&gt;．
問題文から，i番目の展望台が地震を含めて繋がっている展望台の中で一番高ければ良いことが分かる．
つまり，繋がっている展望台のどれか一つでも自身より高いものが良い展望台となる．
なので，各A,Bに対して大きい方だけ残していくという戦略を取れば，残ったものが良い展望台である．&lt;/p&gt;
&lt;h2 id=&#34;d---i-hate-factorization&#34;&gt;D - I hate Factorization&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
問題文を誤読しないように．
&lt;strong&gt;任意の&lt;/strong&gt;Xについて成り立っているのではなく，&lt;strong&gt;テストケースとして与えられる&lt;/strong&gt;Xについて成り立つ．
およそ200くらいが上限となるらしいので，それについて全探索するだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---this-message-will-self-destruct-in-5s&#34;&gt;E - This Message Will Self-Destruct in 5s&lt;/h2&gt;
&lt;p&gt;条件は添字i,jに対して&lt;code&gt;i - j = Ai + Aj&lt;/code&gt;であり，これを式変形すると&lt;code&gt;i - Ai = j + Aj&lt;/code&gt;となる．
つまり，(添字と身長の差)と(添字と身長の和)が同じ値になるペアが条件を満たす．
なので各Aに対して添字との差と和をあらかじめ計算しておけば解ける&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC165の解説</title>
      <link>https://t45k.github.io/kyopuro/abc165/</link>
      <pubDate>Mon, 04 May 2020 22:58:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc165/</guid>
      <description>&lt;p&gt;二日連続ABCの一日目．
3完．
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/ABC165&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---we-love-golf&#34;&gt;A - We Love Golf&lt;/h2&gt;
&lt;p&gt;きちんと数学して解くこともできるが，制約が小さいので全探索しても間に合う．
AからBまでの閉区間内にKの倍数があるか確認する．&lt;/p&gt;
&lt;h2 id=&#34;b---1&#34;&gt;B - 1%&lt;/h2&gt;
&lt;p&gt;これもきちんと数学して解けるけど全探索で解ける系．
入力例から分かるように，10^18が与えられても出力は3760になるので，1~3760までの区間を探索するだけで良い．&lt;/p&gt;
&lt;h2 id=&#34;c---many-requirements&#34;&gt;C - Many Requirements&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解けませんでした&lt;/strong&gt;&lt;br&gt;
これも全探索するだけ問題．
考えられる数列を全列挙して特典の最大値を探す．&lt;br&gt;
全列挙に必要な計算量が10^10だと思っていたので試さなかったが，実際にはボールとしきりの要領で組み合わせを考えると計算量は*O(N * C(N+M-1,N))*なので，全列挙しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;d---floor-function&#34;&gt;D - Floor Function&lt;/h2&gt;
&lt;p&gt;数学．editorialが分かりやすいです．&lt;/p&gt;
&lt;h2 id=&#34;e---rotation-matching&#34;&gt;E - Rotation Matching&lt;/h2&gt;
&lt;p&gt;同じ組み合わせを避けていく問題．&lt;br&gt;
例えば，組み合わせ(1,N)は(1,2)と同じ組み合わせになる．
したがって，(組み合わせの方の大きい方)-(小さい方)を&lt;strong&gt;組み合わせの距離&lt;/strong&gt;と定義すると，距離N-iと距離iは同じ組み合わせである．
これを念頭に入れてN-1からN-mまでの組み合わせを考えていく．
(1,N)(2,N-1)&amp;hellip;と作っていくと距離N-1,N-3&amp;hellip;と1飛ばしに組み合わせを作れる．
途中で折り返しをうまく調整して距離N-2,N-4&amp;hellip;の組み合わせを作る．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC164の解説</title>
      <link>https://t45k.github.io/kyopuro/abc164/</link>
      <pubDate>Mon, 27 Apr 2020 23:38:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc164/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/atcoder/abc/abc164&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---sheep-and-wolves&#34;&gt;A - Sheep and Wolves&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---battle&#34;&gt;B - Battle&lt;/h2&gt;
&lt;p&gt;割った余りを求めるのがスマートだけで，先攻後攻の概念があるので愚直に互いに引いていった方が安全．&lt;/p&gt;
&lt;h2 id=&#34;c---gacha&#34;&gt;C - gacha&lt;/h2&gt;
&lt;p&gt;JavaだとSetに打ち込めば良い．
&lt;code&gt;Stream#distinct&lt;/code&gt;からの&lt;code&gt;Stream#count&lt;/code&gt;で多少スマートに書ける．&lt;/p&gt;
&lt;h2 id=&#34;d---multiple-of-2019&#34;&gt;D - Multiple of 2019&lt;/h2&gt;
&lt;p&gt;各桁に対して，i桁目の数字がDiとして&lt;code&gt;Si = (10 ^ i * Di + Si-1) % 2019&lt;/code&gt;を計算すると，Siが同じ値の桁間の数字は2019の倍数になる．&lt;/p&gt;
&lt;h2 id=&#34;e---two-currencies&#34;&gt;E - Two Currencies&lt;/h2&gt;
&lt;p&gt;むずかしかった．&lt;br&gt;
(頂点番号, 所持金)を一つの頂点としてダイクストラする．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>K-Shoot MANIAが正しく動かなくなった原因とその対策</title>
      <link>https://t45k.github.io/blog/k-shoot_mania/</link>
      <pubDate>Sat, 25 Apr 2020 17:05:30 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/k-shoot_mania/</guid>
      <description>&lt;p&gt;K-Shoot MANIAの挙動がおかしい原因が分かったのでメモ&lt;/p&gt;
&lt;h2 id=&#34;症状&#34;&gt;症状&lt;/h2&gt;
&lt;p&gt;キーボードの入力が異様に遅くなる．
キーボードを押しっぱなしにして10秒後くらいにようやく反応する．
もちろんプレイもままならない．
Windowsのpreview版を使っていたのでそれが原因かなと思っていたが，違うPCでも同じ症状が出たためOSは関係なかった．&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;
&lt;p&gt;キーボードの入力を書き換えるソフトを使っていたのが原因．
&lt;a href=&#34;https://sites.google.com/site/craftware/keyhac-ja&#34;&gt;keyhac&lt;/a&gt;と&lt;a href=&#34;https://www.karakaram.com/alt-ime-on-off&#34;&gt;alt-ime&lt;/a&gt;を使っていたが，これのせいでキーボードの入力がケーシューに正しく反映されなくなってたっぽい．
対策は簡単で，該当ソフトを落とすだけ．&lt;/p&gt;
&lt;h2 id=&#34;終わりに&#34;&gt;終わりに&lt;/h2&gt;
&lt;p&gt;LR2の反応がおかしかったのもこれが原因かも．
自宅ゲーセン環境で快適なひきこもり生活を．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「ディスコ探偵水曜日」読了</title>
      <link>https://t45k.github.io/blog/disco_detective_wednesdayyy/</link>
      <pubDate>Fri, 24 Apr 2020 19:01:51 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/disco_detective_wednesdayyy/</guid>
      <description>&lt;p&gt;&lt;strong&gt;この世の出来事は全部運命と意志の相互作用で生まれるんだって、知ってる？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「ディスコ探偵水曜日」を読みました．
10年以上前の本なのでおそらく新品ではもう手に入りません．
僕はBook Offをはしごしました．&lt;/p&gt;
&lt;p&gt;上中下の3巻構成なのですが，下巻が異様に長い上にとても難解．
この本を読むのは2回目ですが，今回も内容を理解しきれませんでした．&lt;/p&gt;
&lt;p&gt;粗筋は割愛します．
個人的には中間の，名探偵が次々と推理を披露して死んでいくシーンと，そしてディスコが最後の推理をするシーンが，
舞城王太郎特有のスピード感があって好きです．&lt;/p&gt;
&lt;p&gt;1年に1回，イベントとしてこの本を読むことをありかなぁと思いました．&lt;/p&gt;
&lt;p&gt;次は西尾維新の「クビシメロマンチスト」を読む予定です．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC163の解説</title>
      <link>https://t45k.github.io/kyopuro/abc163/</link>
      <pubDate>Tue, 21 Apr 2020 16:22:58 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc163/</guid>
      <description>&lt;p&gt;3完．
unratedで良かった&amp;hellip;
&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/ABC/ABC163&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---circle-pond&#34;&gt;A - Circle Pond&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
円周は&lt;code&gt;2 * r * 円周率&lt;/code&gt;．
Javaだと円周率は&lt;code&gt;java.lang.Math.PI&lt;/code&gt;が使える．&lt;/p&gt;
&lt;h2 id=&#34;b---homework&#34;&gt;B - Homework&lt;/h2&gt;
&lt;p&gt;全ての宿題をやるには&lt;code&gt;Σ Ai&lt;/code&gt;日かかるので，それを&lt;code&gt;M&lt;/code&gt;と比較する．&lt;/p&gt;
&lt;h2 id=&#34;c---management&#34;&gt;C - management&lt;/h2&gt;
&lt;p&gt;問題文が若干ややこしい．
やることは特定の数字が何回出てくるかを数えるだけ．
はじめに配列&lt;code&gt;array[N + 1]&lt;/code&gt;を用意して，各&lt;code&gt;Ai&lt;/code&gt;に対して&lt;code&gt;array[Ai]++&lt;/code&gt;する．&lt;/p&gt;
&lt;h2 id=&#34;d---sum-of-large-numbers&#34;&gt;D - Sum of Large Numbers&lt;/h2&gt;
&lt;p&gt;時間内に解けなかった．
組み合わせの問題だと思ってライブラリを引っ張ってきたけど使わなかった&amp;hellip;&lt;br&gt;
各数字が10^100以上と十分大きいので，足し合わせる個数が違うとき同じ値になることはない．
あるiに対して&lt;code&gt;front_sum&lt;/code&gt;を0からi-1までの和，&lt;code&gt;back_sum&lt;/code&gt;をn-i+1からnまでの和とすると，
i個選択する時の組み合わせによって得られる和は&lt;code&gt;i * 10^100 + front_sum&lt;/code&gt;から&lt;code&gt;i * 10^100 + back_sum&lt;/code&gt;までの間に収まる．
つまり，&lt;code&gt;back_sum - front_sum + 1&lt;/code&gt;通りになる．
&lt;code&gt;front_sum&lt;/code&gt;と&lt;code&gt;back_sum&lt;/code&gt;は累積和で取れるので，iをKからNまで動かして足し合わせれば良い．&lt;/p&gt;
&lt;h2 id=&#34;e---active-infants&#34;&gt;E - Active Infants&lt;/h2&gt;
&lt;p&gt;原始的なDP（ほんまか？）．&lt;br&gt;
活発度が高い順に左か右に移動させる．
活発度を降順にソートした時，&lt;code&gt;dp[i][j]&lt;/code&gt;を，&lt;strong&gt;(i+j)番目の園児を移動させた結果左側にi人，右側にj人の時の嬉しさ&lt;/strong&gt;という風に考える．
そうすると，&lt;code&gt;dp[i][j]&lt;/code&gt;は&lt;strong&gt;左側にi-1人，右側にj人いるときに(i+j)番目の園児を左側に移動させる&lt;/strong&gt;か&lt;strong&gt;左側にi人，右側にj-1人いるときに(i+j)番目の園児を右側に移動させる&lt;/strong&gt;の嬉しさが大きい方になる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacでIntelliJを使っているとクラッシュする問題と解決法</title>
      <link>https://t45k.github.io/blog/fix_mac_fault/</link>
      <pubDate>Mon, 13 Apr 2020 17:38:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/fix_mac_fault/</guid>
      <description>&lt;p&gt;MacBook Air 2020を買いました．詳しくは&lt;a href=&#34;https://t45k.github.io/blog/macbook_air&#34;&gt;ここ&lt;/a&gt;．&lt;/p&gt;
&lt;p&gt;普段はJavaやKotlinを書いているので迷いなくIntelliJ IDEAをインストールしたのですが，どうも挙動がおかしい．&lt;br&gt;
というのも，結構な頻度でIntelliJがクラッシュするし，場合によってはOSがクラッシュ強制的に再起動がかかります．
ひどい時にはOSがクラッシュして再起動がかかり，それが開けた2分後に再びクラッシュしたこともあります．&lt;/p&gt;
&lt;p&gt;実は&lt;a href=&#34;https://t45k.github.io/blog/line&#34;&gt;LINEのインターン&lt;/a&gt;で借りていたMacBook Pro 15inchでも似たような問題が起こっていたので，2度目の経験でした．&lt;br&gt;
インターンで借りていたパソコンは5日間で返すので我慢して使っていましたが，今回は長らく使っていく予定なので流石に直す必要がありました．&lt;/p&gt;
&lt;p&gt;修理も視野に入れながら解決法を探しました．&lt;/p&gt;
&lt;h2 id=&#34;解決法&#34;&gt;解決法&lt;/h2&gt;
&lt;p&gt;結論からいうと原因は分かりませんでしたが()，&lt;strong&gt;OSを再インストール&lt;/strong&gt;することで解決しました．詳しくは&lt;a href=&#34;https://support.apple.com/ja-jp/HT204904&#34;&gt;こちら&lt;/a&gt;．&lt;br&gt;
原因が分からないので全ての人がこれで直るかは分かりませんが，OS再インスコでデータが消えることはないため真っ先に試す価値はあります．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacBook Airを購入した話</title>
      <link>https://t45k.github.io/blog/macbook_air/</link>
      <pubDate>Mon, 13 Apr 2020 17:21:02 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/macbook_air/</guid>
      <description>&lt;h3 id=&#34;念願のmacbook-airを購入しました&#34;&gt;念願のMacBook Airを購入しました!&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/mba.JPG&#34; alt=&#34;mba&#34;&gt;&lt;/p&gt;
&lt;p&gt;構成は&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU: 1.1GHzクアッド&lt;/li&gt;
&lt;li&gt;メモリ: 16GB&lt;/li&gt;
&lt;li&gt;SSD: 256GB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数ヶ月後に出ると噂のMacBook Proを待っている人もいるかもしれませんが，僕は以下のような理由でmbaを選びました．&lt;/p&gt;
&lt;h2 id=&#34;1---もう待てなかったから&#34;&gt;1 - もう待てなかったから&lt;/h2&gt;
&lt;p&gt;ずっと新しいmacが欲しいと思っていたのでこれ以上待てませんでした&lt;/p&gt;
&lt;h2 id=&#34;2---そこまでスペックを必要としていないかったから&#34;&gt;2 - そこまでスペックを必要としていないかったから&lt;/h2&gt;
&lt;p&gt;研究室からmbpを借りていますし，研究などでマシンパワーが必要な時は研究室のワークステーションを使えば良いだけなので&lt;/p&gt;
&lt;h2 id=&#34;3---touch-barが嫌いだから&#34;&gt;3 - Touch barが嫌いだから&lt;/h2&gt;
&lt;p&gt;バタフライキーボードはともかく，Touch barは賛否両論ありますが，僕はあまり好きになれませんでした．
たまに反応しなくなったりするし．&lt;/p&gt;
&lt;h2 id=&#34;4---安いから&#34;&gt;4 - 安いから&lt;/h2&gt;
&lt;p&gt;税込み13万で買えました．
mbpはこんなものじゃすまないと思います．&lt;/p&gt;
&lt;p&gt;理由としてはこんなところです．
付け加えるなら，自分の理想にとても近かったというのもあります．
これは去年の12月のツイート&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;はよmacbook air，13インチ，cpu4コア，RAM16GB，SSD256GB，ファンクションキー，シザーキーボードで10万くらいのやつ出てくれや&lt;/p&gt;&amp;mdash; task (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1203581420871905280?ref_src=twsrc%5Etfw&#34;&gt;December 8, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;使い心地&#34;&gt;使い心地&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://t45k.github.io/blog/fix_mac_fault&#34;&gt;ある一点&lt;/a&gt;を除いたら最高です（その一点も結局解決しました）．&lt;/p&gt;
&lt;p&gt;主にmbpとの比較になるのですが，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;軽い&lt;/li&gt;
&lt;li&gt;薄い&lt;/li&gt;
&lt;li&gt;開けやすい(mbaは切り欠けが下まで貫通している)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;みたいなところです．&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;こうなりました．
&lt;img src=&#34;https://t45k.github.io/img/blog/stecker.JPG&#34; alt=&#34;stecker&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC162の解説</title>
      <link>https://t45k.github.io/kyopuro/abc162/</link>
      <pubDate>Mon, 13 Apr 2020 16:57:30 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc162/</guid>
      <description>&lt;p&gt;祝参加者1万人越え．無念の4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC162&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---lucky-7&#34;&gt;A - Lucky 7&lt;/h2&gt;
&lt;p&gt;やるだけ．文字列で読み込んで&lt;code&gt;String#contains&lt;/code&gt;を使うと早い．&lt;/p&gt;
&lt;h2 id=&#34;b---fizzbuzz-sum&#34;&gt;B - FizzBuzz Sum&lt;/h2&gt;
&lt;p&gt;これもやるだけ．&lt;code&gt;LongStream&lt;/code&gt;できれいに書ける．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;LongStream.rangeClosed(1, scanner.nextInt())
    .filter(i -&amp;gt; i % 3 != 0 &amp;amp;&amp;amp; i % 5 != 0)
    .sum();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---sum-of-gcd-of-tuples-easy&#34;&gt;C - Sum of gcd of Tuples (Easy)&lt;/h2&gt;
&lt;p&gt;三重ループを回すだけ．&lt;/p&gt;
&lt;h2 id=&#34;d---rgb-triplets&#34;&gt;D - RGB Triplets&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;N &amp;lt;= 4,000&lt;/code&gt;なので二重ループで回すことを考える．
ある座標以降のそれぞれの色が何個あるかを記録する．
これは後ろから累積和をとることで可能．
こうすることで，例えば&lt;code&gt;i&lt;/code&gt;が赤色，&lt;code&gt;j&lt;/code&gt;が緑色のとき，&lt;code&gt;j+1&lt;/code&gt;以降の青色の個数を&lt;code&gt;O(1)&lt;/code&gt;で得られる．
また，&lt;code&gt;k-j ≠ j-i&lt;/code&gt;の条件を満たすために，k-j = j-iとなるkに対して&lt;code&gt;(j+1以降の数) - (k以降の数) + (k+1以降の数)&lt;/code&gt;と計算すれば良い(累積和の性質から)．&lt;/p&gt;
&lt;h2 id=&#34;e---sum-of-gcd-of-tuples-hard&#34;&gt;E - Sum of gcd of Tuples (Hard)&lt;/h2&gt;
&lt;p&gt;解法は思いついていたが計算量的にダメだと思っていて放置していたやつ&lt;br&gt;．
解答が詳しいのでそちらを参照．
繰り返し二乗法などを使うと速くなる．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC161の解説</title>
      <link>https://t45k.github.io/kyopuro/abc161/</link>
      <pubDate>Sat, 04 Apr 2020 22:53:03 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc161/</guid>
      <description>&lt;p&gt;100-200-300-400-600の5完．
人生初のオンサイト600点問題AC．
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC161&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---abc-swap&#34;&gt;A - ABC Swap&lt;/h2&gt;
&lt;p&gt;Z，X，Yを順に出力するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---popular-vote&#34;&gt;B - Popular Vote&lt;/h2&gt;
&lt;p&gt;やるだけ．&lt;br&gt;
割り算の結果を比較するときは，&lt;code&gt;a &amp;gt; b / c&lt;/code&gt;ではなく&lt;code&gt;a * c &amp;gt; b&lt;/code&gt;のように書いたほうが正確．&lt;/p&gt;
&lt;h2 id=&#34;c---replacing-integer&#34;&gt;C - Replacing Integer&lt;/h2&gt;
&lt;p&gt;方針立てるのに時間かかった問題．&lt;br&gt;
直感的には分かりづらいけど以下のように言い換えられる(chokudaiさんのツイート)．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;C問題、数学の問題といえばそうなんだけど、「無限に長いすごろくがあります。ゴールまでの距離がxです。Kマスずつ進めますが、ゴールを通り過ぎてしまう場合は折り返します。最もゴールに近づく時の残りマス数を答えなさい」みたいにすると、まぁ一応ちゃんとしたストーリーはつくよね。&lt;/p&gt;&amp;mdash; chokudai(高橋 直大)🌸🍆🍡 (@chokudai) &lt;a href=&#34;https://twitter.com/chokudai/status/1246435428476973063?ref_src=twsrc%5Etfw&#34;&gt;April 4, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;というわけで，&lt;code&gt;N % K&lt;/code&gt;と&lt;code&gt;(N - (N % K)) % K&lt;/code&gt;の小さい方を求める．&lt;/p&gt;
&lt;h2 id=&#34;d---lunlun-number&#34;&gt;D - Lunlun Number&lt;/h2&gt;
&lt;p&gt;想定解が天才すぎる．愚直に解いた．&lt;br&gt;
i番目の数字に対して，i + 1番目の数字を次のように決める．各桁を下から順番に見ていく．もし見ている桁が9でなく，かつ次の桁の数字より1小さいか同じなら，その桁をインクリメントし，それ以降の桁をルンルン数かつ最小となるように調整(つまり，&amp;lsquo;上の桁 - 1&amp;rsquo;か&#39;0&amp;rsquo;)した値がi + 1番目の数になる．どの桁も条件に当てはまらなければ，一番大きい桁をインクリメントする．&lt;br&gt;
各桁を確認，操作する場合は，数字をいったんchar型配列にするとやりやすいかも．&lt;/p&gt;
&lt;h2 id=&#34;e---yutori&#34;&gt;E - Yutori&lt;/h2&gt;
&lt;p&gt;解説AC．&lt;br&gt;
前から貪欲と後ろから貪欲の結果を比較するだけ．解説に登場する配列L，Rを求めなくても，二分探索しても十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;f---division-or-substraction&#34;&gt;F - Division or Substraction&lt;/h2&gt;
&lt;p&gt;E問題よりACが多いF問題．&lt;br&gt;
まずNに対して以下の数字は必ず条件を満たす&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2: 偶数は割っていくと，奇数は引いていくと最終的に1になるため&lt;/li&gt;
&lt;li&gt;N - 1: 引くと1になるため&lt;/li&gt;
&lt;li&gt;N: 割ると1になるため&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;それ以外に関しては関しては次のようになる．
ちなみに&amp;quot;何回か引いた後にに，何回か割る&amp;quot;という操作は発生しない．&lt;/p&gt;
&lt;h3 id=&#34;引くことしか考えない&#34;&gt;引くことしか考えない&lt;/h3&gt;
&lt;p&gt;N % L == 1 となるLを考えればよい．
このLは，N - 1の約数列挙を行うことで求まる．&lt;/p&gt;
&lt;h3 id=&#34;何回か割って何回か引く&#34;&gt;何回か割って，何回か引く&lt;/h3&gt;
&lt;p&gt;これは 3 ~ sqrt(N) (sqrt(N)を超過すると，1回割っただけで割る数を下回ってしまうので考えなくて良い)の各値iに対して，余りが0である間可能な限りiで割った後に，&lt;code&gt;N % i == 1&lt;/code&gt;となるかを確認すれば良い．&lt;/p&gt;
&lt;p&gt;これらの結果を足し合わせるだけ．
この解法だと&lt;strong&gt;2&lt;/strong&gt;がコーナーケースになることに注意．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AtCoderで水色になりました</title>
      <link>https://t45k.github.io/blog/nyusui/</link>
      <pubDate>Sun, 29 Mar 2020 00:16:31 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/nyusui/</guid>
      <description>&lt;p&gt;先日行われた&lt;a href=&#34;https://atcoder.jp/contests/abc160&#34;&gt;ABC160&lt;/a&gt;にて無事に入水を果たしたのでポエムを書きます．
&lt;img src=&#34;https://t45k.github.io/img/blog/nyusui.png&#34; height=&#34;75%&#34; width=&#34;75%&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;感じたこと&#34;&gt;感じたこと&lt;/h2&gt;
&lt;p&gt;一つの目標だった水色に到達してほっとしています．
人によっては10回かそこらでなる人もいる中，53回目でようやくなれた自分の才能とセンスのなさには本当に辟易しています．
精進が大事．
蟻本は最初の章しか読めてないけど結構役に立ちました．&lt;/p&gt;
&lt;h2 id=&#34;次は&#34;&gt;次は&lt;/h2&gt;
&lt;p&gt;せっかくなので青色を目指します．
ここ2回のABCは青パフォが出てるので，この調子で頑張っていきたいです．&lt;/p&gt;
&lt;h2 id=&#34;最後に&#34;&gt;最後に&lt;/h2&gt;
&lt;p&gt;毎回楽しいコンテストを開催してくれているAtCoder社と，その問題を用意してくれているWriter，Testerの皆様に心から感謝します．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC160の解説</title>
      <link>https://t45k.github.io/kyopuro/abc160/</link>
      <pubDate>Sat, 28 Mar 2020 23:27:57 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc160/</guid>
      <description>&lt;p&gt;5完．&lt;a href=&#34;https://github.com/T45K/tree/master/AtCoder/ABC/ABC160&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---coffee&#34;&gt;A - Coffee&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．&lt;code&gt;String#charAt&lt;/code&gt;を使う&lt;/p&gt;
&lt;h2 id=&#34;b---golden-coins&#34;&gt;B - Golden Coins&lt;/h2&gt;
&lt;p&gt;なるべく多くの500円に換金した方が良いので，まずは&lt;code&gt;X&lt;/code&gt;を500で割る．
余りを50で割って，それぞれの商に1000と5を掛けて出力．&lt;/p&gt;
&lt;h2 id=&#34;c---traveling-salesman-around-lake&#34;&gt;C - Traveling Salesman around Lake&lt;/h2&gt;
&lt;p&gt;ある家からその一つ手前の家までをぐるっと一周回ってくるのが最適となる．
1番目の家からN番目の家までに移動距離は&lt;code&gt;Ai - AN&lt;/code&gt;，それ以外の家iから家i - 1までは&lt;code&gt;K - Ai + Ai-1&lt;/code&gt;になるので，その中の最小値が答え．&lt;/p&gt;
&lt;h2 id=&#34;d---line&#34;&gt;D - 	Line++&lt;/h2&gt;
&lt;p&gt;ワーシャルフロイドっぽい問題．&lt;br&gt;
まず初めにX，Yを経由しない場合の全ての頂点間の距離を求める．
これはグラフを隣接行列で表すと&lt;code&gt;graph[i][j] = |i - j|&lt;/code&gt;となる．&lt;br&gt;
次に，XまたはYを経由した場合を考えた上で，全ての頂点間の最短距離を求める．
これは&lt;code&gt;graph[i][j] = min(graph[i][j], graph[i][X] + graph[X][j])&lt;/code&gt;となる．&lt;br&gt;
最後に，隣接行列の中で各距離の出現回数を記録し，それを出力する．&lt;/p&gt;
&lt;h2 id=&#34;e---red-and-green-apples&#34;&gt;E - Red and Green Apples&lt;/h2&gt;
&lt;p&gt;貪欲にやるだけ．&lt;br&gt;
美味しさを最大化したいとき，赤リンゴを降順に並べたときのX+1つ目以降と緑リンゴを降順に並べたときののY+1つ目以降は捨ててもよい．
後はそれぞれのリンゴの小さいものを順番に無色のものと入れ替えるだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC159の解説</title>
      <link>https://t45k.github.io/kyopuro/abc159/</link>
      <pubDate>Sun, 22 Mar 2020 22:48:22 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc159/</guid>
      <description>&lt;p&gt;奇跡的に5完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC159&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---the-number-of-even-pairs&#34;&gt;A - The Number of Even Pairs&lt;/h2&gt;
&lt;p&gt;和が正になるのは&lt;code&gt;even + even&lt;/code&gt;か&lt;code&gt;odd + odd&lt;/code&gt;の時なので，偶奇それぞれに対して組み合わせ(&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;)を計算して足し合わせる．&lt;/p&gt;
&lt;h2 id=&#34;b---string-palindrome&#34;&gt;B - String Palindrome&lt;/h2&gt;
&lt;p&gt;書かれてることをするだけ．
回文系の問題は以下のようなメソッドを作っとくと便利かも．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; isPalindrome(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; start, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; end, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String s) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; ; i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (start + i &amp;gt;= end - i) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
        &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.charAt(start + i) != s.charAt(end - i)) {
            &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;c---maximum-volume&#34;&gt;C - Maximum Volume&lt;/h2&gt;
&lt;p&gt;Lの1/3の3乗&lt;/p&gt;
&lt;h2 id=&#34;d---banned-k&#34;&gt;D - Banned K&lt;/h2&gt;
&lt;p&gt;考えた方としては，初めに何も取り除かないときの組み合わせの総数を求めておいて，それを使って取り除いた数字の組み合わせを計算し直すという感じ．&lt;br&gt;
初めに全ての組み合わせの和を計算する．
これは連想配列を用いてどの数字が何回出てくるかを数え上げて，各回数に対して&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を計算して足し合わせるだけ．
次に，各数字を取り除いた場合を考える．
取り除いた数字の組み合わせは&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;になってしまうので，総和から&lt;code&gt;n * (n - 1) / 2&lt;/code&gt;を引いて&lt;code&gt;(n - 1) * (n - 2) / 2&lt;/code&gt;を足した数が求めたい数字になる．&lt;/p&gt;
&lt;h2 id=&#34;e---dividing-chocolate&#34;&gt;E - Dividing Chocolate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;が大きなヒント．&lt;br&gt;
&lt;code&gt;H &amp;lt;= 10&lt;/code&gt;から，横方向に切る組み合わせは全探索を使える(&lt;code&gt;2 ^ 10 ≒ 10 ^ 3&lt;/code&gt;)．
横方向に切った結果から，Kを超えないように縦方向に切らないといけない回数を貪欲に算出できる．&lt;/p&gt;
&lt;h2 id=&#34;f----knapsack-for-all-segments&#34;&gt;F -  Knapsack for All Segments&lt;/h2&gt;
&lt;p&gt;解説AC．なぜか解説通りに実装するとTLEになったため別の方針を採用(&lt;a href=&#34;https://atcoder.jp/contests/abc159/submissions/11164623&#34;&gt;https://atcoder.jp/contests/abc159/submissions/11164623&lt;/a&gt;)．&lt;br&gt;
&lt;code&gt;Ax1 + Ax2 + ... Axn = S&lt;/code&gt;を満たす時，&lt;code&gt;s = 1, 2, ..., x1&lt;/code&gt;，&lt;code&gt;e = xn, xn + 1, ..., N&lt;/code&gt;とすると，sからeまでの文字列は全て条件を満たす．
そこで，始点と終点を決めるためのDPを行う．&lt;br&gt;
答えを表す変数&lt;code&gt;ans&lt;/code&gt;，dp[N][S]を用意し，次の場合分けを考える．j = 0 .. S - 1 に対して，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;場合分け&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Ai を足さない&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;dp[N][j] = dp[N - 1][j]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Ai を足す&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Ai を始点にする場合 dp[N][j] += dp[N - 1][j] + i&lt;br&gt;Ai を始点にしない場合 dp[N][j + Ai] += dp[N - 1][j]&lt;br&gt;Ai を終点にする場合 answer += dp[N - 1][S - Ai] * (n - i)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>AGC043の解説</title>
      <link>https://t45k.github.io/kyopuro/agc043/</link>
      <pubDate>Sat, 21 Mar 2020 23:37:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/agc043/</guid>
      <description>&lt;script async src=&#34;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&#34;&gt;&lt;/script&gt;
&lt;p&gt;1完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/AGC/AGC043&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---range-flip-find-route&#34;&gt;A - Range Flip Find Route&lt;/h2&gt;
&lt;p&gt;全探索の計算量をいかに減らせるかがポイント．DPは思いつかんかった&amp;hellip;&lt;/p&gt;
&lt;p&gt;右か下にしか移動できない時，黒ゾーンに入ってから出るまでの経路を一回の操作で白にできる（公式参照）．
なので，白から黒に入る経路のコストを1，それ以外を0とみなした最短経路問題に落とし込むことができる．
ダイクストラ法を使うと計算量は頂点数&lt;code&gt;V&lt;/code&gt;と辺数&lt;code&gt;E&lt;/code&gt;に対して&lt;code&gt;O(V * log(E))&lt;/code&gt;となる．
今回の頂点数Vは&lt;code&gt;V &amp;lt;= H * W = 10 ^ 4&lt;/code&gt;となる．
また，一つの頂点に対して辺の数はたかだか2(右に移動するか下に移動するかの2通り)なので，十分間に合う．&lt;/p&gt;
&lt;h2 id=&#34;b---123-triangle&#34;&gt;B - 123 Triangle&lt;/h2&gt;
&lt;p&gt;誰がこんな解法思いつくんでしょうね&amp;hellip;(解説AC)&lt;/p&gt;
&lt;p&gt;答えは0，1，2のいずれかになるので，初めに答えの偶奇を判定する．
各aは先に1引いといても問題ない．
偶奇判定なので，&lt;code&gt;abs(a - b)&lt;/code&gt;ではなく&lt;code&gt;a xor b&lt;/code&gt;で良い．
そうすると，
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;=&lt;/mo&gt;
&lt;mo&gt;(&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,2&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mo&gt;&amp;hellip;&lt;/mo&gt;
&lt;mo&gt;^&lt;/mo&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;n-1&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;mo&gt;⁢&lt;/mo&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;1,n&lt;/mn&gt;
&lt;/msub&gt;
&lt;mo&gt;)&lt;/mo&gt;
&lt;mo&gt;%&lt;/mo&gt;
&lt;mn&gt;2&lt;/mn&gt;
&lt;/math&gt;
となる．
そのため，各組み合わせを計算すれば良い．&lt;br&gt;
今回は偶奇が欲しいので，各組み合わせの2で割った余りだけで十分である．
そこで&lt;a href=&#34;https://mathtrain.jp/lucastheorem&#34;&gt;&lt;strong&gt;Lucasの定理&lt;/strong&gt;&lt;/a&gt;を用いる(リンク参照)．
定理に従うと手順はこう．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初めに&lt;code&gt;n - 1&lt;/code&gt;を二進数に変換する&lt;/li&gt;
&lt;li&gt;各aを二進数に変換する(&lt;code&gt;n - 1&lt;/code&gt;の二進数表現と桁を揃えることに注意)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n - 1&lt;/code&gt;と&lt;code&gt;a&lt;/code&gt;の二進数表現の各桁(それぞれm，nとする)に対して組み合わせ(つまり，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mi&gt;n&lt;/mi&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mi&gt;m&lt;/mi&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;
)を計算する(各桁は0か1なので，
&lt;math&gt;
&lt;mmultiscripts&gt;
&lt;mo&gt;C&lt;/mo&gt;
&lt;mn&gt;1&lt;/mn&gt;
&lt;none /&gt;
&lt;mprescripts /&gt;
&lt;mn&gt;0&lt;/mn&gt;
&lt;none /&gt;
&lt;/mmultiscripts&gt;
&lt;/math&gt;の時だけ0でそれ以外は1になる)&lt;/li&gt;
&lt;li&gt;組み合わせの計算結果をかけ合わせる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これで
&lt;math&gt;
&lt;msub&gt;
&lt;mi&gt;x&lt;/mi&gt;
&lt;mn&gt;n,1&lt;/mn&gt;
&lt;/msub&gt;
&lt;/math&gt;
の偶奇が出るので，答えが1かどうかが分かる．&lt;br&gt;
答えが奇数の場合は，数字列中に1が含まれていれば答えは0となる&lt;br&gt;
それでも決まらなければ，各aを2で割った上でもう一度偶奇を計算すると0か2が確定する．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「みんな元気。」読了</title>
      <link>https://t45k.github.io/blog/all_fine/</link>
      <pubDate>Fri, 20 Mar 2020 12:00:53 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/all_fine/</guid>
      <description>&lt;p&gt;&lt;strong&gt;みんな大丈夫。みんな元気。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「みんな元気。」を読みました．&lt;a href=&#34;https://www.amazon.co.jp/%E3%81%BF%E3%82%93%E3%81%AA%E5%85%83%E6%B0%97%E3%80%82-%E8%88%9E%E5%9F%8E%E7%8E%8B%E5%A4%AA%E9%83%8E-ebook/dp/B00CL6N332/ref=sr_1_5?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;dchild=1&amp;amp;keywords=%E3%81%BF%E3%82%93%E3%81%AA%E5%85%83%E6%B0%97&amp;amp;qid=1584673351&amp;amp;sr=8-5&#34;&gt;Amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この本は，表題である「みんな元気。(副題: Cuckoos &amp;amp; The Invisible Devil)」と短編4編で構成されています．
例によってきっかけはDJ Technorch．&lt;/p&gt;
&lt;p&gt;粗筋は，空飛ぶ家族が主人公の妹を拐いに来てなんやかんやある感じです．
相変わらず難解だった気がします．
この物語は，「選択」が主題の一つだと思います．
副題のカッコウから，拐われた妹が実は托卵だったみたいな展開を予想しましたが全然そんなことありませんでした．
風呂敷をめちゃくちゃに広げたうえで畳むことなく急に終わる感じなのですが，終わり方が納得できるというかとても爽やかでした．&lt;/p&gt;
&lt;p&gt;短編集の中では，「スクールアタック・シンドローム」が好きです．&lt;/p&gt;
&lt;p&gt;なんとなく，舞城王太郎特有のスピード感的なものを理解してきた気がしました．&lt;/p&gt;
&lt;p&gt;次はおそらく「九十九十九」を読みます．&lt;/p&gt;
&lt;p&gt;最後に&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/-71fQjkZ0X8&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>パナソニックプログラミングコンテスト2020の解説</title>
      <link>https://t45k.github.io/kyopuro/panasonic2020/</link>
      <pubDate>Sat, 14 Mar 2020 22:56:44 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/panasonic2020/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/others/pana20&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---kth-term&#34;&gt;A - Kth Term&lt;/h2&gt;
&lt;p&gt;実装するだけ．
Javaの場合は問題文をコピペして&lt;code&gt;final int[] array = {1, 1, ...};&lt;/code&gt;と宣言すると早い．&lt;/p&gt;
&lt;h2 id=&#34;b---bishop&#34;&gt;B - Bishop&lt;/h2&gt;
&lt;p&gt;ここに一番時間を吸われた．&lt;br&gt;
問題例を見ると最終的に&lt;code&gt;(h * w + 1) / 2&lt;/code&gt;でいけそうに見えるが，hまたはwが1の時角は一切移動できなくなることに気付けるかがポイント．&lt;/p&gt;
&lt;h2 id=&#34;c---sqrt-inequality&#34;&gt;C - Sqrt Inequality&lt;/h2&gt;
&lt;p&gt;ここにも時間を吸われた．&lt;br&gt;
&lt;code&gt;Math#sqrt&lt;/code&gt;を使うと解けそうな気がするが，精度の都合上間違いになることがある．
今回は式変換を行うと&lt;code&gt;4ab &amp;lt; a^2 + b^2 + c^2 + 2ab - 2bc - 2ca&lt;/code&gt;に持っていけるので，そこに代入するだけ．
あるいは&lt;code&gt;BigDecimal&lt;/code&gt;を使っても大丈夫らしい．&lt;/p&gt;
&lt;h2 id=&#34;d---string-equivalence&#34;&gt;D - String Equivalence&lt;/h2&gt;
&lt;p&gt;偶然通った問題．&lt;br&gt;
左側から文字を決めていくが，使える文字は自身より左に存在している一番大きい文字 + 1までしか使えないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;e---three-substrings&#34;&gt;E - Three Substrings&lt;/h2&gt;
&lt;p&gt;全探索の問題．&lt;a href=&#34;https://www.hamayanhamayan.com/entry/2020/03/15/002311&#34;&gt;ここ&lt;/a&gt;を参考にした．&lt;br&gt;
Editorialではa，b，cの順番を考慮せずにやる方法を紹介しているが，考えることが増えるので素直に全ての順列で場合分けした方が良さそう．
以降，(aの先頭) ≦ (bの先頭) ≦ (cの先頭)の場合を考える．&lt;br&gt;
まず，a中のどの箇所がbと被っているかを全探索して，配列か何かに記録する(O(n^2))．これをaとc，bとcに対してもやる．
コードだとこんな感じ．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] init(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt; length, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String b) {&lt;span style=&#34;font-style:italic&#34;&gt;// 配列の初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[] array = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt;[length]; &lt;span style=&#34;font-style:italic&#34;&gt;// lengthは十分大きい値
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    Arrays.fill(array, &lt;span style=&#34;font-weight:bold&#34;&gt;true&lt;/span&gt;);
    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; a.length(); i++) {
        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; b.length() &amp;amp;&amp;amp; i + j &amp;lt; a.length(); j++) {
            &lt;span style=&#34;font-style:italic&#34;&gt;// 文字列aの位置i以降がbと被っているかの確認
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!match(a.charAt(i + j), b.charAt(j))) { 
                array[i] = &lt;span style=&#34;font-weight:bold&#34;&gt;false&lt;/span&gt;;
                &lt;span style=&#34;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            }
        }
    }
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; array;
}
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;boolean&lt;/span&gt; match(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; a, &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;char&lt;/span&gt; b) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;return&lt;/span&gt; a == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || b == &lt;span style=&#34;font-style:italic&#34;&gt;&amp;#39;?&amp;#39;&lt;/span&gt; || a == b;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;それぞれの結果をab，ac，bcとする．&lt;br&gt;
これらの配列の&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab[i] == true&lt;/code&gt;となる&lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bc[j] == true&lt;/code&gt;となる&lt;code&gt;j&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;に対して&lt;code&gt;ac[i + j] == true&lt;/code&gt;となれば，その配置は矛盾がないことになる．
図だとこんな感じ&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/kyopuro/pana2020_e.png&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;p&gt;iの探索範囲は0からaの長さ，jの探索範囲はbの長さかiからaの終端までの長さの長い方になる．&lt;br&gt;
あとは長さの最小値を出すだけ．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC061#Dの別解</title>
      <link>https://t45k.github.io/kyopuro/abc061_d/</link>
      <pubDate>Sun, 08 Mar 2020 20:39:29 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc061_d/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc061/tasks/abc061_d&#34;&gt;ABC061 D - Score Attack&lt;/a&gt;の別解．&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/ABC061/D/MainAlt.java&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;問題内容&#34;&gt;問題内容&lt;/h2&gt;
&lt;p&gt;正負の重みの辺で構成された，閉路を含む有向グラフの単一始点終点の最長経路を求める問題．
解説では，初めに辺の重みの正負を逆転してからベルマンフォード法で最短経路を求めている．
また，経路に影響を与えうる閉路の存在を確認するために，フラグを使った方法を採用している．単純に負の閉路の存在が最短経路に影響を及ぼすわけではないことに注意．&lt;/p&gt;
&lt;h2 id=&#34;別解&#34;&gt;別解&lt;/h2&gt;
&lt;p&gt;最長路検出と閉路検出について異なる方法を紹介する．&lt;/p&gt;
&lt;h3 id=&#34;最長路検出&#34;&gt;最長路検出&lt;/h3&gt;
&lt;p&gt;今回頂点数が1,000と比較的少ないので，BFSを用いた全探索が可能である．
BFSを用いる場合は，閉路を含むことから，キューが空にならない可能性があるので，繰り返し回数を制限する必要がる．
BFSであることから，n ^ 2 回繰り返せば十分である．&lt;/p&gt;
&lt;h3 id=&#34;閉路検出&#34;&gt;閉路検出&lt;/h3&gt;
&lt;p&gt;解説ではbool型配列を用いてフラグ管理をしているが，そもそもフラグ管理をする必要はない．
各辺に対する経路長の更新を頂点の個数回繰り返し，結果が変わっていれば&lt;code&gt;inf&lt;/code&gt;を出力すれば良い．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC158の解説</title>
      <link>https://t45k.github.io/kyopuro/abc158/</link>
      <pubDate>Sat, 07 Mar 2020 22:42:19 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc158/</guid>
      <description>&lt;p&gt;四完．&lt;a href=&#34;https://github.com/t45k/kyopuro/master/tree/abc158&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---station-and-bus&#34;&gt;A - Station and Bus&lt;/h2&gt;
&lt;p&gt;連想配列にぶちこむ．&lt;/p&gt;
&lt;h2 id=&#34;b---count-balls&#34;&gt;B - Count Balls&lt;/h2&gt;
&lt;p&gt;n に対する (A + B) の商と余りを求めておき，ごちゃごちゃする．&lt;/p&gt;
&lt;h2 id=&#34;c---tax-increase&#34;&gt;C - Tax Increase&lt;/h2&gt;
&lt;p&gt;1から20,000くらいまでの整数が条件を満たすか全探索．&lt;/p&gt;
&lt;h2 id=&#34;d---string-formation&#34;&gt;D - String Formation&lt;/h2&gt;
&lt;p&gt;現在文字列が正順なのか逆順なのかを記録しておくフラグを用意する．
クエリが&lt;code&gt;1&lt;/code&gt;ならフラグ反転，クエリが&lt;code&gt;2&lt;/code&gt;の場合は，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正順ならクエリ通りに文字追加&lt;/li&gt;
&lt;li&gt;逆順ならクエリとは逆に文字追加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;をやる．
最終的にフラグを参照してから正しい方向で出力．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StringBuilder#insert&lt;/code&gt;を使うとTLEになりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>「好き好き大好き超愛してる。」読了</title>
      <link>https://t45k.github.io/blog/love_love_love_you_i_love_you/</link>
      <pubDate>Tue, 03 Mar 2020 16:20:18 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/love_love_love_you_i_love_you/</guid>
      <description>&lt;p&gt;&lt;strong&gt;愛は祈りだ。僕は祈る。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;舞城王太郎の「好き好き大好き超愛してる。」を読みました．&lt;a href=&#34;https://www.amazon.co.jp/%E5%A5%BD%E3%81%8D%E5%A5%BD%E3%81%8D%E5%A4%A7%E5%A5%BD%E3%81%8D%E8%B6%85%E6%84%9B%E3%81%97%E3%81%A6%E3%82%8B%E3%80%82-%E8%AC%9B%E8%AB%87%E7%A4%BE%E6%96%87%E5%BA%AB-%E8%88%9E%E5%9F%8E-%E7%8E%8B%E5%A4%AA%E9%83%8E/dp/4062760819/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;keywords=%E5%A5%BD%E3%81%8D%E5%A5%BD%E3%81%8D%E5%A4%A7%E5%A5%BD%E3%81%8D%E8%B6%85%E6%84%9B%E3%81%97%E3%81%A6%E3%82%8B&amp;amp;qid=1583220082&amp;amp;sr=8-1&#34;&gt;Amazon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;きっかけはDJ Technorchの楽曲「Love Love Love You I Love You」．&lt;br&gt;
舞城王太郎作品は，以前「ディスコ探偵水曜日」を読んでめちゃくちゃ読みにくいなと思っていたので，読む前に少し構えました．&lt;br&gt;
「愛は祈りだ。」の一文から始まるこの本は，一貫して「愛」と「物語」についての小説です．
一文目がこれほど全体を象徴している作品は個人的にはこれが初めてで，おそらく長く記憶に残るんだろうなぁという感じです（余談ですが，最後の一文が一番記憶に残っている作品は西尾維新の「クビシメロマンチスト」）．
読みやすい方ではありますが，理解するのは難しいと感じました．&lt;/p&gt;
&lt;p&gt;次は「みんな元気。」を読みます．&lt;/p&gt;
&lt;p&gt;最後に，きっかけとなった楽曲を貼っときます．&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lTrDY-60mMg&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;
</description>
    </item>
    
    <item>
      <title>ABC157の解説</title>
      <link>https://t45k.github.io/kyopuro/abc157/</link>
      <pubDate>Sun, 01 Mar 2020 22:53:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc157/</guid>
      <description>&lt;p&gt;なんとか四完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC157&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---duplex-printing&#34;&gt;A - Duplex Printing&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;n&lt;/code&gt;に1足して2で割るだけ&lt;/p&gt;
&lt;h2 id=&#34;b---bingo&#34;&gt;B - Bingo&lt;/h2&gt;
&lt;p&gt;実装するだけだが実装量が多くなりがちな問題&lt;/p&gt;
&lt;h2 id=&#34;c---guess-the-number&#34;&gt;C - Guess The Number&lt;/h2&gt;
&lt;p&gt;条件に合う数字を生成する方針をとるもWAになったので全探索する方向に変更．
桁数を満たす整数を昇順に条件を満たすか確認する．
余談だが，WAの原因はおそらく1桁の数字は0でも大丈夫なのを考慮していなかったため．&lt;/p&gt;
&lt;h2 id=&#34;d---friend-suggestions&#34;&gt;D - Friend Suggestions&lt;/h2&gt;
&lt;p&gt;Union-Find Treeで殴る問題．
友達関係を取得する時にUnion-Find Treeを構築します．
同時に，それぞれの人が何人友達がいるかを記録します．&lt;br&gt;
ブロック関係を取得する際に，それぞれの人に何人ブロックしている人がいるか記録します．
この時，友達候補でない人を記録する必要はありません．&lt;br&gt;
最終的に，Union-Find Treeから&lt;strong&gt;自分，友達，ブロック関係を含めた自分と繋がっている人&lt;/strong&gt;を得られるので，そこから友達の人数とブロックしている人数と自分自身の人数を引くことで答えが求まります．&lt;br&gt;
余談ですが，&lt;code&gt;Set&lt;/code&gt;をfor文で回すと異様に遅いので，for文を使う場合は&lt;code&gt;List&lt;/code&gt;を使った方が良いです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最小全域木メモ</title>
      <link>https://t45k.github.io/kyopuro/min_spanning_tree/</link>
      <pubDate>Sat, 29 Feb 2020 22:37:36 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/min_spanning_tree/</guid>
      <description>&lt;p&gt;最小全域木という概念を知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;最小全域木とは&#34;&gt;最小全域木とは&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;無向グラフが与えられた時に，その部分グラフで任意の2頂点を連結にする様な木を全域木(Spanning Tree)と言います．辺にコストがある場合に，使われる辺のコストの和を最小にする全域木を最小全域木(MST : Minimum Spanning Tree)と言います．&lt;/em&gt;（蟻本より）&lt;br&gt;
つまり，グラフが連結であることを保ったまま，コストの大きい辺を間引いてできたグラフを指します．連結であり，かつ辺のコストの和が最小なので，グラフは木となります．&lt;br&gt;
&lt;a href=&#34;https://atcoder.jp/contests/abc065/tasks/arc076_b&#34;&gt;ABC065-D&lt;/a&gt;がこの問題に該当します．&lt;/p&gt;
&lt;h2 id=&#34;解き方&#34;&gt;解き方&lt;/h2&gt;
&lt;p&gt;有名なアルゴリズムとして，クラスカル法とプリム法があります．
今回はクラスカル法を紹介します．&lt;br&gt;
クラスカル法は至って単純で，各辺をコスト順にソートし，その辺が繋ぐノードが連結でなければその辺を採用，そうでなければ不採用としMSTを作ります．
ノード同士が連結であるかどうかは，Union-Find Treeを用いて確認します．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// edges は Edge(int label1, int label2, long cost) のリスト
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;edges.sort(Comparator.comparingLong(o -&amp;gt; o.cost));
&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; UnionFindTree unionFindTree = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; UnionFindTree(n); &lt;span style=&#34;font-style:italic&#34;&gt;// 要素数nのUnion-Find Treeを構築
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;&#34;&gt;long&lt;/span&gt; sum = 0;
&lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Edge edge : edges) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;if&lt;/span&gt; (!unionFindTree.isSame(edge.label1, edge.label2)) {
        unionFindTree.unit(edge.label1, edge.label2);
        sum += edge.cost;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;辺のソートに一番計算量を食われます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ワーシャルフロイド法メモ</title>
      <link>https://t45k.github.io/kyopuro/warshallfloyd/</link>
      <pubDate>Sun, 23 Feb 2020 01:54:16 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/warshallfloyd/</guid>
      <description>&lt;p&gt;ワーシャルフロイド法というアルゴリズムを知ったのでメモ．&lt;/p&gt;
&lt;h2 id=&#34;ワーシャルフロイド法とは&#34;&gt;ワーシャルフロイド法とは&lt;/h2&gt;
&lt;p&gt;グラフのある一点から任意の点への最短距離を求めるアルゴリズム．
計算量は点の個数nに対してO(n^3)．
似たようなアルゴリズムに&lt;strong&gt;ダイクストラ法&lt;/strong&gt;があるが，あちらはある2点の最短距離をO(n^2)で求めるアルゴリズムである．
計算量が重ためなので，使う場面はかなり限られるが，知っておくと便利だと思った．&lt;/p&gt;
&lt;h2 id=&#34;実装&#34;&gt;実装&lt;/h2&gt;
&lt;p&gt;このアルゴリズムは，動的計画法を用いて最短距離を計算するというアイデアに基づいており，実装がとても簡単．
二次元配列を用いた例がこちら．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;&#34;&gt;void&lt;/span&gt; main(&lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; String[] args) {
    &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[][] graph = &lt;span style=&#34;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;&#34;&gt;int&lt;/span&gt;[n][n];
    &lt;span style=&#34;font-style:italic&#34;&gt;// 初めに無限大の値で各要素を初期化
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) {
        Arrays.fill(graph[i], Integer.MAX_VALUE / 2); &lt;span style=&#34;font-style:italic&#34;&gt;// Integer.MAX_VALUEでないことに注意
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        graph[i][i] = 0;
    }

    &lt;span style=&#34;font-style:italic&#34;&gt;// グラフの各辺を与えられた値に変更
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;font-style:italic&#34;&gt;// ここからワーシャルフロイド
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; k = 0; k &amp;lt; graph.length; k++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; graph.length; i++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 出発する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; graph.length; j++) { &lt;span style=&#34;font-style:italic&#34;&gt;// 到着する点
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;                graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); &lt;span style=&#34;font-style:italic&#34;&gt;// 中継する点をとった方が短となるか判定
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;三重ループを回すだけである．
注意点は，グラフの初期化時に&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;を代入しないこと．
&lt;code&gt;Math.min&lt;/code&gt;のタイミングでオーバーフローするため&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC156の解説</title>
      <link>https://t45k.github.io/kyopuro/abc156/</link>
      <pubDate>Sat, 22 Feb 2020 22:17:59 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc156/</guid>
      <description>&lt;p&gt;4完．&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC156&#34;&gt;解答&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---beginner&#34;&gt;A - Beginner&lt;/h2&gt;
&lt;p&gt;算数&lt;/p&gt;
&lt;h2 id=&#34;b---digits&#34;&gt;B - Digits&lt;/h2&gt;
&lt;p&gt;nが0になるまでkで割り続ける&lt;/p&gt;
&lt;h2 id=&#34;c---rally&#34;&gt;C - Rally&lt;/h2&gt;
&lt;p&gt;座標は100までなので，1~100までの座標についてそれぞれ距離の総和を全探索する．&lt;/p&gt;
&lt;h2 id=&#34;d---bouquet&#34;&gt;D - Bouquet&lt;/h2&gt;
&lt;p&gt;組み合わせの問題．&lt;br&gt;
組み合わせの総和(nCkのkを1からnまで時の和)からaとbそれぞれの組み合わせ時の場合の数(nCaとnCb)を引く．
組み合わせの総和は2^n - 1になる．
a，bの組み合わせ計算の際には，modを考慮する必要があるため，フェルマーの小定理などを利用すると良い(modInvなどでググると出てくる)．&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/blob/master/util/Utility.java#L360-L390&#34;&gt;modInvのJava実装の例&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC155の解説</title>
      <link>https://t45k.github.io/kyopuro/abc155/</link>
      <pubDate>Sun, 16 Feb 2020 22:48:43 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc155/</guid>
      <description>&lt;p&gt;無念の三冠．&lt;/p&gt;
&lt;h2 id=&#34;a---poor&#34;&gt;A - Poor&lt;/h2&gt;
&lt;p&gt;重複を調べる問題．&lt;br&gt;
愚直に比較しても良いけど，Setを使うのが早そう．&lt;br&gt;
JavaだとIntStreamからの各値にmapしてdistinctするとちょっとかっこいいかも．&lt;/p&gt;
&lt;h2 id=&#34;b---papers-please&#34;&gt;B - Papers, Please&lt;/h2&gt;
&lt;p&gt;fizzbuzzみたいな問題．&lt;br&gt;
これもIntStreamからのfilterでallMatchすると多少カッコよく書ける．&lt;/p&gt;
&lt;h2 id=&#34;c---poll&#34;&gt;C - Poll&lt;/h2&gt;
&lt;p&gt;連想配列を使って数え上げる典型的な問題．&lt;br&gt;
StringのListのソート方法をド忘れして時間を無駄に使ってしまった(正しくは&lt;code&gt;Collections#sort&lt;/code&gt;)．
C#だと文字列ソートが遅いらしく発狂している人がちらほらいた．&lt;/p&gt;
&lt;h2 id=&#34;d---pairs&#34;&gt;D - Pairs&lt;/h2&gt;
&lt;p&gt;E問題より難しいD問題．
以下の要素が重なりあってきつい．&lt;/p&gt;
&lt;h3 id=&#34;決め打ち二分探索&#34;&gt;決め打ち二分探索&lt;/h3&gt;
&lt;p&gt;決め打ち二分探索とは，単調性がある問題に対して，その問題を満たす最小の数字を探す二分探索法を指す．
単調性とは，ある数 &lt;code&gt;x&lt;/code&gt; に対してその問題が成り立つならば，&lt;code&gt;x&lt;/code&gt; 以降の数字に対しても成り立つような性質を指す．&lt;br&gt;
　実装的な視点で言うと，まず最初に単調性を満たし，真偽値を返す関数 &lt;code&gt;isOk(...)&lt;/code&gt; を用意する．
D問題だと&lt;strong&gt;ある値 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;K&lt;/code&gt; が与えられた時に，積が &lt;code&gt;x&lt;/code&gt; 以下となるペアの個数が &lt;code&gt;K&lt;/code&gt; 以上の場合は真&lt;/strong&gt;のようになる．&lt;br&gt;
　次に，二分探索の対象を用意する．このとき，始点は &lt;code&gt;isOk&lt;/code&gt; が偽となり，かつ終点は真となるような範囲を用意する．
今回だと，例えば出力が正となるような場合分けをした時，0は必ず偽なので &lt;code&gt;0 ~ 10^18&lt;/code&gt; のようになる．&lt;br&gt;
　そして二分探索する．
二分探索では通常範囲を指定するが，この時始点は &lt;code&gt;isOk&lt;/code&gt; が偽，終点は真となることを意識する．
通常の二分探索と同じく対象範囲の真ん中の値(&lt;code&gt;(始点 + 終点) / 2&lt;/code&gt;)をとり，それの真偽を判定する．
真の場合は始点から真ん中の値までを，偽の場合は真ん中の値から終点までを再起的に計算する．
この操作で，常に始点は偽，終点は真となる．
最終的に始点と終点が連続した値になるため，その終点を解として出力する．&lt;br&gt;
　要約すると，&lt;code&gt;isOk()&lt;/code&gt; を満たす範囲の下界を求める操作だと言える．&lt;/p&gt;
&lt;h3 id=&#34;lower-bound--upper-bound&#34;&gt;Lower Bound / Upper Bound&lt;/h3&gt;
&lt;p&gt;Editorialでは条件を満たす積を求めるのにしゃくとり法を用いていたが，個人的には二分探索を使った方が直感的だと感じた．
計算量もそこまで気にする必要はない．
今回は数字の重複があるため，普通に二分探索すると正しい答えが求まらない場合がある．
そのため，&lt;strong&gt;Lower Bound&lt;/strong&gt;や&lt;strong&gt;Upper Bound&lt;/strong&gt;を用いる必要がある．&lt;br&gt;
Lower Boundは指定した値&lt;strong&gt;以上&lt;/strong&gt;の要素が初めて出現する場所を取得する．&lt;br&gt;
一方，Upper Boundは指定した値&lt;strong&gt;より大きい要素&lt;/strong&gt;が初めて出現する場所を取得する．&lt;br&gt;
C++ではこれらが標準ライブラリとして提供されているが，Javaにはない．
Javaでは，&lt;code&gt;Collections#binarySearch&lt;/code&gt; の第三引数に以下の &lt;code&gt;Comparator&lt;/code&gt; オブジェクトを渡すことで実現できる．&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;font-style:italic&#34;&gt;// 例: List&amp;lt;Long&amp;gt; に対する Comparator
&lt;/span&gt;&lt;span style=&#34;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; lowerBoundComparator = (x, y) -&amp;gt; x &amp;gt;= y ? 1 : -1;
&lt;span style=&#34;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;font-weight:bold&#34;&gt;final&lt;/span&gt; Comparator&amp;lt;Long&amp;gt; upperBoundComparator = (x, y) -&amp;gt; x &amp;gt; y ? 1 : -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ちなみに，これに限らずJavaの標準ライブラリの &lt;code&gt;binarySearch&lt;/code&gt; の結果として負の数が帰ってきた場合，bit反転( &lt;code&gt;~&lt;/code&gt; 演算子)を使うと良い感じになる．&lt;/p&gt;
&lt;h3 id=&#34;負の数の大小比較&#34;&gt;負の数の大小比較&lt;/h3&gt;
&lt;p&gt;今回は負の数の大小を比較したり，負の数の席を求めたりする場面がある．
負の数の大小比較や掛け算は直感と反する場合が多く，考察段階では考えることが増えてしまうことが多い．
そのため，一度負の数を正の数に反転した上で大小比較し，最後に辻褄を合わすようにするのが良い．&lt;/p&gt;
&lt;h2 id=&#34;e---payment&#34;&gt;E - Payment&lt;/h2&gt;
&lt;p&gt;貪欲にやってもできそうな気がするけど，editorial見て正攻法で解答．&lt;br&gt;
いわゆる桁dpの問題(多分)．
今回は，その桁をちょうど払う状態(以降，&lt;strong&gt;just&lt;/strong&gt;)と1多く払う状態(以降，&lt;strong&gt;extra&lt;/strong&gt;)に分けて考える．
言い換えると，extraは繰り下がりを考慮した状態といえる．&lt;br&gt;
上の桁から考えていくと，状態遷移は以下のようになる．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;その桁のjust = (前の桁のjust + その桁の数字) か (前の桁のextra + (10 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;li&gt;その桁のextra = (前の桁のjust + その桁の数字 + 1) か (前の桁のextra + (9 - その桁の数字)) の小さい方&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これを解いていくと答えになる．&lt;br&gt;
ちなみに，最後の桁は必ずjustとなること，また，最初の桁の前についてもjustとextraを考慮する(99を100で払ったり)ことに注意．&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/T45k/kyopuro/tree/master/AtCoder/ABC/ABC155&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC154の解説</title>
      <link>https://t45k.github.io/kyopuro/abc154/</link>
      <pubDate>Sun, 09 Feb 2020 22:40:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc154/</guid>
      <description>&lt;p&gt;A~Dまで．&lt;a href=&#34;https://github.com/t45k/kyopuro/tree/master/AtCoder/ABC/abc154&#34;&gt;コード&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;a---remaining-balls&#34;&gt;A - Remaining Balls&lt;/h2&gt;
&lt;p&gt;Uで分岐&lt;/p&gt;
&lt;h2 id=&#34;b---i-miss-you&#34;&gt;B - I miss you&amp;hellip;&lt;/h2&gt;
&lt;p&gt;入力の文字列の長さの回数&amp;rsquo;x&amp;rsquo;を出力&lt;/p&gt;
&lt;h2 id=&#34;c---distinct-or-not&#34;&gt;C - Distinct or Not&lt;/h2&gt;
&lt;p&gt;連想配列を使って数字が出現したかを確認&lt;/p&gt;
&lt;h2 id=&#34;d---dice-in-line&#34;&gt;D - Dice in Line&lt;/h2&gt;
&lt;p&gt;毎回期待値計算をすると遅いので，1000(&amp;gt;= pi)までの累積和を計算しておく．
あとは連続したKの要素の期待値の合計をそれぞれ求めるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---almost-everywhere-zero&#34;&gt;E - Almost Everywhere Zero&lt;/h2&gt;
&lt;p&gt;桁DP&lt;br&gt;
0でない(= 1 ~ 9)の数字がK回出る回数を数える．
桁を上から決定していき数え上げる．
桁の決定の仕方は，&lt;strong&gt;その桁を決める前の時点でNより小さいことが確定しているかどうか&lt;/strong&gt;で変わる．&lt;br&gt;
確定している場合を&lt;code&gt;dp[|N|][K + 1]&lt;/code&gt;と表現した時に，桁iでの状態遷移は以下のようになる&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;桁i-1での状態&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;桁iでの状態&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;確定している&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k]&lt;/code&gt;&lt;br&gt;0以外を選択する: &lt;code&gt;dp[i][k] += dp[i - 1][k - 1] * 9&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;確定していない&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;桁iが0の時: Nより小さくすることはできないので何もしない&lt;br&gt;桁iが0でない時: &lt;strong&gt;1 ~ (桁iの数字 - 1)までを選択することで確定している状態に持っていくことができる&lt;/strong&gt;ので，桁i-1までに0以外の数字が出現した回数をjとすると&lt;code&gt;dp[i][j + 1] += (桁iの数字 - 1)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;桁を上から見て行った時に，0でない数字がK回出た時点で，それ以降の数字の決め方はNより小さいことが確定することに注意．&lt;br&gt;
最終的な出力は&lt;code&gt;dp[|N| - 1][K] + ((N自身が条件を満たす)? 1 : 0)&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ICSE2020の面白そうな論文をピックアップしてみた</title>
      <link>https://t45k.github.io/blog/icse2020_abst/</link>
      <pubDate>Sat, 01 Feb 2020 18:59:35 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/icse2020_abst/</guid>
      <description>&lt;p&gt;ICSEはInternational Conference of Software Engineeringの略です．
ソフトウェア工学の国際学会の中で一番ランクが高い会議です．
会議自体は5月に行われるのですが，再録された論文一覧とアブストが公開されているので，
面白そうな論文をピックアップしてみました．&lt;/p&gt;
&lt;h2 id=&#34;is-rust-used-safely-by-software-developers&#34;&gt;Is Rust Used Safely by Software Developers?&lt;/h2&gt;
&lt;p&gt;RustはC，C++に取って代わることを目指した，メモリ安全性や実行速度を売りにしているプログラミング言語です．
その特徴から，ソフトウェア開発界隈からの注目度が高まりつつあります．&lt;br&gt;
この論文では，メモリ安全性を放棄する代わりにパフォーマンスを上げる &lt;strong&gt;Unsafe Rust&lt;/strong&gt; についての調査を行っています．&lt;/p&gt;
&lt;h2 id=&#34;securing-unsafe-rust-programs-with-xrust&#34;&gt;Securing UnSafe Rust Programs with XRust&lt;/h2&gt;
&lt;p&gt;これもRustの論文です．&lt;br&gt;
XRustという，Unsafe Rustを通常のRustに移行する手法を提案しています．&lt;br&gt;
ICSEに(Unsafe)Rustに関する論文が2本採択されていることから，ソフトウェア開発におけるRustの盛り上がり具合が分かります．&lt;/p&gt;
&lt;h2 id=&#34;big-code--big-vocabulary-open-vocabulary-models-for-source-code&#34;&gt;Big Code != Big Vocabulary: Open-Vocabulary Models for Source code&lt;/h2&gt;
&lt;p&gt;キャッチーなタイトルだったのでピックアップしてみました．&lt;br&gt;
変数名などのユーザー定義の識別子があるため，ソースコードは自然言語に比べて，大規模になるとコーパスが巨大になってしまいます．
この論文では，コーパスがスケールするように，新しい言語モデルを提案しています．&lt;/p&gt;
&lt;h2 id=&#34;dlfix-context-based-code-transformation-learning-for-automated-program-repair&#34;&gt;DLFix: Context-based Code Transformation Learning for Automated Program Repair&lt;/h2&gt;
&lt;p&gt;最近のソフトウェア工学の大きなトピックの一つであるAPRの論文．&lt;br&gt;
機械学習ベースのAPRは過去のバグ修正の学習に制限があるのに対して，DLFixでは学習のレイヤを2層に分けることでうまくこの制限を回避したらしいです．&lt;/p&gt;
&lt;h2 id=&#34;a-cost-efficient-approach-to-building-in-continuous-integration&#34;&gt;A Cost-efficient Approach to Building in Continuous Integration&lt;/h2&gt;
&lt;p&gt;CIの論文．&lt;br&gt;
CIのコストはビルドを回している時間だけかかってしまい，かつ，CIの目的はバグを発見することなので，
多くのバグを発見するビルドをなるべく早い段階で回す手法を提案しています．&lt;/p&gt;
&lt;h2 id=&#34;here-we-go-again-why-is-it-difficult-for-developers-to-learn-another-programming-language&#34;&gt;Here We Go Again: Why Is It Difficult for Developers to Learn Another Programming Language?&lt;/h2&gt;
&lt;p&gt;ある言語を習得したプログラマが他の言語を習得する際の難易度に関する調査を行った研究．&lt;/p&gt;
&lt;h3 id=&#34;終わりに&#34;&gt;終わりに&lt;/h3&gt;
&lt;p&gt;以上です．
会議全体としては，機械学習とFuzzing周りの論文が多い印象です．
おそらく今年もICSE勉強会が実施されると思うので，楽しみにしてます．&lt;/p&gt;
&lt;p&gt;論文一覧は&lt;a href=&#34;https://conf.researchr.org/track/icse-2020/icse-2020-papers#event-overview&#34;&gt;ここ&lt;/a&gt;から見れます．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC153の解説</title>
      <link>https://t45k.github.io/kyopuro/abc153/</link>
      <pubDate>Sun, 26 Jan 2020 22:32:42 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc153/</guid>
      <description>&lt;p&gt;けもフレチックでした．&lt;/p&gt;
&lt;p&gt;A~Eまで&lt;/p&gt;
&lt;h2 id=&#34;a---serval-vs-monster&#34;&gt;A - Serval vs Monster&lt;/h2&gt;
&lt;p&gt;(H + A - 1) / A するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---common-raccoon-vs-monster&#34;&gt;B - Common Raccoon vs Monster&lt;/h2&gt;
&lt;p&gt;必殺技の総和をとって大小比較&lt;/p&gt;
&lt;h2 id=&#34;c---fennec-vs-monster&#34;&gt;C - Fennec vs Monster&lt;/h2&gt;
&lt;p&gt;体力が高い順にモンスターに必殺技を使い，残ったモンスターには通常攻撃&lt;/p&gt;
&lt;h2 id=&#34;d---caracal-vs-monster&#34;&gt;D - Caracal vs Monster&lt;/h2&gt;
&lt;p&gt;等比数列の和&lt;/p&gt;
&lt;h2 id=&#34;e---crested-ibis-vs-monster&#34;&gt;E - Crested Ibis vs Monster&lt;/h2&gt;
&lt;p&gt;DP&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC153&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>研究室のパソコンがmacbook proになった話</title>
      <link>https://t45k.github.io/blog/mbp/</link>
      <pubDate>Tue, 21 Jan 2020 18:11:41 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/mbp/</guid>
      <description>&lt;p&gt;組織特有の，年末に予算を使い切る目的で，新しいmacbook proを貸してもらえることになった．
モデルはMid2019の13インチモデル．
研究室内で大した業績を上げていない自分にしてはとても良いものを貸してもらえたと思う．&lt;/p&gt;
&lt;p&gt;以下，使ってみた感想&lt;/p&gt;
&lt;h2 id=&#34;良いとこ&#34;&gt;良いとこ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;速い&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今まで2015年モデルのmacbook airを借りていた．
mbpと比べるとマシンパワーが段違いであり，作業にかかる時間が大幅に短縮された．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画面が綺麗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マジで全然違う．
4年でここまで変わるのかって感じ．&lt;/p&gt;
&lt;h2 id=&#34;良くないとこ&#34;&gt;良くないとこ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;日本語入力がもっさりしてる&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;mbaでは起きていなかった現象．
英語入力から日本語入力に変更した直後が，なぜか入力してから画面に表示されるまで0.5秒くらいかかる．
ググったら結構記事がヒットしたので，何かしらの解決法はあると思う．&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;キーボードがヤバイ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使う前からバタフライキーボードがやばいことは理解していたが，使ってみるとやっぱりやばかった．
普段RealForceや青軸のゲーミングキーボード等のしっかりと押し込むタイプのキーボードを使っているので違和感が凄い．&lt;/p&gt;
&lt;p&gt;多分ボタンの押し方にコツが必要なのだと感じた．
バタフライキーボードは指先で押すと指先を痛めやすい（インターンでmbpを借りていたときはマジで一日の終わりは指先が痛かった）ので，指の腹で押すのが大事だと思う．
今でも&amp;rsquo;return&amp;rsquo;を押す右小指が痛くなってきた．
普段からmbpを使っている友達曰く，なぞるように押すのが良いらしいので慣れるしかないかなぁって気持ち．&lt;/p&gt;
&lt;p&gt;また，バタフライキーボードは薄さにわりに押す際に力が必要なので，小指などで押す&amp;rsquo;A&amp;rsquo;や&amp;rsquo;P&amp;rsquo;などが押せてないことが頻発した．&lt;/p&gt;
&lt;p&gt;エスケープが使いづらいのも地味に辛い．&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;研究室ではRealForceに接続して使うのでバタフライキーボードはまだマシだと思う．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ABC152の解説</title>
      <link>https://t45k.github.io/kyopuro/abc152/</link>
      <pubDate>Mon, 20 Jan 2020 00:27:48 +0900</pubDate>
      
      <guid>https://t45k.github.io/kyopuro/abc152/</guid>
      <description>&lt;p&gt;A~E問題まで．&lt;/p&gt;
&lt;h2 id=&#34;a---ac-or-wa&#34;&gt;A - AC or WA&lt;/h2&gt;
&lt;p&gt;if文で分岐するだけ&lt;/p&gt;
&lt;h2 id=&#34;b---comparing-strings&#34;&gt;B - Comparing Strings&lt;/h2&gt;
&lt;p&gt;辞書順なので，どれだけ長くても答えは必ず2数の小さい方の値で構成される．
2数の大きい方の値の回数だけ，小さい方の値を出力する．&lt;/p&gt;
&lt;h2 id=&#34;c---low-elements&#34;&gt;C - Low Elements&lt;/h2&gt;
&lt;p&gt;数字を順番に見て行った時に，今見ている数字が今まで見てきた中で最小の値以下であればカウントして，最小の値を更新．&lt;/p&gt;
&lt;h2 id=&#34;d---handstand-2&#34;&gt;D - Handstand 2&lt;/h2&gt;
&lt;p&gt;与えられた数の範囲内で，数字の先頭と末尾だけを見た際に同じ数を数え上げていく．
例えば334は34，398は38という感じ．
あとは組み合わせの数同士(例えば34なら43と，38なら83と)を掛け合わせるだけ．&lt;/p&gt;
&lt;h2 id=&#34;e---flatten&#34;&gt;E - Flatten&lt;/h2&gt;
&lt;p&gt;modの逆元を知らないと厳しい問題．&lt;a href=&#34;https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a#3-1-mod-p-%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8B%E5%89%B2%E3%82%8A%E7%AE%97%E3%81%A8%E3%81%AF&#34;&gt;参考&lt;/a&gt;&lt;br&gt;
この手の問題はユークリッドの互除法でGCDを求めてからLCMを求めるパターンがよくあるが，今回はオーバーフローの可能性があるため，素因数分解してからmod付きLCMを求める．
LCMがmod計算してあるので，単純に各値で割るのではなく，modの逆元を計算した上で各値をLCMにかける必要がある．&lt;/p&gt;
&lt;p&gt;ソースコード&lt;br&gt;
&lt;a href=&#34;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&#34;&gt;https://github.com/T45K/kyopuro/tree/master/AtCoder/ABC/ABC152&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>自己紹介</title>
      <link>https://t45k.github.io/about/</link>
      <pubDate>Tue, 14 Jan 2020 22:32:06 +0900</pubDate>
      
      <guid>https://t45k.github.io/about/</guid>
      <description>&lt;h1 id=&#34;こんにちは&#34;&gt;こんにちは&lt;/h1&gt;
&lt;p&gt;中川 将（なかがわ たすく）です．
大阪でウェブエンジニアをやってます．&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://t45k.github.io/img/about.jpg&#34; height=&#34;50%&#34; width=&#34;50%&#34; &gt;&lt;/p&gt;
&lt;h1 id=&#34;好き&#34;&gt;好き&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Java，Kotlin，IntelliJ&lt;/li&gt;
&lt;li&gt;バイク
&lt;ul&gt;
&lt;li&gt;Kawasaki Ninja250SLに乗ってます&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剣道
&lt;ul&gt;
&lt;li&gt;高校，大学と剣道部でした&lt;/li&gt;
&lt;li&gt;三段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;競プロ
&lt;ul&gt;
&lt;li&gt;AtCoder水色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;音楽
&lt;ul&gt;
&lt;li&gt;聴く方&lt;/li&gt;
&lt;li&gt;DJ Technorch，aran，岸田教団，etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;嫌い&#34;&gt;嫌い&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;javascript&lt;/li&gt;
&lt;li&gt;&lt;del&gt;研究&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;呟き&#34;&gt;呟き&lt;/h1&gt;
&lt;style type=&#34;text/css&#34;&gt;
    .box{
		overflow:auto;
		width:500px; height:1000px;
		padding:1px;
		color:#000000;
		background-color:#000000;
		line-height:1.5em;
    }
&lt;/style&gt;
&lt;div class=&#34;box&#34;&gt;
&lt;a class=&#34;twitter-timeline&#34; href=&#34;https://twitter.com/getupmax?ref_src=twsrc%5Etfw&#34;&gt;&lt;/a&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>APSEC2019に参加した話</title>
      <link>https://t45k.github.io/blog/apsec_2019/</link>
      <pubDate>Thu, 05 Dec 2019 20:19:32 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/apsec_2019/</guid>
      <description>&lt;p&gt;12/3~5にマレーシアで開催されたAPSECに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;apsecとは&#34;&gt;APSECとは&lt;/h2&gt;
&lt;p&gt;Asia-Pacific Software Engineering Conferenceの略です．
要するにソフトウェア工学の国際会議です．
会議ランクについては詳しくは知らないのですがそこまで高くないと思います．
投稿前に先生が，「APSECは塩漬けのネタを投稿するのにちょうど良い」と語っていたのが印象的でした．&lt;/p&gt;
&lt;h2 id=&#34;マレーシアとは&#34;&gt;マレーシアとは&lt;/h2&gt;
&lt;p&gt;こんな国です．&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;マレーシア&lt;br&gt;+ 物価が安い&lt;br&gt;+ 時差が1時間&lt;br&gt;+ 英語が通じる&lt;br&gt;&lt;br&gt;+- 暑い&lt;br&gt;&lt;br&gt;- 酒を飲める場所がかなり限られる&lt;br&gt;- 用を足した後に紙を使わない文化&lt;/p&gt;&amp;mdash; task (@getupmax) &lt;a href=&#34;https://twitter.com/getupmax/status/1202822137611862017?ref_src=twsrc%5Etfw&#34;&gt;December 6, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;img src=&#34;https://t45k.github.io/img/blog/apsec.jpg&#34; height=&#34;50%&#34; width=&#34;50%&#34;&gt;
&lt;p&gt;投稿前はあまり気乗りしなかったし，正直通るとも思ってませんでしたが，結果的には国際学会で発表できて良かったなと感じました．
質疑対応がかなりグダッてしまったので英語力（特にリスニング）を鍛えるのが重要だと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LINE DEVELOPER DAY2019に参加した話</title>
      <link>https://t45k.github.io/blog/devday/</link>
      <pubDate>Thu, 21 Nov 2019 20:16:05 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/devday/</guid>
      <description>&lt;p&gt;11/20，21に開催されたLINE DEV DAYに参加してきました．&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/devday.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;dev-dayとは&#34;&gt;DEV DAYとは&lt;/h2&gt;
&lt;p&gt;LINEが開催している社内の技術などを公開するエンジニア向けのイベントです．
今年は二日に分けて開催し，エンジニアだけでなくデザインやプロダクト的な話も盛り込んだそうです．&lt;/p&gt;
&lt;h2 id=&#34;参加したきっかけ&#34;&gt;参加したきっかけ&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;../line/&#34;&gt;LINEのインターン&lt;/a&gt;に参加した時のメンターさんがLINE SDKのリードテックになられたらしく，DEV DAYでの登壇の際にインターン中に作ったプロダクトを紹介するかもみたいな話を小耳に挟んだのがきっかけです．
また，LINEは学生向けに金銭的援助を行っており，インターン生は（交通費として）無条件で3万円もらえるというのも結構魅力的でした．&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;20日は違う会社の採用面接に参加していたため，21日だけ参加しました．
思ったより規模が大きく，たくさんの人が参加していたのが印象的でした．
感想ですが，実は当日頭痛が酷く，話を聞く余裕がなかったというのが正直なところです．
例のメンターさんの発表で，唐突にライブコーディングが始まったのだけはっきり覚えています．
また，国際学会前というのもあり，慌ただしく帰ることになってしまいました．&lt;/p&gt;
&lt;p&gt;今年はゆっくり聞く時間がなかったので，来年機会があればもう少し余裕を持って参加したいなと感じました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>インターン総括</title>
      <link>https://t45k.github.io/blog/intern/</link>
      <pubDate>Sat, 14 Sep 2019 18:26:04 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/intern/</guid>
      <description>&lt;p&gt;2019年，M1の夏休みに行ってきたインターンの所感を書きます．&lt;/p&gt;
&lt;h2 id=&#34;参加したインターン&#34;&gt;参加したインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../aws/&#34;&gt;AWS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../line/&#34;&gt;LINE KYOTO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../rakuten/&#34;&gt;楽天&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参加しなかったインターン&#34;&gt;参加しなかったインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../ntt/&#34;&gt;NTT DATA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参加できなかったインターン&#34;&gt;参加できなかったインターン&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../nssol/&#34;&gt;NSSOL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../cookpad/&#34;&gt;cookpad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;インターン全体の所感&#34;&gt;インターン全体の所感&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;意識高い学生が多い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学部の時は普段からゴリゴリ開発してるような友人はあまりいなかったため，意識の高い学生がこんなにもいることに驚きました&lt;/li&gt;
&lt;li&gt;彼らと就活で戦うことを考えるとすでに辛い&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結構B3，B4で参加してる人も多い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;意識高い&lt;/li&gt;
&lt;li&gt;当時の僕はインターンなんて考えたことなかったので&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;実力も高い&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AtCoder青とかがゴロゴロいる&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;また，自分のスキルアップ（特にweb周りの知識）に繋がったのでよかったです．&lt;/p&gt;
&lt;p&gt;反省点としては，フロントなどの今までの自分が全くやったことがないような分野に挑戦することがなかったことが挙げられます．
自分の知らない分野を一から勉強した上できちんとしたものを作ることを，期限が短いインターン中にやり切るのは難易度が高いと感じました．
こういうことは普段から興味を持って勉強した方が良いのだと考えさせられました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>楽天のインターンに参加した話</title>
      <link>https://t45k.github.io/blog/rakuten/</link>
      <pubDate>Fri, 13 Sep 2019 18:21:32 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/rakuten/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/rakuten_morning.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;p&gt;9/9~13の間，大阪で開催された楽天様のインターンに参加してきました．
写真はインターン中に頂いた無料朝食です．&lt;/p&gt;
&lt;h2 id=&#34;楽天とは&#34;&gt;楽天とは&lt;/h2&gt;
&lt;p&gt;説明不要だと思います．
日本発のメガベンチャーで，ECの楽天市場などが有名です．
会社としては，外国人を積極的に採用しており，社内公用語が英語であることが特徴です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;選考は面接だけでした．
面接の内容もそこまで突っ込んだ話はしなかったです．
面接官の社員さんと趣味が合い，ずっとバイクの話をしていました．&lt;/p&gt;
&lt;p&gt;面接に通過した後，Springを使うための簡単な事前課題が出されました．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;外国人向けサービスを作ってみようという題目でハッカソンを行いました．
学生4人 + メンターの社員さん2名で開発を行っていくという方式でした．
今までメンターの社員さんは困ったり質問があったら訊きにいく程度の存在だったので，ここまでがっつり開発に参加してくれるのは新鮮でした．
他のインターンでは作るものが指定されていたので，アイデアソンから始めるというのは初めての出来事でした（余談ですが，アイデアが他の班と完全に被っていました）．&lt;/p&gt;
&lt;p&gt;開発を始めたのは2日目の朝からでしたが，班のメンバーにはgitを使ったことなかったり，Javaを書いたりしたことがない人もいたため，午前中はそこら辺の知識の共有から始めました（これのおかげで，その後スムーズに開発することができました）．
仕様などを決める際にも，社員さんと相談しながら決めました．
AWSの時はまったく理解できなくて着いていけなくなった経験から，分からないことは質問して理解してから先に進むようにしました．
開発自体はスムーズに進み，プロダクト自体も個人的には満足いくものが作れました．
技術的な面では，空いている時間でCIやDockerなどのモダンな技術を導入できました．
しかしプレゼンがグダリすぎてしまい，コンペでは最下位という結果でした．
プロダクト自体には満足していたので，結構悔しかったです．
ただ開発は楽しかったし，会社としての楽天も食堂が無料など良い点が多くインターンには非常に満足しました．&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;インターン中のパフォーマンスが評価されて，M1の10月ごろに採用面接をしていただけました．
合計3回の面接を経て，内定を頂けました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>LINE KYOTOのインターンに参加した話</title>
      <link>https://t45k.github.io/blog/line/</link>
      <pubDate>Fri, 30 Aug 2019 18:13:39 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/line/</guid>
      <description>&lt;figure&gt;&lt;img src=&#34;https://t45k.github.io/img/blog/line.JPG&#34; width=&#34;50%&#34; height=&#34;50%&#34;/&gt;
&lt;/figure&gt;

&lt;p&gt;8/26~30の間，京都で開催されたLINE KYOTOのインターンに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;line-kyotoとは&#34;&gt;LINE KYOTOとは&lt;/h2&gt;
&lt;p&gt;LINEが何なのかは説明不要だと思うので割愛します．
LINE KYOTOは開発部しか持っていない，純粋な開発拠点であることが特徴の一つです．
また，京都という土地柄，外国人が多く所属しているのも特徴です（社員さんの半分以上が外国籍の方でした）．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;選考は技術試験と面接です．
技術試験はいわゆるプロコンみたいな問題で，普段から勉強しておくと多少有利かもしれません．
面接は，今まで自分がやってきたことを5枚程度のスライドにまとめて，その内容も踏まえて面接を行うというものでした．
僕はこれまで大規模な開発などを経験したことがなかったので，これまでやってきた研究について話しました．
結構倍率は高いようでしたが何とか通りました．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;LINEが開発しているLIFF SDKを用いて，LINE上で動くサービスを開発してみようという内容でハッカソンを行いました．
3人で一つの班を組み，4つのテーマから1つ選択するという形式で，僕たちの班はUNOを選択しました．
僕達が参加した一週間前にも同じインターンがあり，その時UNOを選択した班は結局完成しなかったと散々脅されましたが，結果的に4班中3班がUNOを選択していました．&lt;/p&gt;
&lt;p&gt;僕達の班はフロントの描画担当の子がKotlinで書くということなので，フロントからサーバまですべてKotlinで書くことにしました．
僕は楽天のインターンの事前課題でSpringを触っていたのでサーバを書くことにしました．
また，3人班のもう一人の子が超絶優秀で，最初に仕様とDB設計を行い，サーバとフロントの手伝いをしつつ，サーバとフロントと外部APIを繋げてちゃんと動くようにするという一番難しい部分を担ってくれたおかげで，僕たちの班はちゃんと動くものを作ることができました．
結果的に他の2班は完成させることができず，とても達成感と満足感を得ることができました．&lt;/p&gt;
&lt;p&gt;社員さん達もそれぞれの分野に精通した人が揃っていて，問題が発生してもすぐに解決できることが多かったです．
残業禁止で定時には全員帰られるというのもとても魅力的でした．&lt;/p&gt;
&lt;p&gt;インターン中の様子は以下の以下のLINE公式ブログにも取り上げられています．
&lt;a href=&#34;https://engineering.linecorp.com/ja/blog/kyoto-intern2019/&#34;&gt;https://engineering.linecorp.com/ja/blog/kyoto-intern2019/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;せっかくインターンに参加したので，本選考も受けることにしました．
本選考は技術テストが1回，技術面接が1回，最終面接でした．
最終面接にて無事不採用となりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWSのインターンに参加した話</title>
      <link>https://t45k.github.io/blog/aws/</link>
      <pubDate>Tue, 20 Aug 2019 18:07:41 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/aws/</guid>
      <description>&lt;p&gt;8/19~13の間，東京で開催されたAmazon Web Serviceのインターンに参加してきました．&lt;/p&gt;
&lt;h2 id=&#34;awsとは&#34;&gt;AWSとは&lt;/h2&gt;
&lt;p&gt;AWSとは，Amazon Web Serviceの略です．
AWSはAmazonのクラウド事業を担当している会社です．
Amazonのマーケットプレイスを筆頭に，様々な会社がAWSのクラウドを利用しています（クラウド事業ではシェア1位です）．
今，世界で最も勢いのあるIT会社の一つだと言えます．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;HP上には技術試験 + 面接と書いてあったのですが，なぜか面接が行われませんでした．
技術試験では実際にEC2インスタンスが与えられ，そこの上でAPIサーバを立てるという内容でした．
今までサーバ開発をしたことがなかったので，簡単にサーバが書けると噂のPHPを急いで勉強して何とか提出にこぎつけました．
問題的には明らかにDBを使わせようとしていましたが，そこまで手が回らなかったのでjsonファイルを読み書きするという手段をとりました．
結果的に通ったので良かったです．&lt;/p&gt;
&lt;h2 id=&#34;インターン&#34;&gt;インターン&lt;/h2&gt;
&lt;p&gt;実際に存在するサービスを模倣してアーキテクチャを設計するという題目で，5日間グループワークを行いました．
仕事内容的には魅力的だったのですが，いかんせん僕にネットワークの知識がなさすぎて2日目くらいから早くも着いていけなくなりました．
東京まで来て何してるんだろうって結構辛い気持ちになりました．
ただしっかり勉強した上で望めば本当に楽しいのだろうなと感じました．&lt;/p&gt;
&lt;h2 id=&#34;追記&#34;&gt;追記&lt;/h2&gt;
&lt;p&gt;このインターンは採用直結型だったので，インターン後そのまま本選考に応募しました．
技術試験，技術面接，最終面接を経て，12/24に無事不採用となりました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cookpadのインターンに参加できなかった話</title>
      <link>https://t45k.github.io/blog/cookpad/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:27 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/cookpad/</guid>
      <description>&lt;p&gt;cookpadのインターンに参加できませんでした．&lt;/p&gt;
&lt;h2 id=&#34;cookpadとは&#34;&gt;cookpadとは&lt;/h2&gt;
&lt;p&gt;料理のレシピを提供するサービスで有名な会社です．
あまり知られていないのですが（僕が知らなかっただけかもしれませんが），ITに力を入れており，技術力があるエンジニアが多く所属しています．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;技術試験 + 面接です．&lt;/p&gt;
&lt;p&gt;技術試験はプロコンのようにテストケースが用意されているわけではなく，仕様のみが与えられてそれに一致するようなコードを書くという問題でした．
仕様を満たすようにコードは書いたつもりでしたが落ちてしまいました．&lt;/p&gt;
&lt;p&gt;原因として考えられるのが，問題中APIを叩く部分があって，通常であれば言語仕様に則ってPOSTなどをすると思うのですが，当時はAPIって何?って状態だったので，直接コマンドからcurlを呼び出すように書きました．
その辺から技術不足が見抜かれたのかなぁって感じです．&lt;/p&gt;
&lt;p&gt;結構悔しかったです．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NSSOLのインターンに参加できなかった話</title>
      <link>https://t45k.github.io/blog/nssol/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:21 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/nssol/</guid>
      <description>&lt;p&gt;NSSOL様のインターンに参加できませんでした．&lt;/p&gt;
&lt;p&gt;NSSOLに行った研究室の先輩方は多く，結構興味を持っていました．
東京までの旅費や宿泊費を出してくれる上に，毎日飲み会があると聞いていたので参加できることを楽しみにしていました．&lt;/p&gt;
&lt;h2 id=&#34;nssolとは&#34;&gt;NSSOLとは&lt;/h2&gt;
&lt;p&gt;日本製鐵のシステム部門が独立してできた会社です．
母体が大きな会社であり，NSSOLも国内のSIerの中ではそれなりに大きく有名な会社です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;ES + SPI + 面接でした．&lt;/p&gt;
&lt;p&gt;SPIはテストセンターまで受けに行かなければならず面倒でした．
面接は顔合わせ程度のものだと聞いていたのでここで落とされるとは思っていませんでした．
ただ面接自体は，普段からやっていて癖になっている自虐が多く出てしまい落ちることも納得でした．
こういうジャパニーズトラディショナルカンパニーには面接でありのままの自分を見せるよりも多少は偽った方が良いのかなと思いました．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>NTT DATAのインターンに参加しなかった話</title>
      <link>https://t45k.github.io/blog/ntt/</link>
      <pubDate>Thu, 01 Aug 2019 18:32:15 +0900</pubDate>
      
      <guid>https://t45k.github.io/blog/ntt/</guid>
      <description>&lt;p&gt;NTT DATAのインターンに参加しませんでした．&lt;/p&gt;
&lt;h2 id=&#34;ntt-dataとは&#34;&gt;NTT DATAとは&lt;/h2&gt;
&lt;p&gt;国内情報系最大手のNTTのSI部門会社です．
やはり最大手らしく，日本全国から有能な人材が集まることで有名です．&lt;/p&gt;
&lt;h2 id=&#34;選考フロー&#34;&gt;選考フロー&lt;/h2&gt;
&lt;p&gt;ES + SPI + 動画提出でした．&lt;/p&gt;
&lt;p&gt;テストセンターに行かなくても自分のパソコン上でSPIを受けれたのが個人的に楽でした．
動画はインターンに対する意気込みを語れとのことでした．
これで採用か不採用かが決まるのも変な気がしましたが，とりあえずほぼ一発どりで提出したら通ってびっくりました．&lt;/p&gt;
&lt;p&gt;このインターンに参加すると合計4週間インターンに行くことになってしまうので辞退しました．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
